{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { Plugin, PluginKey, TextSelection, Selection, NodeSelection, EditorState } from 'prosemirror-state';\nimport { EditorView } from 'prosemirror-view';\nimport { keymap } from 'prosemirror-keymap';\nimport { Schema, Fragment, DOMParser, Slice, DOMSerializer, Node as Node$1 } from 'prosemirror-model';\nimport { liftTarget, ReplaceStep, ReplaceAroundStep, canSplit, canJoin, Transform, findWrapping } from 'prosemirror-transform';\nimport { createParagraphNear as createParagraphNear$1, deleteSelection as deleteSelection$1, exitCode as exitCode$1, joinBackward as joinBackward$1, joinForward as joinForward$1, lift as lift$1, liftEmptyBlock as liftEmptyBlock$1, newlineInCode as newlineInCode$1, selectNodeBackward as selectNodeBackward$1, selectNodeForward as selectNodeForward$1, selectParentNode as selectParentNode$1, selectTextblockEnd as selectTextblockEnd$1, selectTextblockStart as selectTextblockStart$1, setBlockType, wrapIn as wrapIn$1 } from 'prosemirror-commands';\nimport { liftListItem as liftListItem$1, sinkListItem as sinkListItem$1, wrapInList as wrapInList$1 } from 'prosemirror-schema-list';\n\nfunction createChainableState(config) {\n  const {\n    state,\n    transaction\n  } = config;\n  let {\n    selection\n  } = transaction;\n  let {\n    doc\n  } = transaction;\n  let {\n    storedMarks\n  } = transaction;\n  return { ...state,\n    apply: state.apply.bind(state),\n    applyTransaction: state.applyTransaction.bind(state),\n    filterTransaction: state.filterTransaction,\n    plugins: state.plugins,\n    schema: state.schema,\n    reconfigure: state.reconfigure.bind(state),\n    toJSON: state.toJSON.bind(state),\n\n    get storedMarks() {\n      return storedMarks;\n    },\n\n    get selection() {\n      return selection;\n    },\n\n    get doc() {\n      return doc;\n    },\n\n    get tr() {\n      selection = transaction.selection;\n      doc = transaction.doc;\n      storedMarks = transaction.storedMarks;\n      return transaction;\n    }\n\n  };\n}\n\nclass CommandManager {\n  constructor(props) {\n    this.editor = props.editor;\n    this.rawCommands = this.editor.extensionManager.commands;\n    this.customState = props.state;\n  }\n\n  get hasCustomState() {\n    return !!this.customState;\n  }\n\n  get state() {\n    return this.customState || this.editor.state;\n  }\n\n  get commands() {\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n    const {\n      tr\n    } = state;\n    const props = this.buildProps(tr);\n    return Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\n      const method = (...args) => {\n        const callback = command(...args)(props);\n\n        if (!tr.getMeta('preventDispatch') && !this.hasCustomState) {\n          view.dispatch(tr);\n        }\n\n        return callback;\n      };\n\n      return [name, method];\n    }));\n  }\n\n  get chain() {\n    return () => this.createChain();\n  }\n\n  get can() {\n    return () => this.createCan();\n  }\n\n  createChain(startTr, shouldDispatch = true) {\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n    const callbacks = [];\n    const hasStartTransaction = !!startTr;\n    const tr = startTr || state.tr;\n\n    const run = () => {\n      if (!hasStartTransaction && shouldDispatch && !tr.getMeta('preventDispatch') && !this.hasCustomState) {\n        view.dispatch(tr);\n      }\n\n      return callbacks.every(callback => callback === true);\n    };\n\n    const chain = { ...Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\n        const chainedCommand = (...args) => {\n          const props = this.buildProps(tr, shouldDispatch);\n          const callback = command(...args)(props);\n          callbacks.push(callback);\n          return chain;\n        };\n\n        return [name, chainedCommand];\n      })),\n      run\n    };\n    return chain;\n  }\n\n  createCan(startTr) {\n    const {\n      rawCommands,\n      state\n    } = this;\n    const dispatch = undefined;\n    const tr = startTr || state.tr;\n    const props = this.buildProps(tr, dispatch);\n    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\n      return [name, (...args) => command(...args)({ ...props,\n        dispatch\n      })];\n    }));\n    return { ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch)\n    };\n  }\n\n  buildProps(tr, shouldDispatch = true) {\n    const {\n      rawCommands,\n      editor,\n      state\n    } = this;\n    const {\n      view\n    } = editor;\n\n    if (state.storedMarks) {\n      tr.setStoredMarks(state.storedMarks);\n    }\n\n    const props = {\n      tr,\n      editor,\n      view,\n      state: createChainableState({\n        state,\n        transaction: tr\n      }),\n      dispatch: shouldDispatch ? () => undefined : undefined,\n      chain: () => this.createChain(tr),\n      can: () => this.createCan(tr),\n\n      get commands() {\n        return Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\n          return [name, (...args) => command(...args)(props)];\n        }));\n      }\n\n    };\n    return props;\n  }\n\n}\n\nclass EventEmitter {\n  constructor() {\n    this.callbacks = {};\n  }\n\n  on(event, fn) {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = [];\n    }\n\n    this.callbacks[event].push(fn);\n    return this;\n  }\n\n  emit(event, ...args) {\n    const callbacks = this.callbacks[event];\n\n    if (callbacks) {\n      callbacks.forEach(callback => callback.apply(this, args));\n    }\n\n    return this;\n  }\n\n  off(event, fn) {\n    const callbacks = this.callbacks[event];\n\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter(callback => callback !== fn);\n      } else {\n        delete this.callbacks[event];\n      }\n    }\n\n    return this;\n  }\n\n  removeAllListeners() {\n    this.callbacks = {};\n  }\n\n}\n\nfunction getExtensionField(extension, field, context) {\n  if (extension.config[field] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context);\n  }\n\n  if (typeof extension.config[field] === 'function') {\n    const value = extension.config[field].bind({ ...context,\n      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null\n    });\n    return value;\n  }\n\n  return extension.config[field];\n}\n\nfunction splitExtensions(extensions) {\n  const baseExtensions = extensions.filter(extension => extension.type === 'extension');\n  const nodeExtensions = extensions.filter(extension => extension.type === 'node');\n  const markExtensions = extensions.filter(extension => extension.type === 'mark');\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions\n  };\n}\n/**\r\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\r\n * @param extensions List of extensions\r\n */\n\n\nfunction getAttributesFromExtensions(extensions) {\n  const extensionAttributes = [];\n  const {\n    nodeExtensions,\n    markExtensions\n  } = splitExtensions(extensions);\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];\n  const defaultAttribute = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n    isRequired: false\n  };\n  extensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addGlobalAttributes = getExtensionField(extension, 'addGlobalAttributes', context);\n\n    if (!addGlobalAttributes) {\n      return;\n    } // TODO: remove `as GlobalAttributes`\n\n\n    const globalAttributes = addGlobalAttributes();\n    globalAttributes.forEach(globalAttribute => {\n      globalAttribute.types.forEach(type => {\n        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {\n          extensionAttributes.push({\n            type,\n            name,\n            attribute: { ...defaultAttribute,\n              ...attribute\n            }\n          });\n        });\n      });\n    });\n  });\n  nodeAndMarkExtensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addAttributes = getExtensionField(extension, 'addAttributes', context);\n\n    if (!addAttributes) {\n      return;\n    } // TODO: remove `as Attributes`\n\n\n    const attributes = addAttributes();\n    Object.entries(attributes).forEach(([name, attribute]) => {\n      const mergedAttr = { ...defaultAttribute,\n        ...attribute\n      };\n\n      if (attribute.isRequired && attribute.default === undefined) {\n        delete mergedAttr.default;\n      }\n\n      extensionAttributes.push({\n        type: extension.name,\n        name,\n        attribute: mergedAttr\n      });\n    });\n  });\n  return extensionAttributes;\n}\n\nfunction getNodeType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n\n    return schema.nodes[nameOrType];\n  }\n\n  return nameOrType;\n}\n\nfunction mergeAttributes(...objects) {\n  return objects.filter(item => !!item).reduce((items, item) => {\n    const mergedAttributes = { ...items\n    };\n    Object.entries(item).forEach(([key, value]) => {\n      const exists = mergedAttributes[key];\n\n      if (!exists) {\n        mergedAttributes[key] = value;\n        return;\n      }\n\n      if (key === 'class') {\n        mergedAttributes[key] = [mergedAttributes[key], value].join(' ');\n      } else if (key === 'style') {\n        mergedAttributes[key] = [mergedAttributes[key], value].join('; ');\n      } else {\n        mergedAttributes[key] = value;\n      }\n    });\n    return mergedAttributes;\n  }, {});\n}\n\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n  return extensionAttributes.filter(item => item.attribute.rendered).map(item => {\n    if (!item.attribute.renderHTML) {\n      return {\n        [item.name]: nodeOrMark.attrs[item.name]\n      };\n    }\n\n    return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});\n}\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\r\n * Optionally calls `value` as a function.\r\n * Otherwise it is returned directly.\r\n * @param value Function or any value.\r\n * @param context Optional context to bind to function.\r\n * @param props Optional props to pass to function.\r\n */\n\n\nfunction callOrReturn(value, context = undefined, ...props) {\n  if (isFunction(value)) {\n    if (context) {\n      return value.bind(context)(...props);\n    }\n\n    return value(...props);\n  }\n\n  return value;\n}\n\nfunction isEmptyObject(value = {}) {\n  return Object.keys(value).length === 0 && value.constructor === Object;\n}\n\nfunction fromString(value) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n\n  if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n    return Number(value);\n  }\n\n  if (value === 'true') {\n    return true;\n  }\n\n  if (value === 'false') {\n    return false;\n  }\n\n  return value;\n}\n/**\r\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\r\n * Cancels when `getAttrs` returned `false`.\r\n * @param parseRule ProseMirror ParseRule\r\n * @param extensionAttributes List of attributes to inject\r\n */\n\n\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n  if (parseRule.style) {\n    return parseRule;\n  }\n\n  return { ...parseRule,\n    getAttrs: node => {\n      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n\n      if (oldAttributes === false) {\n        return false;\n      }\n\n      const newAttributes = extensionAttributes.reduce((items, item) => {\n        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));\n\n        if (value === null || value === undefined) {\n          return items;\n        }\n\n        return { ...items,\n          [item.name]: value\n        };\n      }, {});\n      return { ...oldAttributes,\n        ...newAttributes\n      };\n    }\n  };\n}\n\nfunction cleanUpSchemaItem(data) {\n  return Object.fromEntries(Object.entries(data).filter(([key, value]) => {\n    if (key === 'attrs' && isEmptyObject(value)) {\n      return false;\n    }\n\n    return value !== null && value !== undefined;\n  }));\n}\n\nfunction getSchemaByResolvedExtensions(extensions) {\n  var _a;\n\n  const allAttributes = getAttributesFromExtensions(extensions);\n  const {\n    nodeExtensions,\n    markExtensions\n  } = splitExtensions(extensions);\n  const topNode = (_a = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))) === null || _a === void 0 ? void 0 : _a.name;\n  const nodes = Object.fromEntries(nodeExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const extraNodeFields = extensions.reduce((fields, e) => {\n      const extendNodeSchema = getExtensionField(e, 'extendNodeSchema', context);\n      return { ...fields,\n        ...(extendNodeSchema ? extendNodeSchema(extension) : {})\n      };\n    }, {});\n    const schema = cleanUpSchemaItem({ ...extraNodeFields,\n      content: callOrReturn(getExtensionField(extension, 'content', context)),\n      marks: callOrReturn(getExtensionField(extension, 'marks', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      inline: callOrReturn(getExtensionField(extension, 'inline', context)),\n      atom: callOrReturn(getExtensionField(extension, 'atom', context)),\n      selectable: callOrReturn(getExtensionField(extension, 'selectable', context)),\n      draggable: callOrReturn(getExtensionField(extension, 'draggable', context)),\n      code: callOrReturn(getExtensionField(extension, 'code', context)),\n      defining: callOrReturn(getExtensionField(extension, 'defining', context)),\n      isolating: callOrReturn(getExtensionField(extension, 'isolating', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        var _a;\n\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    });\n    const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n    }\n\n    const renderHTML = getExtensionField(extension, 'renderHTML', context);\n\n    if (renderHTML) {\n      schema.toDOM = node => renderHTML({\n        node,\n        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)\n      });\n    }\n\n    const renderText = getExtensionField(extension, 'renderText', context);\n\n    if (renderText) {\n      schema.toText = renderText;\n    }\n\n    return [extension.name, schema];\n  }));\n  const marks = Object.fromEntries(markExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const extraMarkFields = extensions.reduce((fields, e) => {\n      const extendMarkSchema = getExtensionField(e, 'extendMarkSchema', context);\n      return { ...fields,\n        ...(extendMarkSchema ? extendMarkSchema(extension) : {})\n      };\n    }, {});\n    const schema = cleanUpSchemaItem({ ...extraMarkFields,\n      inclusive: callOrReturn(getExtensionField(extension, 'inclusive', context)),\n      excludes: callOrReturn(getExtensionField(extension, 'excludes', context)),\n      group: callOrReturn(getExtensionField(extension, 'group', context)),\n      spanning: callOrReturn(getExtensionField(extension, 'spanning', context)),\n      code: callOrReturn(getExtensionField(extension, 'code', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        var _a;\n\n        return [extensionAttribute.name, {\n          default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n        }];\n      }))\n    });\n    const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n    }\n\n    const renderHTML = getExtensionField(extension, 'renderHTML', context);\n\n    if (renderHTML) {\n      schema.toDOM = mark => renderHTML({\n        mark,\n        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)\n      });\n    }\n\n    return [extension.name, schema];\n  }));\n  return new Schema({\n    topNode,\n    nodes,\n    marks\n  });\n}\n\nfunction getSchemaTypeByName(name, schema) {\n  return schema.nodes[name] || schema.marks[name] || null;\n}\n\nfunction isExtensionRulesEnabled(extension, enabled) {\n  if (Array.isArray(enabled)) {\n    return enabled.some(enabledExtension => {\n      const name = typeof enabledExtension === 'string' ? enabledExtension : enabledExtension.name;\n      return name === extension.name;\n    });\n  }\n\n  return enabled;\n}\n\nconst getTextContentFromNodes = ($from, maxMatch = 500) => {\n  let textBefore = '';\n  $from.parent.nodesBetween(Math.max(0, $from.parentOffset - maxMatch), $from.parentOffset, (node, pos, parent, index) => {\n    var _a, _b, _c;\n\n    textBefore += ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {\n      node,\n      pos,\n      parent,\n      index\n    })) || ((_c = $from.nodeBefore) === null || _c === void 0 ? void 0 : _c.text) || '%leaf%';\n  });\n  return textBefore;\n};\n\nfunction isRegExp(value) {\n  return Object.prototype.toString.call(value) === '[object RegExp]';\n}\n\nclass InputRule {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n\n}\n\nconst inputRuleMatcherHandler = (text, find) => {\n  if (isRegExp(find)) {\n    return find.exec(text);\n  }\n\n  const inputRuleMatch = find(text);\n\n  if (!inputRuleMatch) {\n    return null;\n  }\n\n  const result = [];\n  result.push(inputRuleMatch.text);\n  result.index = inputRuleMatch.index;\n  result.input = text;\n  result.data = inputRuleMatch.data;\n\n  if (inputRuleMatch.replaceWith) {\n    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n      console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\n    }\n\n    result.push(inputRuleMatch.replaceWith);\n  }\n\n  return result;\n};\n\nfunction run$1(config) {\n  var _a;\n\n  const {\n    editor,\n    from,\n    to,\n    text,\n    rules,\n    plugin\n  } = config;\n  const {\n    view\n  } = editor;\n\n  if (view.composing) {\n    return false;\n  }\n\n  const $from = view.state.doc.resolve(from);\n\n  if ( // check for code node\n  $from.parent.type.spec.code // check for code mark\n  || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find(mark => mark.type.spec.code))) {\n    return false;\n  }\n\n  let matched = false;\n  const textBefore = getTextContentFromNodes($from) + text;\n  rules.forEach(rule => {\n    if (matched) {\n      return;\n    }\n\n    const match = inputRuleMatcherHandler(textBefore, rule.find);\n\n    if (!match) {\n      return;\n    }\n\n    const tr = view.state.tr;\n    const state = createChainableState({\n      state: view.state,\n      transaction: tr\n    });\n    const range = {\n      from: from - (match[0].length - text.length),\n      to\n    };\n    const {\n      commands,\n      chain,\n      can\n    } = new CommandManager({\n      editor,\n      state\n    });\n    const handler = rule.handler({\n      state,\n      range,\n      match,\n      commands,\n      chain,\n      can\n    }); // stop if there are no changes\n\n    if (handler === null || !tr.steps.length) {\n      return;\n    } // store transform as meta data\n    // so we can undo input rules within the `undoInputRules` command\n\n\n    tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text\n    });\n    view.dispatch(tr);\n    matched = true;\n  });\n  return matched;\n}\n/**\r\n * Create an input rules plugin. When enabled, it will cause text\r\n * input that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\n\n\nfunction inputRulesPlugin(props) {\n  const {\n    editor,\n    rules\n  } = props;\n  const plugin = new Plugin({\n    state: {\n      init() {\n        return null;\n      },\n\n      apply(tr, prev) {\n        const stored = tr.getMeta(plugin);\n\n        if (stored) {\n          return stored;\n        }\n\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n\n    },\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run$1({\n          editor,\n          from,\n          to,\n          text,\n          rules,\n          plugin\n        });\n      },\n\n      handleDOMEvents: {\n        compositionend: view => {\n          setTimeout(() => {\n            const {\n              $cursor\n            } = view.state.selection;\n\n            if ($cursor) {\n              run$1({\n                editor,\n                from: $cursor.pos,\n                to: $cursor.pos,\n                text: '',\n                rules,\n                plugin\n              });\n            }\n          });\n          return false;\n        }\n      },\n\n      // add support for input rules to trigger on enter\n      // this is useful for example for code blocks\n      handleKeyDown(view, event) {\n        if (event.key !== 'Enter') {\n          return false;\n        }\n\n        const {\n          $cursor\n        } = view.state.selection;\n\n        if ($cursor) {\n          return run$1({\n            editor,\n            from: $cursor.pos,\n            to: $cursor.pos,\n            text: '\\n',\n            rules,\n            plugin\n          });\n        }\n\n        return false;\n      }\n\n    },\n    // @ts-ignore\n    isInputRules: true\n  });\n  return plugin;\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\n\nclass PasteRule {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n\n}\n\nconst pasteRuleMatcherHandler = (text, find) => {\n  if (isRegExp(find)) {\n    return [...text.matchAll(find)];\n  }\n\n  const matches = find(text);\n\n  if (!matches) {\n    return [];\n  }\n\n  return matches.map(pasteRuleMatch => {\n    const result = [];\n    result.push(pasteRuleMatch.text);\n    result.index = pasteRuleMatch.index;\n    result.input = text;\n    result.data = pasteRuleMatch.data;\n\n    if (pasteRuleMatch.replaceWith) {\n      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n        console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\n      }\n\n      result.push(pasteRuleMatch.replaceWith);\n    }\n\n    return result;\n  });\n};\n\nfunction run(config) {\n  const {\n    editor,\n    state,\n    from,\n    to,\n    rule\n  } = config;\n  const {\n    commands,\n    chain,\n    can\n  } = new CommandManager({\n    editor,\n    state\n  });\n  const handlers = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isTextblock || node.type.spec.code) {\n      return;\n    }\n\n    const resolvedFrom = Math.max(from, pos);\n    const resolvedTo = Math.min(to, pos + node.content.size);\n    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\\ufffc');\n    const matches = pasteRuleMatcherHandler(textToMatch, rule.find);\n    matches.forEach(match => {\n      if (match.index === undefined) {\n        return;\n      }\n\n      const start = resolvedFrom + match.index + 1;\n      const end = start + match[0].length;\n      const range = {\n        from: state.tr.mapping.map(start),\n        to: state.tr.mapping.map(end)\n      };\n      const handler = rule.handler({\n        state,\n        range,\n        match,\n        commands,\n        chain,\n        can\n      });\n      handlers.push(handler);\n    });\n  });\n  const success = handlers.every(handler => handler !== null);\n  return success;\n}\n/**\r\n * Create an paste rules plugin. When enabled, it will cause pasted\r\n * text that matches any of the given rules to trigger the rule’s\r\n * action.\r\n */\n\n\nfunction pasteRulesPlugin(props) {\n  const {\n    editor,\n    rules\n  } = props;\n  let dragSourceElement = null;\n  let isPastedFromProseMirror = false;\n  let isDroppedFromProseMirror = false;\n  const plugins = rules.map(rule => {\n    return new Plugin({\n      // we register a global drag handler to track the current drag source element\n      view(view) {\n        const handleDragstart = event => {\n          var _a;\n\n          dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;\n        };\n\n        window.addEventListener('dragstart', handleDragstart);\n        return {\n          destroy() {\n            window.removeEventListener('dragstart', handleDragstart);\n          }\n\n        };\n      },\n\n      props: {\n        handleDOMEvents: {\n          drop: view => {\n            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\n            return false;\n          },\n          paste: (view, event) => {\n            var _a;\n\n            const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/html');\n            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes('data-pm-slice'));\n            return false;\n          }\n        }\n      },\n      appendTransaction: (transactions, oldState, state) => {\n        const transaction = transactions[0];\n        const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror;\n        const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror;\n\n        if (!isPaste && !isDrop) {\n          return;\n        } // stop if there is no changed range\n\n\n        const from = oldState.doc.content.findDiffStart(state.doc.content);\n        const to = oldState.doc.content.findDiffEnd(state.doc.content);\n\n        if (!isNumber(from) || !to || from === to.b) {\n          return;\n        } // build a chainable state\n        // so we can use a single transaction for all paste rules\n\n\n        const tr = state.tr;\n        const chainableState = createChainableState({\n          state,\n          transaction: tr\n        });\n        const handler = run({\n          editor,\n          state: chainableState,\n          from: Math.max(from - 1, 0),\n          to: to.b,\n          rule\n        }); // stop if there are no changes\n\n        if (!handler || !tr.steps.length) {\n          return;\n        }\n\n        return tr;\n      }\n    });\n  });\n  return plugins;\n}\n\nfunction findDuplicates(items) {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index);\n  return [...new Set(filtered)];\n}\n\nclass ExtensionManager {\n  constructor(extensions, editor) {\n    this.splittableMarks = [];\n    this.editor = editor;\n    this.extensions = ExtensionManager.resolve(extensions);\n    this.schema = getSchemaByResolvedExtensions(this.extensions);\n    this.extensions.forEach(extension => {\n      var _a; // store extension storage in editor\n\n\n      this.editor.extensionStorage[extension.name] = extension.storage;\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n\n      if (extension.type === 'mark') {\n        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, 'keepOnSplit', context))) !== null && _a !== void 0 ? _a : true;\n\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name);\n        }\n      }\n\n      const onBeforeCreate = getExtensionField(extension, 'onBeforeCreate', context);\n\n      if (onBeforeCreate) {\n        this.editor.on('beforeCreate', onBeforeCreate);\n      }\n\n      const onCreate = getExtensionField(extension, 'onCreate', context);\n\n      if (onCreate) {\n        this.editor.on('create', onCreate);\n      }\n\n      const onUpdate = getExtensionField(extension, 'onUpdate', context);\n\n      if (onUpdate) {\n        this.editor.on('update', onUpdate);\n      }\n\n      const onSelectionUpdate = getExtensionField(extension, 'onSelectionUpdate', context);\n\n      if (onSelectionUpdate) {\n        this.editor.on('selectionUpdate', onSelectionUpdate);\n      }\n\n      const onTransaction = getExtensionField(extension, 'onTransaction', context);\n\n      if (onTransaction) {\n        this.editor.on('transaction', onTransaction);\n      }\n\n      const onFocus = getExtensionField(extension, 'onFocus', context);\n\n      if (onFocus) {\n        this.editor.on('focus', onFocus);\n      }\n\n      const onBlur = getExtensionField(extension, 'onBlur', context);\n\n      if (onBlur) {\n        this.editor.on('blur', onBlur);\n      }\n\n      const onDestroy = getExtensionField(extension, 'onDestroy', context);\n\n      if (onDestroy) {\n        this.editor.on('destroy', onDestroy);\n      }\n    });\n  }\n\n  static resolve(extensions) {\n    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));\n    const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name));\n\n    if (duplicatedNames.length) {\n      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map(item => `'${item}'`).join(', ')}]. This can lead to issues.`);\n    }\n\n    return resolvedExtensions;\n  }\n\n  static flatten(extensions) {\n    return extensions.map(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage\n      };\n      const addExtensions = getExtensionField(extension, 'addExtensions', context);\n\n      if (addExtensions) {\n        return [extension, ...this.flatten(addExtensions())];\n      }\n\n      return extension;\n    }) // `Infinity` will break TypeScript so we set a number that is probably high enough\n    .flat(10);\n  }\n\n  static sort(extensions) {\n    const defaultPriority = 100;\n    return extensions.sort((a, b) => {\n      const priorityA = getExtensionField(a, 'priority') || defaultPriority;\n      const priorityB = getExtensionField(b, 'priority') || defaultPriority;\n\n      if (priorityA > priorityB) {\n        return -1;\n      }\n\n      if (priorityA < priorityB) {\n        return 1;\n      }\n\n      return 0;\n    });\n  }\n\n  get commands() {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const addCommands = getExtensionField(extension, 'addCommands', context);\n\n      if (!addCommands) {\n        return commands;\n      }\n\n      return { ...commands,\n        ...addCommands()\n      };\n    }, {});\n  }\n\n  get plugins() {\n    const {\n      editor\n    } = this; // With ProseMirror, first plugins within an array are executed first.\n    // In tiptap, we provide the ability to override plugins,\n    // so it feels more natural to run plugins at the end of an array first.\n    // That’s why we have to reverse the `extensions` array and sort again\n    // based on the `priority` option.\n\n    const extensions = ExtensionManager.sort([...this.extensions].reverse());\n    const inputRules = [];\n    const pasteRules = [];\n    const allPlugins = extensions.map(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const plugins = [];\n      const addKeyboardShortcuts = getExtensionField(extension, 'addKeyboardShortcuts', context);\n\n      if (addKeyboardShortcuts) {\n        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {\n          return [shortcut, () => method({\n            editor\n          })];\n        }));\n        const keyMapPlugin = keymap(bindings);\n        plugins.push(keyMapPlugin);\n      }\n\n      const addInputRules = getExtensionField(extension, 'addInputRules', context);\n\n      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n        inputRules.push(...addInputRules());\n      }\n\n      const addPasteRules = getExtensionField(extension, 'addPasteRules', context);\n\n      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n        pasteRules.push(...addPasteRules());\n      }\n\n      const addProseMirrorPlugins = getExtensionField(extension, 'addProseMirrorPlugins', context);\n\n      if (addProseMirrorPlugins) {\n        const proseMirrorPlugins = addProseMirrorPlugins();\n        plugins.push(...proseMirrorPlugins);\n      }\n\n      return plugins;\n    }).flat();\n    return [inputRulesPlugin({\n      editor,\n      rules: inputRules\n    }), ...pasteRulesPlugin({\n      editor,\n      rules: pasteRules\n    }), ...allPlugins];\n  }\n\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions);\n  }\n\n  get nodeViews() {\n    const {\n      editor\n    } = this;\n    const {\n      nodeExtensions\n    } = splitExtensions(this.extensions);\n    return Object.fromEntries(nodeExtensions.filter(extension => !!getExtensionField(extension, 'addNodeView')).map(extension => {\n      const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name);\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n        type: getNodeType(extension.name, this.schema)\n      };\n      const addNodeView = getExtensionField(extension, 'addNodeView', context);\n\n      if (!addNodeView) {\n        return [];\n      }\n\n      const nodeview = (node, view, getPos, decorations) => {\n        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n        return addNodeView()({\n          editor,\n          node,\n          getPos,\n          decorations,\n          HTMLAttributes,\n          extension\n        });\n      };\n\n      return [extension.name, nodeview];\n    }));\n  }\n\n} // see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\n\n\nfunction getType(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\n\nfunction isPlainObject(value) {\n  if (getType(value) !== 'Object') {\n    return false;\n  }\n\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\n}\n\nfunction mergeDeep(target, source) {\n  const output = { ...target\n  };\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, {\n            [key]: source[key]\n          });\n        } else {\n          output[key] = mergeDeep(target[key], source[key]);\n        }\n      } else {\n        Object.assign(output, {\n          [key]: source[key]\n        });\n      }\n    });\n  }\n\n  return output;\n}\n\nclass Extension {\n  constructor(config = {}) {\n    this.type = 'extension';\n    this.name = 'extension';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = { ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    } // TODO: remove `addOptions` fallback\n\n\n    this.options = this.config.defaultOptions;\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n\n  static create(config = {}) {\n    return new Extension(config);\n  }\n\n  configure(options = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n\n  extend(extendedConfig = {}) {\n    const extension = new Extension(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n\n}\n\nfunction getTextBetween(startNode, range, options) {\n  const {\n    from,\n    to\n  } = range;\n  const {\n    blockSeparator = '\\n\\n',\n    textSerializers = {}\n  } = options || {};\n  let text = '';\n  let separated = true;\n  startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n    var _a;\n\n    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];\n\n    if (textSerializer) {\n      if (node.isBlock && !separated) {\n        text += blockSeparator;\n        separated = true;\n      }\n\n      if (parent) {\n        text += textSerializer({\n          node,\n          pos,\n          parent,\n          index,\n          range\n        });\n      }\n    } else if (node.isText) {\n      text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos); // eslint-disable-line\n\n      separated = false;\n    } else if (node.isBlock && !separated) {\n      text += blockSeparator;\n      separated = true;\n    }\n  });\n  return text;\n}\n\nfunction getTextSerializersFromSchema(schema) {\n  return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));\n}\n\nconst ClipboardTextSerializer = Extension.create({\n  name: 'clipboardTextSerializer',\n\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('clipboardTextSerializer'),\n      props: {\n        clipboardTextSerializer: () => {\n          const {\n            editor\n          } = this;\n          const {\n            state,\n            schema\n          } = editor;\n          const {\n            doc,\n            selection\n          } = state;\n          const {\n            ranges\n          } = selection;\n          const from = Math.min(...ranges.map(range => range.$from.pos));\n          const to = Math.max(...ranges.map(range => range.$to.pos));\n          const textSerializers = getTextSerializersFromSchema(schema);\n          const range = {\n            from,\n            to\n          };\n          return getTextBetween(doc, range, {\n            textSerializers\n          });\n        }\n      }\n    })];\n  }\n\n});\n\nconst blur = () => ({\n  editor,\n  view\n}) => {\n  requestAnimationFrame(() => {\n    var _a;\n\n    if (!editor.isDestroyed) {\n      view.dom.blur(); // Browsers should remove the caret on blur but safari does not.\n      // See: https://github.com/ueberdosis/tiptap/issues/2405\n\n      (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\n    }\n  });\n  return true;\n};\n\nconst clearContent = (emitUpdate = false) => ({\n  commands\n}) => {\n  return commands.setContent('', emitUpdate);\n};\n\nconst clearNodes = () => ({\n  state,\n  tr,\n  dispatch\n}) => {\n  const {\n    selection\n  } = tr;\n  const {\n    ranges\n  } = selection;\n\n  if (!dispatch) {\n    return true;\n  }\n\n  ranges.forEach(({\n    $from,\n    $to\n  }) => {\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return;\n      }\n\n      const {\n        doc,\n        mapping\n      } = tr;\n      const $mappedFrom = doc.resolve(mapping.map(pos));\n      const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\n      const nodeRange = $mappedFrom.blockRange($mappedTo);\n\n      if (!nodeRange) {\n        return;\n      }\n\n      const targetLiftDepth = liftTarget(nodeRange);\n\n      if (node.type.isTextblock) {\n        const {\n          defaultType\n        } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\n        tr.setNodeMarkup(nodeRange.start, defaultType);\n      }\n\n      if (targetLiftDepth || targetLiftDepth === 0) {\n        tr.lift(nodeRange, targetLiftDepth);\n      }\n    });\n  });\n  return true;\n};\n\nconst command = fn => props => {\n  return fn(props);\n};\n\nconst createParagraphNear = () => ({\n  state,\n  dispatch\n}) => {\n  return createParagraphNear$1(state, dispatch);\n};\n\nconst deleteNode = typeOrName => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const $pos = tr.selection.$anchor;\n\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n\n    if (node.type === type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst deleteRange = range => ({\n  tr,\n  dispatch\n}) => {\n  const {\n    from,\n    to\n  } = range;\n\n  if (dispatch) {\n    tr.delete(from, to);\n  }\n\n  return true;\n};\n\nconst deleteSelection = () => ({\n  state,\n  dispatch\n}) => {\n  return deleteSelection$1(state, dispatch);\n};\n\nconst enter = () => ({\n  commands\n}) => {\n  return commands.keyboardShortcut('Enter');\n};\n\nconst exitCode = () => ({\n  state,\n  dispatch\n}) => {\n  return exitCode$1(state, dispatch);\n};\n/**\r\n * Check if object1 includes object2\r\n * @param object1 Object\r\n * @param object2 Object\r\n */\n\n\nfunction objectIncludes(object1, object2, options = {\n  strict: true\n}) {\n  const keys = Object.keys(object2);\n\n  if (!keys.length) {\n    return true;\n  }\n\n  return keys.every(key => {\n    if (options.strict) {\n      return object2[key] === object1[key];\n    }\n\n    if (isRegExp(object2[key])) {\n      return object2[key].test(object1[key]);\n    }\n\n    return object2[key] === object1[key];\n  });\n}\n\nfunction findMarkInSet(marks, type, attributes = {}) {\n  return marks.find(item => {\n    return item.type === type && objectIncludes(item.attrs, attributes);\n  });\n}\n\nfunction isMarkInSet(marks, type, attributes = {}) {\n  return !!findMarkInSet(marks, type, attributes);\n}\n\nfunction getMarkRange($pos, type, attributes = {}) {\n  if (!$pos || !type) {\n    return;\n  }\n\n  let start = $pos.parent.childAfter($pos.parentOffset);\n\n  if ($pos.parentOffset === start.offset && start.offset !== 0) {\n    start = $pos.parent.childBefore($pos.parentOffset);\n  }\n\n  if (!start.node) {\n    return;\n  }\n\n  const mark = findMarkInSet([...start.node.marks], type, attributes);\n\n  if (!mark) {\n    return;\n  }\n\n  let startIndex = start.index;\n  let startPos = $pos.start() + start.offset;\n  let endIndex = startIndex + 1;\n  let endPos = startPos + start.node.nodeSize;\n  findMarkInSet([...start.node.marks], type, attributes);\n\n  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  }\n\n  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {\n    endPos += $pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\n\nfunction getMarkType(nameOrType, schema) {\n  if (typeof nameOrType === 'string') {\n    if (!schema.marks[nameOrType]) {\n      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n\n    return schema.marks[nameOrType];\n  }\n\n  return nameOrType;\n}\n\nconst extendMarkRange = (typeOrName, attributes = {}) => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  const type = getMarkType(typeOrName, state.schema);\n  const {\n    doc,\n    selection\n  } = tr;\n  const {\n    $from,\n    from,\n    to\n  } = selection;\n\n  if (dispatch) {\n    const range = getMarkRange($from, type, attributes);\n\n    if (range && range.from <= from && range.to >= to) {\n      const newSelection = TextSelection.create(doc, range.from, range.to);\n      tr.setSelection(newSelection);\n    }\n  }\n\n  return true;\n};\n\nconst first = commands => props => {\n  const items = typeof commands === 'function' ? commands(props) : commands;\n\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nfunction isClass(value) {\n  var _a;\n\n  if (((_a = value.constructor) === null || _a === void 0 ? void 0 : _a.toString().substring(0, 5)) !== 'class') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isObject(value) {\n  return value && typeof value === 'object' && !Array.isArray(value) && !isClass(value);\n}\n\nfunction isTextSelection(value) {\n  return isObject(value) && value instanceof TextSelection;\n}\n\nfunction minMax(value = 0, min = 0, max = 0) {\n  return Math.min(Math.max(value, min), max);\n}\n\nfunction resolveFocusPosition(doc, position = null) {\n  if (!position) {\n    return null;\n  }\n\n  const selectionAtStart = Selection.atStart(doc);\n  const selectionAtEnd = Selection.atEnd(doc);\n\n  if (position === 'start' || position === true) {\n    return selectionAtStart;\n  }\n\n  if (position === 'end') {\n    return selectionAtEnd;\n  }\n\n  const minPos = selectionAtStart.from;\n  const maxPos = selectionAtEnd.to;\n\n  if (position === 'all') {\n    return TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\n  }\n\n  return TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\n}\n\nfunction isiOS() {\n  return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform) // iPad on iOS 13 detection\n  || navigator.userAgent.includes('Mac') && 'ontouchend' in document;\n}\n\nconst focus = (position = null, options = {}) => ({\n  editor,\n  view,\n  tr,\n  dispatch\n}) => {\n  options = {\n    scrollIntoView: true,\n    ...options\n  };\n\n  const delayedFocus = () => {\n    // focus within `requestAnimationFrame` breaks focus on iOS\n    // so we have to call this\n    if (isiOS()) {\n      view.dom.focus();\n    } // For React we have to focus asynchronously. Otherwise wild things happen.\n    // see: https://github.com/ueberdosis/tiptap/issues/1520\n\n\n    requestAnimationFrame(() => {\n      if (!editor.isDestroyed) {\n        view.focus();\n\n        if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {\n          editor.commands.scrollIntoView();\n        }\n      }\n    });\n  };\n\n  if (view.hasFocus() && position === null || position === false) {\n    return true;\n  } // we don’t try to resolve a NodeSelection or CellSelection\n\n\n  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n    delayedFocus();\n    return true;\n  } // pass through tr.doc instead of editor.state.doc\n  // since transactions could change the editors state before this command has been run\n\n\n  const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;\n  const isSameSelection = editor.state.selection.eq(selection);\n\n  if (dispatch) {\n    if (!isSameSelection) {\n      tr.setSelection(selection);\n    } // `tr.setSelection` resets the stored marks\n    // so we’ll restore them if the selection is the same as before\n\n\n    if (isSameSelection && tr.storedMarks) {\n      tr.setStoredMarks(tr.storedMarks);\n    }\n\n    delayedFocus();\n  }\n\n  return true;\n};\n\nconst forEach = (items, fn) => props => {\n  return items.every((item, index) => fn(item, { ...props,\n    index\n  }));\n};\n\nconst insertContent = (value, options) => ({\n  tr,\n  commands\n}) => {\n  return commands.insertContentAt({\n    from: tr.selection.from,\n    to: tr.selection.to\n  }, value, options);\n};\n\nfunction elementFromString(value) {\n  // add a wrapper to preserve leading and trailing whitespace\n  const wrappedValue = `<body>${value}</body>`;\n  return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;\n}\n\nfunction createNodeFromContent(content, schema, options) {\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options\n  };\n\n  if (typeof content === 'object' && content !== null) {\n    try {\n      if (Array.isArray(content)) {\n        return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)));\n      }\n\n      return schema.nodeFromJSON(content);\n    } catch (error) {\n      console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error);\n      return createNodeFromContent('', schema, options);\n    }\n  }\n\n  if (typeof content === 'string') {\n    const parser = DOMParser.fromSchema(schema);\n    return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);\n  }\n\n  return createNodeFromContent('', schema, options);\n} // source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\n\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  const last = tr.steps.length - 1;\n\n  if (last < startLen) {\n    return;\n  }\n\n  const step = tr.steps[last];\n\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return;\n  }\n\n  const map = tr.mapping.maps[last];\n  let end = 0;\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo;\n    }\n  });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\n\nconst isFragment = nodeOrFragment => {\n  return nodeOrFragment.toString().startsWith('<');\n};\n\nconst insertContentAt = (position, value, options) => ({\n  tr,\n  dispatch,\n  editor\n}) => {\n  if (dispatch) {\n    options = {\n      parseOptions: {},\n      updateSelection: true,\n      ...options\n    };\n    const content = createNodeFromContent(value, editor.schema, {\n      parseOptions: {\n        preserveWhitespace: 'full',\n        ...options.parseOptions\n      }\n    }); // don’t dispatch an empty fragment because this can lead to strange errors\n\n    if (content.toString() === '<>') {\n      return true;\n    }\n\n    let {\n      from,\n      to\n    } = typeof position === 'number' ? {\n      from: position,\n      to: position\n    } : position;\n    let isOnlyTextContent = true;\n    let isOnlyBlockContent = true;\n    const nodes = isFragment(content) ? content : [content];\n    nodes.forEach(node => {\n      // check if added node is valid\n      node.check();\n      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;\n      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n    }); // check if we can replace the wrapping node by\n    // the newly inserted content\n    // example:\n    // replace an empty paragraph by an inserted image\n    // instead of inserting the image below the paragraph\n\n    if (from === to && isOnlyBlockContent) {\n      const {\n        parent\n      } = tr.doc.resolve(from);\n      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n\n      if (isEmptyTextBlock) {\n        from -= 1;\n        to += 1;\n      }\n    } // if there is only plain text we have to use `insertText`\n    // because this will keep the current marks\n\n\n    if (isOnlyTextContent) {\n      tr.insertText(value, from, to);\n    } else {\n      tr.replaceWith(from, to, content);\n    } // set cursor at end of inserted content\n\n\n    if (options.updateSelection) {\n      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n    }\n  }\n\n  return true;\n};\n\nconst joinBackward = () => ({\n  state,\n  dispatch\n}) => {\n  return joinBackward$1(state, dispatch);\n};\n\nconst joinForward = () => ({\n  state,\n  dispatch\n}) => {\n  return joinForward$1(state, dispatch);\n};\n\nfunction isMacOS() {\n  return typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;\n}\n\nfunction normalizeKeyName(name) {\n  const parts = name.split(/-(?!$)/);\n  let result = parts[parts.length - 1];\n\n  if (result === 'Space') {\n    result = ' ';\n  }\n\n  let alt;\n  let ctrl;\n  let shift;\n  let meta;\n\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i];\n\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true;\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true;\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true;\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true;\n    } else if (/^mod$/i.test(mod)) {\n      if (isiOS() || isMacOS()) {\n        meta = true;\n      } else {\n        ctrl = true;\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`);\n    }\n  }\n\n  if (alt) {\n    result = `Alt-${result}`;\n  }\n\n  if (ctrl) {\n    result = `Ctrl-${result}`;\n  }\n\n  if (meta) {\n    result = `Meta-${result}`;\n  }\n\n  if (shift) {\n    result = `Shift-${result}`;\n  }\n\n  return result;\n}\n\nconst keyboardShortcut = name => ({\n  editor,\n  view,\n  tr,\n  dispatch\n}) => {\n  const keys = normalizeKeyName(name).split(/-(?!$)/);\n  const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item));\n  const event = new KeyboardEvent('keydown', {\n    key: key === 'Space' ? ' ' : key,\n    altKey: keys.includes('Alt'),\n    ctrlKey: keys.includes('Ctrl'),\n    metaKey: keys.includes('Meta'),\n    shiftKey: keys.includes('Shift'),\n    bubbles: true,\n    cancelable: true\n  });\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp('handleKeyDown', f => f(view, event));\n  });\n  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(step => {\n    const newStep = step.map(tr.mapping);\n\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep);\n    }\n  });\n  return true;\n};\n\nfunction isNodeActive(state, typeOrName, attributes = {}) {\n  const {\n    from,\n    to,\n    empty\n  } = state.selection;\n  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n  const nodeRanges = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      return;\n    }\n\n    const relativeFrom = Math.max(from, pos);\n    const relativeTo = Math.min(to, pos + node.nodeSize);\n    nodeRanges.push({\n      node,\n      from: relativeFrom,\n      to: relativeTo\n    });\n  });\n  const selectionRange = to - from;\n  const matchedNodeRanges = nodeRanges.filter(nodeRange => {\n    if (!type) {\n      return true;\n    }\n\n    return type.name === nodeRange.node.type.name;\n  }).filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, {\n    strict: false\n  }));\n\n  if (empty) {\n    return !!matchedNodeRanges.length;\n  }\n\n  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);\n  return range >= selectionRange;\n}\n\nconst lift = (typeOrName, attributes = {}) => ({\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const isActive = isNodeActive(state, type, attributes);\n\n  if (!isActive) {\n    return false;\n  }\n\n  return lift$1(state, dispatch);\n};\n\nconst liftEmptyBlock = () => ({\n  state,\n  dispatch\n}) => {\n  return liftEmptyBlock$1(state, dispatch);\n};\n\nconst liftListItem = typeOrName => ({\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return liftListItem$1(type)(state, dispatch);\n};\n\nconst newlineInCode = () => ({\n  state,\n  dispatch\n}) => {\n  return newlineInCode$1(state, dispatch);\n};\n\nfunction getSchemaTypeNameByName(name, schema) {\n  if (schema.nodes[name]) {\n    return 'node';\n  }\n\n  if (schema.marks[name]) {\n    return 'mark';\n  }\n\n  return null;\n}\n/**\r\n * Remove a property or an array of properties from an object\r\n * @param obj Object\r\n * @param key Key to remove\r\n */\n\n\nfunction deleteProps(obj, propOrProps) {\n  const props = typeof propOrProps === 'string' ? [propOrProps] : propOrProps;\n  return Object.keys(obj).reduce((newObj, prop) => {\n    if (!props.includes(prop)) {\n      newObj[prop] = obj[prop];\n    }\n\n    return newObj;\n  }, {});\n}\n\nconst resetAttributes = (typeOrName, attributes) => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n\n  if (!schemaType) {\n    return false;\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n            }\n          });\n        }\n      });\n    });\n  }\n\n  return true;\n};\n\nconst scrollIntoView = () => ({\n  tr,\n  dispatch\n}) => {\n  if (dispatch) {\n    tr.scrollIntoView();\n  }\n\n  return true;\n};\n\nconst selectAll = () => ({\n  tr,\n  commands\n}) => {\n  return commands.setTextSelection({\n    from: 0,\n    to: tr.doc.content.size\n  });\n};\n\nconst selectNodeBackward = () => ({\n  state,\n  dispatch\n}) => {\n  return selectNodeBackward$1(state, dispatch);\n};\n\nconst selectNodeForward = () => ({\n  state,\n  dispatch\n}) => {\n  return selectNodeForward$1(state, dispatch);\n};\n\nconst selectParentNode = () => ({\n  state,\n  dispatch\n}) => {\n  return selectParentNode$1(state, dispatch);\n}; // @ts-ignore\n\n\nconst selectTextblockEnd = () => ({\n  state,\n  dispatch\n}) => {\n  return selectTextblockEnd$1(state, dispatch);\n}; // @ts-ignore\n\n\nconst selectTextblockStart = () => ({\n  state,\n  dispatch\n}) => {\n  return selectTextblockStart$1(state, dispatch);\n};\n\nfunction createDocument(content, schema, parseOptions = {}) {\n  return createNodeFromContent(content, schema, {\n    slice: false,\n    parseOptions\n  });\n}\n\nconst setContent = (content, emitUpdate = false, parseOptions = {}) => ({\n  tr,\n  editor,\n  dispatch\n}) => {\n  const {\n    doc\n  } = tr;\n  const document = createDocument(content, editor.schema, parseOptions);\n\n  if (dispatch) {\n    tr.replaceWith(0, doc.content.size, document).setMeta('preventUpdate', !emitUpdate);\n  }\n\n  return true;\n};\n\nfunction getMarkAttributes(state, typeOrName) {\n  const type = getMarkType(typeOrName, state.schema);\n  const {\n    from,\n    to,\n    empty\n  } = state.selection;\n  const marks = [];\n\n  if (empty) {\n    if (state.storedMarks) {\n      marks.push(...state.storedMarks);\n    }\n\n    marks.push(...state.selection.$head.marks());\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks.push(...node.marks);\n    });\n  }\n\n  const mark = marks.find(markItem => markItem.type.name === type.name);\n\n  if (!mark) {\n    return {};\n  }\n\n  return { ...mark.attrs\n  };\n}\n\nconst setMark = (typeOrName, attributes = {}) => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  const {\n    selection\n  } = tr;\n  const {\n    empty,\n    ranges\n  } = selection;\n  const type = getMarkType(typeOrName, state.schema);\n\n  if (dispatch) {\n    if (empty) {\n      const oldAttributes = getMarkAttributes(state, type);\n      tr.addStoredMark(type.create({ ...oldAttributes,\n        ...attributes\n      }));\n    } else {\n      ranges.forEach(range => {\n        const from = range.$from.pos;\n        const to = range.$to.pos;\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          const trimmedFrom = Math.max(pos, from);\n          const trimmedTo = Math.min(pos + node.nodeSize, to);\n          const someHasMark = node.marks.find(mark => mark.type === type); // if there is already a mark of this type\n          // we know that we have to merge its attributes\n          // otherwise we add a fresh new mark\n\n          if (someHasMark) {\n            node.marks.forEach(mark => {\n              if (type === mark.type) {\n                tr.addMark(trimmedFrom, trimmedTo, type.create({ ...mark.attrs,\n                  ...attributes\n                }));\n              }\n            });\n          } else {\n            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n          }\n        });\n      });\n    }\n  }\n\n  return true;\n};\n\nconst setMeta = (key, value) => ({\n  tr\n}) => {\n  tr.setMeta(key, value);\n  return true;\n};\n\nconst setNode = (typeOrName, attributes = {}) => ({\n  state,\n  dispatch,\n  chain\n}) => {\n  const type = getNodeType(typeOrName, state.schema); // TODO: use a fallback like insertContent?\n\n  if (!type.isTextblock) {\n    console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\n    return false;\n  }\n\n  return chain() // try to convert node to default node if needed\n  .command(({\n    commands\n  }) => {\n    const canSetBlock = setBlockType(type, attributes)(state);\n\n    if (canSetBlock) {\n      return true;\n    }\n\n    return commands.clearNodes();\n  }).command(({\n    state: updatedState\n  }) => {\n    return setBlockType(type, attributes)(updatedState, dispatch);\n  }).run();\n};\n\nconst setNodeSelection = position => ({\n  tr,\n  dispatch\n}) => {\n  if (dispatch) {\n    const {\n      doc\n    } = tr;\n    const minPos = Selection.atStart(doc).from;\n    const maxPos = Selection.atEnd(doc).to;\n    const resolvedPos = minMax(position, minPos, maxPos);\n    const selection = NodeSelection.create(doc, resolvedPos);\n    tr.setSelection(selection);\n  }\n\n  return true;\n};\n\nconst setTextSelection = position => ({\n  tr,\n  dispatch\n}) => {\n  if (dispatch) {\n    const {\n      doc\n    } = tr;\n    const {\n      from,\n      to\n    } = typeof position === 'number' ? {\n      from: position,\n      to: position\n    } : position;\n    const minPos = TextSelection.atStart(doc).from;\n    const maxPos = TextSelection.atEnd(doc).to;\n    const resolvedFrom = minMax(from, minPos, maxPos);\n    const resolvedEnd = minMax(to, minPos, maxPos);\n    const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd);\n    tr.setSelection(selection);\n  }\n\n  return true;\n};\n\nconst sinkListItem = typeOrName => ({\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return sinkListItem$1(type)(state, dispatch);\n};\n\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\n  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {\n    const extensionAttribute = extensionAttributes.find(item => {\n      return item.type === typeName && item.name === name;\n    });\n\n    if (!extensionAttribute) {\n      return false;\n    }\n\n    return extensionAttribute.attribute.keepOnSplit;\n  }));\n}\n\nfunction defaultBlockAt$1(match) {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const {\n      type\n    } = match.edge(i);\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type;\n    }\n  }\n\n  return null;\n}\n\nfunction ensureMarks(state, splittableMarks) {\n  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n\n  if (marks) {\n    const filteredMarks = marks.filter(mark => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));\n    state.tr.ensureMarks(filteredMarks);\n  }\n}\n\nconst splitBlock = ({\n  keepMarks = true\n} = {}) => ({\n  tr,\n  state,\n  dispatch,\n  editor\n}) => {\n  const {\n    selection,\n    doc\n  } = tr;\n  const {\n    $from,\n    $to\n  } = selection;\n  const extensionAttributes = editor.extensionManager.attributes;\n  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n\n  if (selection instanceof NodeSelection && selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n      return false;\n    }\n\n    if (dispatch) {\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks);\n      }\n\n      tr.split($from.pos).scrollIntoView();\n    }\n\n    return true;\n  }\n\n  if (!$from.parent.isBlock) {\n    return false;\n  }\n\n  if (dispatch) {\n    const atEnd = $to.parentOffset === $to.parent.content.size;\n\n    if (selection instanceof TextSelection) {\n      tr.deleteSelection();\n    }\n\n    const deflt = $from.depth === 0 ? undefined : defaultBlockAt$1($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n    let types = atEnd && deflt ? [{\n      type: deflt,\n      attrs: newAttributes\n    }] : undefined;\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\n\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{\n      type: deflt\n    }] : undefined)) {\n      can = true;\n      types = deflt ? [{\n        type: deflt,\n        attrs: newAttributes\n      }] : undefined;\n    }\n\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types);\n\n      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n        const first = tr.mapping.map($from.before());\n        const $first = tr.doc.resolve(first);\n\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n        }\n      }\n    }\n\n    if (keepMarks) {\n      ensureMarks(state, editor.extensionManager.splittableMarks);\n    }\n\n    tr.scrollIntoView();\n  }\n\n  return true;\n};\n\nconst splitListItem = typeOrName => ({\n  tr,\n  state,\n  dispatch,\n  editor\n}) => {\n  var _a;\n\n  const type = getNodeType(typeOrName, state.schema);\n  const {\n    $from,\n    $to\n  } = state.selection; // @ts-ignore\n  // eslint-disable-next-line\n\n  const node = state.selection.node;\n\n  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n    return false;\n  }\n\n  const grandParent = $from.node(-1);\n\n  if (grandParent.type !== type) {\n    return false;\n  }\n\n  const extensionAttributes = editor.extensionManager.attributes;\n\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    // In an empty block. If this is a nested list, the wrapping\n    // list item should be split. Otherwise, bail out and let next\n    // command handle lifting.\n    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n      return false;\n    }\n\n    if (dispatch) {\n      let wrap = Fragment.empty; // eslint-disable-next-line\n\n      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3; // Build a fragment containing empty versions of the structure\n      // from the outer list item to the parent node of the cursor\n\n      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n        wrap = Fragment.from($from.node(d).copy(wrap));\n      } // eslint-disable-next-line\n\n\n      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3; // Add a second list item with an empty default start node\n\n      const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n      const nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes)) || undefined;\n      wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined));\n      const start = $from.before($from.depth - (depthBefore - 1));\n      tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\n      let sel = -1;\n      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n        if (sel > -1) {\n          return false;\n        }\n\n        if (n.isTextblock && n.content.size === 0) {\n          sel = pos + 1;\n        }\n      });\n\n      if (sel > -1) {\n        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));\n      }\n\n      tr.scrollIntoView();\n    }\n\n    return true;\n  }\n\n  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n  const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);\n  const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n  tr.delete($from.pos, $to.pos);\n  const types = nextType ? [{\n    type,\n    attrs: newTypeAttributes\n  }, {\n    type: nextType,\n    attrs: newNextTypeAttributes\n  }] : [{\n    type,\n    attrs: newTypeAttributes\n  }];\n\n  if (!canSplit(tr.doc, $from.pos, 2)) {\n    return false;\n  }\n\n  if (dispatch) {\n    tr.split($from.pos, 2, types).scrollIntoView();\n  }\n\n  return true;\n};\n\nfunction findParentNodeClosestToPos($pos, predicate) {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i);\n\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node\n      };\n    }\n  }\n}\n\nfunction findParentNode(predicate) {\n  return selection => findParentNodeClosestToPos(selection.$from, predicate);\n}\n\nfunction isList(name, extensions) {\n  const {\n    nodeExtensions\n  } = splitExtensions(extensions);\n  const extension = nodeExtensions.find(item => item.name === name);\n\n  if (!extension) {\n    return false;\n  }\n\n  const context = {\n    name: extension.name,\n    options: extension.options,\n    storage: extension.storage\n  };\n  const group = callOrReturn(getExtensionField(extension, 'group', context));\n\n  if (typeof group !== 'string') {\n    return false;\n  }\n\n  return group.split(' ').includes('list');\n}\n\nconst joinListBackwards = (tr, listType) => {\n  const list = findParentNode(node => node.type === listType)(tr.selection);\n\n  if (!list) {\n    return true;\n  }\n\n  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\n\n  if (before === undefined) {\n    return true;\n  }\n\n  const nodeBefore = tr.doc.nodeAt(before);\n  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);\n\n  if (!canJoinBackwards) {\n    return true;\n  }\n\n  tr.join(list.pos);\n  return true;\n};\n\nconst joinListForwards = (tr, listType) => {\n  const list = findParentNode(node => node.type === listType)(tr.selection);\n\n  if (!list) {\n    return true;\n  }\n\n  const after = tr.doc.resolve(list.start).after(list.depth);\n\n  if (after === undefined) {\n    return true;\n  }\n\n  const nodeAfter = tr.doc.nodeAt(after);\n  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after);\n\n  if (!canJoinForwards) {\n    return true;\n  }\n\n  tr.join(after);\n  return true;\n};\n\nconst toggleList = (listTypeOrName, itemTypeOrName) => ({\n  editor,\n  tr,\n  state,\n  dispatch,\n  chain,\n  commands,\n  can\n}) => {\n  const {\n    extensions\n  } = editor.extensionManager;\n  const listType = getNodeType(listTypeOrName, state.schema);\n  const itemType = getNodeType(itemTypeOrName, state.schema);\n  const {\n    selection\n  } = state;\n  const {\n    $from,\n    $to\n  } = selection;\n  const range = $from.blockRange($to);\n\n  if (!range) {\n    return false;\n  }\n\n  const parentList = findParentNode(node => isList(node.type.name, extensions))(selection);\n\n  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n    // remove list\n    if (parentList.node.type === listType) {\n      return commands.liftListItem(itemType);\n    } // change list type\n\n\n    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {\n      return chain().command(() => {\n        tr.setNodeMarkup(parentList.pos, listType);\n        return true;\n      }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n    }\n  }\n\n  return chain() // try to convert node to default node if needed\n  .command(() => {\n    const canWrapInList = can().wrapInList(listType);\n\n    if (canWrapInList) {\n      return true;\n    }\n\n    return commands.clearNodes();\n  }).wrapInList(listType).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n};\n\nfunction isMarkActive(state, typeOrName, attributes = {}) {\n  const {\n    empty,\n    ranges\n  } = state.selection;\n  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks()).filter(mark => {\n      if (!type) {\n        return true;\n      }\n\n      return type.name === mark.type.name;\n    }).find(mark => objectIncludes(mark.attrs, attributes, {\n      strict: false\n    }));\n  }\n\n  let selectionRange = 0;\n  const markRanges = [];\n  ranges.forEach(({\n    $from,\n    $to\n  }) => {\n    const from = $from.pos;\n    const to = $to.pos;\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (!node.isText && !node.marks.length) {\n        return;\n      }\n\n      const relativeFrom = Math.max(from, pos);\n      const relativeTo = Math.min(to, pos + node.nodeSize);\n      const range = relativeTo - relativeFrom;\n      selectionRange += range;\n      markRanges.push(...node.marks.map(mark => ({\n        mark,\n        from: relativeFrom,\n        to: relativeTo\n      })));\n    });\n  });\n\n  if (selectionRange === 0) {\n    return false;\n  } // calculate range of matched mark\n\n\n  const matchedRange = markRanges.filter(markRange => {\n    if (!type) {\n      return true;\n    }\n\n    return type.name === markRange.mark.type.name;\n  }).filter(markRange => objectIncludes(markRange.mark.attrs, attributes, {\n    strict: false\n  })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0); // calculate range of marks that excludes the searched mark\n  // for example `code` doesn’t allow any other marks\n\n  const excludedRange = markRanges.filter(markRange => {\n    if (!type) {\n      return true;\n    }\n\n    return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0); // we only include the result of `excludedRange`\n  // if there is a match at all\n\n  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n  return range >= selectionRange;\n}\n\nconst toggleMark = (typeOrName, attributes = {}, options = {}) => ({\n  state,\n  commands\n}) => {\n  const {\n    extendEmptyMarkRange = false\n  } = options;\n  const type = getMarkType(typeOrName, state.schema);\n  const isActive = isMarkActive(state, type, attributes);\n\n  if (isActive) {\n    return commands.unsetMark(type, {\n      extendEmptyMarkRange\n    });\n  }\n\n  return commands.setMark(type, attributes);\n};\n\nconst toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({\n  state,\n  commands\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const toggleType = getNodeType(toggleTypeOrName, state.schema);\n  const isActive = isNodeActive(state, type, attributes);\n\n  if (isActive) {\n    return commands.setNode(toggleType);\n  }\n\n  return commands.setNode(type, attributes);\n};\n\nconst toggleWrap = (typeOrName, attributes = {}) => ({\n  state,\n  commands\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const isActive = isNodeActive(state, type, attributes);\n\n  if (isActive) {\n    return commands.lift(type);\n  }\n\n  return commands.wrapIn(type, attributes);\n};\n\nconst undoInputRule = () => ({\n  state,\n  dispatch\n}) => {\n  const plugins = state.plugins;\n\n  for (let i = 0; i < plugins.length; i += 1) {\n    const plugin = plugins[i];\n    let undoable; // @ts-ignore\n    // eslint-disable-next-line\n\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        const tr = state.tr;\n        const toUndo = undoable.transform;\n\n        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n        }\n\n        if (undoable.text) {\n          const marks = tr.doc.resolve(undoable.from).marks();\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n        } else {\n          tr.delete(undoable.from, undoable.to);\n        }\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst unsetAllMarks = () => ({\n  tr,\n  dispatch\n}) => {\n  const {\n    selection\n  } = tr;\n  const {\n    empty,\n    ranges\n  } = selection;\n\n  if (empty) {\n    return true;\n  }\n\n  if (dispatch) {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos);\n    });\n  }\n\n  return true;\n};\n\nconst unsetMark = (typeOrName, options = {}) => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  var _a;\n\n  const {\n    extendEmptyMarkRange = false\n  } = options;\n  const {\n    selection\n  } = tr;\n  const type = getMarkType(typeOrName, state.schema);\n  const {\n    $from,\n    empty,\n    ranges\n  } = selection;\n\n  if (!dispatch) {\n    return true;\n  }\n\n  if (empty && extendEmptyMarkRange) {\n    let {\n      from,\n      to\n    } = selection;\n    const attrs = (_a = $from.marks().find(mark => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;\n    const range = getMarkRange($from, type, attrs);\n\n    if (range) {\n      from = range.from;\n      to = range.to;\n    }\n\n    tr.removeMark(from, to, type);\n  } else {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos, type);\n    });\n  }\n\n  tr.removeStoredMark(type);\n  return true;\n};\n\nconst updateAttributes = (typeOrName, attributes = {}) => ({\n  tr,\n  state,\n  dispatch\n}) => {\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n\n  if (!schemaType) {\n    return false;\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      const from = range.$from.pos;\n      const to = range.$to.pos;\n      state.doc.nodesBetween(from, to, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, { ...node.attrs,\n            ...attributes\n          });\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              const trimmedFrom = Math.max(pos, from);\n              const trimmedTo = Math.min(pos + node.nodeSize, to);\n              tr.addMark(trimmedFrom, trimmedTo, markType.create({ ...mark.attrs,\n                ...attributes\n              }));\n            }\n          });\n        }\n      });\n    });\n  }\n\n  return true;\n};\n\nconst wrapIn = (typeOrName, attributes = {}) => ({\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return wrapIn$1(type, attributes)(state, dispatch);\n};\n\nconst wrapInList = (typeOrName, attributes = {}) => ({\n  state,\n  dispatch\n}) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return wrapInList$1(type, attributes)(state, dispatch);\n};\n\nvar commands = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  blur: blur,\n  clearContent: clearContent,\n  clearNodes: clearNodes,\n  command: command,\n  createParagraphNear: createParagraphNear,\n  deleteNode: deleteNode,\n  deleteRange: deleteRange,\n  deleteSelection: deleteSelection,\n  enter: enter,\n  exitCode: exitCode,\n  extendMarkRange: extendMarkRange,\n  first: first,\n  focus: focus,\n  forEach: forEach,\n  insertContent: insertContent,\n  insertContentAt: insertContentAt,\n  joinBackward: joinBackward,\n  joinForward: joinForward,\n  keyboardShortcut: keyboardShortcut,\n  lift: lift,\n  liftEmptyBlock: liftEmptyBlock,\n  liftListItem: liftListItem,\n  newlineInCode: newlineInCode,\n  resetAttributes: resetAttributes,\n  scrollIntoView: scrollIntoView,\n  selectAll: selectAll,\n  selectNodeBackward: selectNodeBackward,\n  selectNodeForward: selectNodeForward,\n  selectParentNode: selectParentNode,\n  selectTextblockEnd: selectTextblockEnd,\n  selectTextblockStart: selectTextblockStart,\n  setContent: setContent,\n  setMark: setMark,\n  setMeta: setMeta,\n  setNode: setNode,\n  setNodeSelection: setNodeSelection,\n  setTextSelection: setTextSelection,\n  sinkListItem: sinkListItem,\n  splitBlock: splitBlock,\n  splitListItem: splitListItem,\n  toggleList: toggleList,\n  toggleMark: toggleMark,\n  toggleNode: toggleNode,\n  toggleWrap: toggleWrap,\n  undoInputRule: undoInputRule,\n  unsetAllMarks: unsetAllMarks,\n  unsetMark: unsetMark,\n  updateAttributes: updateAttributes,\n  wrapIn: wrapIn,\n  wrapInList: wrapInList\n});\nconst Commands = Extension.create({\n  name: 'commands',\n\n  addCommands() {\n    return { ...commands\n    };\n  }\n\n});\nconst Editable = Extension.create({\n  name: 'editable',\n\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('editable'),\n      props: {\n        editable: () => this.editor.options.editable\n      }\n    })];\n  }\n\n});\nconst FocusEvents = Extension.create({\n  name: 'focusEvents',\n\n  addProseMirrorPlugins() {\n    const {\n      editor\n    } = this;\n    return [new Plugin({\n      key: new PluginKey('focusEvents'),\n      props: {\n        handleDOMEvents: {\n          focus: (view, event) => {\n            editor.isFocused = true;\n            const transaction = editor.state.tr.setMeta('focus', {\n              event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          },\n          blur: (view, event) => {\n            editor.isFocused = false;\n            const transaction = editor.state.tr.setMeta('blur', {\n              event\n            }).setMeta('addToHistory', false);\n            view.dispatch(transaction);\n            return false;\n          }\n        }\n      }\n    })];\n  }\n\n});\nconst Keymap = Extension.create({\n  name: 'keymap',\n\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(({\n      commands\n    }) => [() => commands.undoInputRule(), // maybe convert first text block node to default node\n    () => commands.command(({\n      tr\n    }) => {\n      const {\n        selection,\n        doc\n      } = tr;\n      const {\n        empty,\n        $anchor\n      } = selection;\n      const {\n        pos,\n        parent\n      } = $anchor;\n      const isAtStart = Selection.atStart(doc).from === pos;\n\n      if (!empty || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {\n        return false;\n      }\n\n      return commands.clearNodes();\n    }), () => commands.deleteSelection(), () => commands.joinBackward(), () => commands.selectNodeBackward()]);\n\n    const handleDelete = () => this.editor.commands.first(({\n      commands\n    }) => [() => commands.deleteSelection(), () => commands.joinForward(), () => commands.selectNodeForward()]);\n\n    const handleEnter = () => this.editor.commands.first(({\n      commands\n    }) => [() => commands.newlineInCode(), () => commands.createParagraphNear(), () => commands.liftEmptyBlock(), () => commands.splitBlock()]);\n\n    const baseKeymap = {\n      Enter: handleEnter,\n      'Mod-Enter': () => this.editor.commands.exitCode(),\n      Backspace: handleBackspace,\n      'Mod-Backspace': handleBackspace,\n      'Shift-Backspace': handleBackspace,\n      Delete: handleDelete,\n      'Mod-Delete': handleDelete,\n      'Mod-a': () => this.editor.commands.selectAll()\n    };\n    const pcKeymap = { ...baseKeymap\n    };\n    const macKeymap = { ...baseKeymap,\n      'Ctrl-h': handleBackspace,\n      'Alt-Backspace': handleBackspace,\n      'Ctrl-d': handleDelete,\n      'Ctrl-Alt-Backspace': handleDelete,\n      'Alt-Delete': handleDelete,\n      'Alt-d': handleDelete,\n      'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\n      'Ctrl-e': () => this.editor.commands.selectTextblockEnd()\n    };\n\n    if (isiOS() || isMacOS()) {\n      return macKeymap;\n    }\n\n    return pcKeymap;\n  },\n\n  addProseMirrorPlugins() {\n    return [// With this plugin we check if the whole document was selected and deleted.\n    // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n    // to a paragraph if necessary.\n    // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\n    // with many other commands.\n    new Plugin({\n      key: new PluginKey('clearDocument'),\n      appendTransaction: (transactions, oldState, newState) => {\n        const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n\n        if (!docChanges) {\n          return;\n        }\n\n        const {\n          empty,\n          from,\n          to\n        } = oldState.selection;\n        const allFrom = Selection.atStart(oldState.doc).from;\n        const allEnd = Selection.atEnd(oldState.doc).to;\n        const allWasSelected = from === allFrom && to === allEnd;\n        const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, ' ', ' ').length === 0;\n\n        if (empty || !allWasSelected || !isEmpty) {\n          return;\n        }\n\n        const tr = newState.tr;\n        const state = createChainableState({\n          state: newState,\n          transaction: tr\n        });\n        const {\n          commands\n        } = new CommandManager({\n          editor: this.editor,\n          state\n        });\n        commands.clearNodes();\n\n        if (!tr.steps.length) {\n          return;\n        }\n\n        return tr;\n      }\n    })];\n  }\n\n});\nconst Tabindex = Extension.create({\n  name: 'tabindex',\n\n  addProseMirrorPlugins() {\n    return [new Plugin({\n      key: new PluginKey('tabindex'),\n      props: {\n        attributes: this.editor.isEditable ? {\n          tabindex: '0'\n        } : {}\n      }\n    })];\n  }\n\n});\nvar extensions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ClipboardTextSerializer: ClipboardTextSerializer,\n  Commands: Commands,\n  Editable: Editable,\n  FocusEvents: FocusEvents,\n  Keymap: Keymap,\n  Tabindex: Tabindex\n});\n\nfunction getNodeAttributes(state, typeOrName) {\n  const type = getNodeType(typeOrName, state.schema);\n  const {\n    from,\n    to\n  } = state.selection;\n  const nodes = [];\n  state.doc.nodesBetween(from, to, node => {\n    nodes.push(node);\n  });\n  const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name);\n\n  if (!node) {\n    return {};\n  }\n\n  return { ...node.attrs\n  };\n}\n\nfunction getAttributes(state, typeOrName) {\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n\n  if (schemaType === 'node') {\n    return getNodeAttributes(state, typeOrName);\n  }\n\n  if (schemaType === 'mark') {\n    return getMarkAttributes(state, typeOrName);\n  }\n\n  return {};\n}\n\nfunction getHTMLFromFragment(fragment, schema) {\n  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);\n  const temporaryDocument = document.implementation.createHTMLDocument();\n  const container = temporaryDocument.createElement('div');\n  container.appendChild(documentFragment);\n  return container.innerHTML;\n}\n\nfunction getText(node, options) {\n  const range = {\n    from: 0,\n    to: node.content.size\n  };\n  return getTextBetween(node, range, options);\n}\n\nfunction isActive(state, name, attributes = {}) {\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n  }\n\n  const schemaType = getSchemaTypeNameByName(name, state.schema);\n\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes);\n  }\n\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes);\n  }\n\n  return false;\n}\n\nfunction isNodeEmpty(node) {\n  var _a;\n\n  const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();\n  const content = node.toJSON();\n  return JSON.stringify(defaultContent) === JSON.stringify(content);\n}\n\nconst style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`;\n\nfunction createStyleTag(style, nonce) {\n  const tipTapStyleTag = document.querySelector('style[data-tiptap-style]');\n\n  if (tipTapStyleTag !== null) {\n    return tipTapStyleTag;\n  }\n\n  const styleNode = document.createElement('style');\n\n  if (nonce) {\n    styleNode.setAttribute('nonce', nonce);\n  }\n\n  styleNode.setAttribute('data-tiptap-style', '');\n  styleNode.innerHTML = style;\n  document.getElementsByTagName('head')[0].appendChild(styleNode);\n  return styleNode;\n}\n\nclass Editor extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.isFocused = false;\n    this.extensionStorage = {};\n    this.options = {\n      element: document.createElement('div'),\n      content: '',\n      injectCSS: true,\n      injectNonce: undefined,\n      extensions: [],\n      autofocus: false,\n      editable: true,\n      editorProps: {},\n      parseOptions: {},\n      enableInputRules: true,\n      enablePasteRules: true,\n      enableCoreExtensions: true,\n      onBeforeCreate: () => null,\n      onCreate: () => null,\n      onUpdate: () => null,\n      onSelectionUpdate: () => null,\n      onTransaction: () => null,\n      onFocus: () => null,\n      onBlur: () => null,\n      onDestroy: () => null\n    };\n    this.isCapturingTransaction = false;\n    this.capturedTransaction = null;\n    this.setOptions(options);\n    this.createExtensionManager();\n    this.createCommandManager();\n    this.createSchema();\n    this.on('beforeCreate', this.options.onBeforeCreate);\n    this.emit('beforeCreate', {\n      editor: this\n    });\n    this.createView();\n    this.injectCSS();\n    this.on('create', this.options.onCreate);\n    this.on('update', this.options.onUpdate);\n    this.on('selectionUpdate', this.options.onSelectionUpdate);\n    this.on('transaction', this.options.onTransaction);\n    this.on('focus', this.options.onFocus);\n    this.on('blur', this.options.onBlur);\n    this.on('destroy', this.options.onDestroy);\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return;\n      }\n\n      this.commands.focus(this.options.autofocus);\n      this.emit('create', {\n        editor: this\n      });\n    }, 0);\n  }\n  /**\r\n   * Returns the editor storage.\r\n   */\n\n\n  get storage() {\n    return this.extensionStorage;\n  }\n  /**\r\n   * An object of all registered commands.\r\n   */\n\n\n  get commands() {\n    return this.commandManager.commands;\n  }\n  /**\r\n   * Create a command chain to call multiple commands at once.\r\n   */\n\n\n  chain() {\n    return this.commandManager.chain();\n  }\n  /**\r\n   * Check if a command or a command chain can be executed. Without executing it.\r\n   */\n\n\n  can() {\n    return this.commandManager.can();\n  }\n  /**\r\n   * Inject CSS styles.\r\n   */\n\n\n  injectCSS() {\n    if (this.options.injectCSS && document) {\n      this.css = createStyleTag(style, this.options.injectNonce);\n    }\n  }\n  /**\r\n   * Update editor options.\r\n   *\r\n   * @param options A list of options\r\n   */\n\n\n  setOptions(options = {}) {\n    this.options = { ...this.options,\n      ...options\n    };\n\n    if (!this.view || !this.state || this.isDestroyed) {\n      return;\n    }\n\n    if (this.options.editorProps) {\n      this.view.setProps(this.options.editorProps);\n    }\n\n    this.view.updateState(this.state);\n  }\n  /**\r\n   * Update editable state of the editor.\r\n   */\n\n\n  setEditable(editable) {\n    this.setOptions({\n      editable\n    });\n  }\n  /**\r\n   * Returns whether the editor is editable.\r\n   */\n\n\n  get isEditable() {\n    // since plugins are applied after creating the view\n    // `editable` is always `true` for one tick.\n    // that’s why we also have to check for `options.editable`\n    return this.options.editable && this.view && this.view.editable;\n  }\n  /**\r\n   * Returns the editor state.\r\n   */\n\n\n  get state() {\n    return this.view.state;\n  }\n  /**\r\n   * Register a ProseMirror plugin.\r\n   *\r\n   * @param plugin A ProseMirror plugin\r\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\r\n   */\n\n\n  registerPlugin(plugin, handlePlugins) {\n    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];\n    const state = this.state.reconfigure({\n      plugins\n    });\n    this.view.updateState(state);\n  }\n  /**\r\n   * Unregister a ProseMirror plugin.\r\n   *\r\n   * @param nameOrPluginKey The plugins name\r\n   */\n\n\n  unregisterPlugin(nameOrPluginKey) {\n    if (this.isDestroyed) {\n      return;\n    }\n\n    const name = typeof nameOrPluginKey === 'string' ? `${nameOrPluginKey}$` // @ts-ignore\n    : nameOrPluginKey.key;\n    const state = this.state.reconfigure({\n      // @ts-ignore\n      plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name))\n    });\n    this.view.updateState(state);\n  }\n  /**\r\n   * Creates an extension manager.\r\n   */\n\n\n  createExtensionManager() {\n    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n      return ['extension', 'node', 'mark'].includes(extension === null || extension === void 0 ? void 0 : extension.type);\n    });\n    this.extensionManager = new ExtensionManager(allExtensions, this);\n  }\n  /**\r\n   * Creates an command manager.\r\n   */\n\n\n  createCommandManager() {\n    this.commandManager = new CommandManager({\n      editor: this\n    });\n  }\n  /**\r\n   * Creates a ProseMirror schema.\r\n   */\n\n\n  createSchema() {\n    this.schema = this.extensionManager.schema;\n  }\n  /**\r\n   * Creates a ProseMirror view.\r\n   */\n\n\n  createView() {\n    const doc = createDocument(this.options.content, this.schema, this.options.parseOptions);\n    const selection = resolveFocusPosition(doc, this.options.autofocus);\n    this.view = new EditorView(this.options.element, { ...this.options.editorProps,\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: EditorState.create({\n        doc,\n        selection: selection || undefined\n      })\n    }); // `editor.view` is not yet available at this time.\n    // Therefore we will add all plugins and node views directly afterwards.\n\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins\n    });\n    this.view.updateState(newState);\n    this.createNodeViews(); // Let’s store the editor instance in the DOM element.\n    // So we’ll have access to it for tests.\n\n    const dom = this.view.dom;\n    dom.editor = this;\n  }\n  /**\r\n   * Creates all node views.\r\n   */\n\n\n  createNodeViews() {\n    this.view.setProps({\n      nodeViews: this.extensionManager.nodeViews\n    });\n  }\n\n  captureTransaction(fn) {\n    this.isCapturingTransaction = true;\n    fn();\n    this.isCapturingTransaction = false;\n    const tr = this.capturedTransaction;\n    this.capturedTransaction = null;\n    return tr;\n  }\n  /**\r\n   * The callback over which to send transactions (state updates) produced by the view.\r\n   *\r\n   * @param transaction An editor state transaction\r\n   */\n\n\n  dispatchTransaction(transaction) {\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction;\n        return;\n      }\n\n      transaction.steps.forEach(step => {\n        var _a;\n\n        return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);\n      });\n      return;\n    }\n\n    const state = this.state.apply(transaction);\n    const selectionHasChanged = !this.state.selection.eq(state.selection);\n    this.view.updateState(state);\n    this.emit('transaction', {\n      editor: this,\n      transaction\n    });\n\n    if (selectionHasChanged) {\n      this.emit('selectionUpdate', {\n        editor: this,\n        transaction\n      });\n    }\n\n    const focus = transaction.getMeta('focus');\n    const blur = transaction.getMeta('blur');\n\n    if (focus) {\n      this.emit('focus', {\n        editor: this,\n        event: focus.event,\n        transaction\n      });\n    }\n\n    if (blur) {\n      this.emit('blur', {\n        editor: this,\n        event: blur.event,\n        transaction\n      });\n    }\n\n    if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n      return;\n    }\n\n    this.emit('update', {\n      editor: this,\n      transaction\n    });\n  }\n  /**\r\n   * Get attributes of the currently selected node or mark.\r\n   */\n\n\n  getAttributes(nameOrType) {\n    return getAttributes(this.state, nameOrType);\n  }\n\n  isActive(nameOrAttributes, attributesOrUndefined) {\n    const name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null;\n    const attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes;\n    return isActive(this.state, name, attributes);\n  }\n  /**\r\n   * Get the document as JSON.\r\n   */\n\n\n  getJSON() {\n    return this.state.doc.toJSON();\n  }\n  /**\r\n   * Get the document as HTML.\r\n   */\n\n\n  getHTML() {\n    return getHTMLFromFragment(this.state.doc.content, this.schema);\n  }\n  /**\r\n   * Get the document as text.\r\n   */\n\n\n  getText(options) {\n    const {\n      blockSeparator = '\\n\\n',\n      textSerializers = {}\n    } = options || {};\n    return getText(this.state.doc, {\n      blockSeparator,\n      textSerializers: { ...textSerializers,\n        ...getTextSerializersFromSchema(this.schema)\n      }\n    });\n  }\n  /**\r\n   * Check if there is no content.\r\n   */\n\n\n  get isEmpty() {\n    return isNodeEmpty(this.state.doc);\n  }\n  /**\r\n   * Get the number of characters for the current document.\r\n   *\r\n   * @deprecated\r\n   */\n\n\n  getCharacterCount() {\n    console.warn('[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.');\n    return this.state.doc.content.size - 2;\n  }\n  /**\r\n   * Destroy the editor.\r\n   */\n\n\n  destroy() {\n    this.emit('destroy');\n\n    if (this.view) {\n      this.view.destroy();\n    }\n\n    this.removeAllListeners();\n  }\n  /**\r\n   * Check if the editor is already destroyed.\r\n   */\n\n\n  get isDestroyed() {\n    var _a; // @ts-ignore\n\n\n    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\n  }\n\n}\n/**\r\n * Returns a new `Transform` based on all steps of the passed transactions.\r\n */\n\n\nfunction combineTransactionSteps(oldDoc, transactions) {\n  const transform = new Transform(oldDoc);\n  transactions.forEach(transaction => {\n    transaction.steps.forEach(step => {\n      transform.step(step);\n    });\n  });\n  return transform;\n}\n\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const {\n      type\n    } = match.edge(i);\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type;\n    }\n  }\n\n  return null;\n}\n\nfunction findChildren(node, predicate) {\n  const nodesWithPos = [];\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n/**\r\n * Same as `findChildren` but searches only within a `range`.\r\n */\n\n\nfunction findChildrenInRange(node, range, predicate) {\n  const nodesWithPos = []; // if (range.from === range.to) {\n  //   const nodeAt = node.nodeAt(range.from)\n  //   if (nodeAt) {\n  //     nodesWithPos.push({\n  //       node: nodeAt,\n  //       pos: range.from,\n  //     })\n  //   }\n  // }\n\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\n\nfunction getSchema(extensions) {\n  const resolvedExtensions = ExtensionManager.resolve(extensions);\n  return getSchemaByResolvedExtensions(resolvedExtensions);\n}\n\nfunction generateHTML(doc, extensions) {\n  const schema = getSchema(extensions);\n  const contentNode = Node$1.fromJSON(schema, doc);\n  return getHTMLFromFragment(contentNode.content, schema);\n}\n\nfunction generateJSON(html, extensions) {\n  const schema = getSchema(extensions);\n  const dom = elementFromString(html);\n  return DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\n\nfunction generateText(doc, extensions, options) {\n  const {\n    blockSeparator = '\\n\\n',\n    textSerializers = {}\n  } = options || {};\n  const schema = getSchema(extensions);\n  const contentNode = Node$1.fromJSON(schema, doc);\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: { ...textSerializers,\n      ...getTextSerializersFromSchema(schema)\n    }\n  });\n}\n/**\r\n * Removes duplicated values within an array.\r\n * Supports numbers, strings and objects.\r\n */\n\n\nfunction removeDuplicates(array, by = JSON.stringify) {\n  const seen = {};\n  return array.filter(item => {\n    const key = by(item);\n    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;\n  });\n}\n/**\r\n * Removes duplicated ranges and ranges that are\r\n * fully captured by other ranges.\r\n */\n\n\nfunction simplifyChangedRanges(changes) {\n  const uniqueChanges = removeDuplicates(changes);\n  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index) => {\n    const rest = uniqueChanges.filter((_, i) => i !== index);\n    return !rest.some(otherChange => {\n      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;\n    });\n  });\n}\n/**\r\n * Returns a list of changed ranges\r\n * based on the first and last state of all steps.\r\n */\n\n\nfunction getChangedRanges(transform) {\n  const {\n    mapping,\n    steps\n  } = transform;\n  const changes = [];\n  mapping.maps.forEach((stepMap, index) => {\n    const ranges = []; // This accounts for step changes where no range was actually altered\n    // e.g. when setting a mark, node attribute, etc.\n    // @ts-ignore\n\n    if (!stepMap.ranges.length) {\n      const {\n        from,\n        to\n      } = steps[index];\n\n      if (from === undefined || to === undefined) {\n        return;\n      }\n\n      ranges.push({\n        from,\n        to\n      });\n    } else {\n      stepMap.forEach((from, to) => {\n        ranges.push({\n          from,\n          to\n        });\n      });\n    }\n\n    ranges.forEach(({\n      from,\n      to\n    }) => {\n      const newStart = mapping.slice(index).map(from, -1);\n      const newEnd = mapping.slice(index).map(to);\n      const oldStart = mapping.invert().map(newStart, -1);\n      const oldEnd = mapping.invert().map(newEnd);\n      changes.push({\n        oldRange: {\n          from: oldStart,\n          to: oldEnd\n        },\n        newRange: {\n          from: newStart,\n          to: newEnd\n        }\n      });\n    });\n  });\n  return simplifyChangedRanges(changes);\n}\n\nfunction getDebugJSON(node, startOffset = 0) {\n  const isTopNode = node.type === node.type.schema.topNodeType;\n  const increment = isTopNode ? 0 : 1;\n  const from = startOffset;\n  const to = from + node.nodeSize;\n  const marks = node.marks.map(mark => {\n    const output = {\n      type: mark.type.name\n    };\n\n    if (Object.keys(mark.attrs).length) {\n      output.attrs = { ...mark.attrs\n      };\n    }\n\n    return output;\n  });\n  const attrs = { ...node.attrs\n  };\n  const output = {\n    type: node.type.name,\n    from,\n    to\n  };\n\n  if (Object.keys(attrs).length) {\n    output.attrs = attrs;\n  }\n\n  if (marks.length) {\n    output.marks = marks;\n  }\n\n  if (node.content.childCount) {\n    output.content = [];\n    node.forEach((child, offset) => {\n      var _a;\n\n      (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\n    });\n  }\n\n  if (node.text) {\n    output.text = node.text;\n  }\n\n  return output;\n}\n\nfunction getMarksBetween(from, to, doc) {\n  const marks = []; // get all inclusive marks on empty selection\n\n  if (from === to) {\n    doc.resolve(from).marks().forEach(mark => {\n      const $pos = doc.resolve(from - 1);\n      const range = getMarkRange($pos, mark.type);\n\n      if (!range) {\n        return;\n      }\n\n      marks.push({\n        mark,\n        ...range\n      });\n    });\n  } else {\n    doc.nodesBetween(from, to, (node, pos) => {\n      marks.push(...node.marks.map(mark => ({\n        from: pos,\n        to: pos + node.nodeSize,\n        mark\n      })));\n    });\n  }\n\n  return marks;\n}\n\nfunction isNodeSelection(value) {\n  return isObject(value) && value instanceof NodeSelection;\n}\n\nfunction posToDOMRect(view, from, to) {\n  const minPos = 0;\n  const maxPos = view.state.doc.content.size;\n  const resolvedFrom = minMax(from, minPos, maxPos);\n  const resolvedEnd = minMax(to, minPos, maxPos);\n  const start = view.coordsAtPos(resolvedFrom);\n  const end = view.coordsAtPos(resolvedEnd, -1);\n  const top = Math.min(start.top, end.top);\n  const bottom = Math.max(start.bottom, end.bottom);\n  const left = Math.min(start.left, end.left);\n  const right = Math.max(start.right, end.right);\n  const width = right - left;\n  const height = bottom - top;\n  const x = left;\n  const y = top;\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y\n  };\n  return { ...data,\n    toJSON: () => data\n  };\n}\n/**\r\n * Build an input rule that adds a mark when the\r\n * matched text is typed into it.\r\n */\n\n\nfunction markInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({\n      state,\n      range,\n      match\n    }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match);\n\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n\n      const {\n        tr\n      } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      let markEnd = range.to;\n\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(item => {\n          // @ts-ignore\n          const excluded = item.mark.type.excluded;\n          return excluded.find(type => type === config.type && type !== item.mark.type);\n        }).filter(item => item.to > textStart);\n\n        if (excludedMarks.length) {\n          return null;\n        }\n\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n\n        markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n}\n/**\r\n * Build an input rule that adds a node when the\r\n * matched text is typed into it.\r\n */\n\n\nfunction nodeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({\n      state,\n      range,\n      match\n    }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n      const {\n        tr\n      } = state;\n      const start = range.from;\n      let end = range.to;\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        let matchStart = start + offset;\n\n        if (matchStart > end) {\n          matchStart = end;\n        } else {\n          end = matchStart + match[1].length;\n        } // insert last typed character\n\n\n        const lastChar = match[0][match[0].length - 1];\n        tr.insertText(lastChar, start + match[0].length - 1); // insert node from input rule\n\n        tr.replaceWith(matchStart, end, config.type.create(attributes));\n      } else if (match[0]) {\n        tr.replaceWith(start, end, config.type.create(attributes));\n      }\n    }\n  });\n}\n/**\r\n * Build an input rule that changes the type of a textblock when the\r\n * matched text is typed into it. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n */\n\n\nfunction textblockTypeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({\n      state,\n      range,\n      match\n    }) => {\n      const $start = state.doc.resolve(range.from);\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n\n      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n        return null;\n      }\n\n      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);\n    }\n  });\n}\n/**\r\n * Build an input rule that replaces text when the\r\n * matched text is typed into it.\r\n */\n\n\nfunction textInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({\n      state,\n      range,\n      match\n    }) => {\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\n/**\r\n * Build an input rule for automatically wrapping a textblock when a\r\n * given string is typed. When using a regular expresion you’ll\r\n * probably want the regexp to start with `^`, so that the pattern can\r\n * only occur at the start of a textblock.\r\n *\r\n * `type` is the type of node to wrap in.\r\n *\r\n * By default, if there’s a node with the same type above the newly\r\n * wrapped node, the rule will try to join those\r\n * two nodes. You can pass a join predicate, which takes a regular\r\n * expression match and the node before the wrapped node, and can\r\n * return a boolean to indicate whether a join should happen.\r\n */\n\n\nfunction wrappingInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({\n      state,\n      range,\n      match\n    }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n      const tr = state.tr.delete(range.from, range.to);\n      const $start = tr.doc.resolve(range.from);\n      const blockRange = $start.blockRange();\n      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);\n\n      if (!wrapping) {\n        return null;\n      }\n\n      tr.wrap(blockRange, wrapping);\n      const before = tr.doc.resolve(range.from - 1).nodeBefore;\n\n      if (before && before.type === config.type && canJoin(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {\n        tr.join(range.from - 1);\n      }\n    }\n  });\n}\n\nclass Mark {\n  constructor(config = {}) {\n    this.type = 'mark';\n    this.name = 'mark';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = { ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    } // TODO: remove `addOptions` fallback\n\n\n    this.options = this.config.defaultOptions;\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n\n  static create(config = {}) {\n    return new Mark(config);\n  }\n\n  configure(options = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n\n  extend(extendedConfig = {}) {\n    const extension = new Mark(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n\n}\n\nclass Node {\n  constructor(config = {}) {\n    this.type = 'node';\n    this.name = 'node';\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = { ...this.config,\n      ...config\n    };\n    this.name = this.config.name;\n\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    } // TODO: remove `addOptions` fallback\n\n\n    this.options = this.config.defaultOptions;\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n        name: this.name\n      }));\n    }\n\n    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n\n  static create(config = {}) {\n    return new Node(config);\n  }\n\n  configure(options = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n\n  extend(extendedConfig = {}) {\n    const extension = new Node(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n\n    extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n\n}\n\nclass NodeView {\n  constructor(component, props, options) {\n    this.isDragging = false;\n    this.component = component;\n    this.editor = props.editor;\n    this.options = {\n      stopEvent: null,\n      ignoreMutation: null,\n      ...options\n    };\n    this.extension = props.extension;\n    this.node = props.node;\n    this.decorations = props.decorations;\n    this.getPos = props.getPos;\n    this.mount();\n  }\n\n  mount() {\n    // eslint-disable-next-line\n    return;\n  }\n\n  get dom() {\n    return this.editor.view.dom;\n  }\n\n  get contentDOM() {\n    return null;\n  }\n\n  onDragStart(event) {\n    var _a, _b, _c, _d, _e, _f, _g;\n\n    const {\n      view\n    } = this.editor;\n    const target = event.target; // get the drag handle element\n    // `closest` is not available for text nodes so we may have to use its parent\n\n    const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[data-drag-handle]') : target.closest('[data-drag-handle]');\n\n    if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {\n      return;\n    }\n\n    let x = 0;\n    let y = 0; // calculate offset for drag element if we use a different drag handle element\n\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect();\n      const handleBox = dragHandle.getBoundingClientRect(); // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n\n      const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;\n      const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;\n      x = handleBox.x - domBox.x + offsetX;\n      y = handleBox.y - domBox.y + offsetY;\n    }\n\n    (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(this.dom, x, y); // we need to tell ProseMirror that we want to move the whole node\n    // so we create a NodeSelection\n\n    const selection = NodeSelection.create(view.state.doc, this.getPos());\n    const transaction = view.state.tr.setSelection(selection);\n    view.dispatch(transaction);\n  }\n\n  stopEvent(event) {\n    var _a;\n\n    if (!this.dom) {\n      return false;\n    }\n\n    if (typeof this.options.stopEvent === 'function') {\n      return this.options.stopEvent({\n        event\n      });\n    }\n\n    const target = event.target;\n    const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target)); // any event from child nodes should be handled by ProseMirror\n\n    if (!isInElement) {\n      return false;\n    }\n\n    const isDropEvent = event.type === 'drop';\n    const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable; // any input event within node views should be ignored by ProseMirror\n\n    if (isInput && !isDropEvent) {\n      return true;\n    }\n\n    const {\n      isEditable\n    } = this.editor;\n    const {\n      isDragging\n    } = this;\n    const isDraggable = !!this.node.type.spec.draggable;\n    const isSelectable = NodeSelection.isSelectable(this.node);\n    const isCopyEvent = event.type === 'copy';\n    const isPasteEvent = event.type === 'paste';\n    const isCutEvent = event.type === 'cut';\n    const isClickEvent = event.type === 'mousedown';\n    const isDragEvent = event.type.startsWith('drag'); // ProseMirror tries to drag selectable nodes\n    // even if `draggable` is set to `false`\n    // this fix prevents that\n\n    if (!isDraggable && isSelectable && isDragEvent) {\n      event.preventDefault();\n    }\n\n    if (isDraggable && isDragEvent && !isDragging) {\n      event.preventDefault();\n      return false;\n    } // we have to store that dragging started\n\n\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest('[data-drag-handle]');\n      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n\n      if (isValidDragHandle) {\n        this.isDragging = true;\n        document.addEventListener('dragend', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n        document.addEventListener('mouseup', () => {\n          this.isDragging = false;\n        }, {\n          once: true\n        });\n      }\n    } // these events are handled by prosemirror\n\n\n    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {\n      return false;\n    }\n\n    return true;\n  }\n\n  ignoreMutation(mutation) {\n    if (!this.dom || !this.contentDOM) {\n      return true;\n    }\n\n    if (typeof this.options.ignoreMutation === 'function') {\n      return this.options.ignoreMutation({\n        mutation\n      });\n    } // a leaf/atom node is like a black box for ProseMirror\n    // and should be fully handled by the node view\n\n\n    if (this.node.isLeaf || this.node.isAtom) {\n      return true;\n    } // ProseMirror should handle any selections\n\n\n    if (mutation.type === 'selection') {\n      return false;\n    } // try to prevent a bug on iOS that will break node views on enter\n    // this is because ProseMirror can’t preventDispatch on enter\n    // this will lead to a re-render of the node view on enter\n    // see: https://github.com/ueberdosis/tiptap/issues/1214\n\n\n    if (this.dom.contains(mutation.target) && mutation.type === 'childList' && isiOS() && this.editor.isFocused) {\n      const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)]; // we’ll check if every changed node is contentEditable\n      // to make sure it’s probably mutated by ProseMirror\n\n      if (changedNodes.every(node => node.isContentEditable)) {\n        return false;\n      }\n    } // we will allow mutation contentDOM with attributes\n    // so we can for example adding classes within our node view\n\n\n    if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n      return true;\n    } // ProseMirror should handle any changes within contentDOM\n\n\n    if (this.contentDOM.contains(mutation.target)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  updateAttributes(attributes) {\n    this.editor.commands.command(({\n      tr\n    }) => {\n      const pos = this.getPos();\n      tr.setNodeMarkup(pos, undefined, { ...this.node.attrs,\n        ...attributes\n      });\n      return true;\n    });\n  }\n\n  deleteNode() {\n    const from = this.getPos();\n    const to = from + this.node.nodeSize;\n    this.editor.commands.deleteRange({\n      from,\n      to\n    });\n  }\n\n}\n/**\r\n * Build an paste rule that adds a mark when the\r\n * matched text is pasted into it.\r\n */\n\n\nfunction markPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({\n      state,\n      range,\n      match\n    }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match);\n\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n\n      const {\n        tr\n      } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      let markEnd = range.to;\n\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(item => {\n          // @ts-ignore\n          const excluded = item.mark.type.excluded;\n          return excluded.find(type => type === config.type && type !== item.mark.type);\n        }).filter(item => item.to > textStart);\n\n        if (excludedMarks.length) {\n          return null;\n        }\n\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n\n        markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n} // source: https://stackoverflow.com/a/6969486\n\n\nfunction escapeForRegEx(string) {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n/**\r\n * Build an paste rule that adds a node when the\r\n * matched text is pasted into it.\r\n */\n\n\nfunction nodePasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n\n    handler({\n      match,\n      chain,\n      range\n    }) {\n      const attributes = callOrReturn(config.getAttributes, undefined, match);\n\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n\n      if (match.input) {\n        chain().deleteRange(range).insertContent({\n          type: config.type.name,\n          attrs: attributes\n        });\n      }\n    }\n\n  });\n}\n/**\r\n * Build an paste rule that replaces text when the\r\n * matched text is pasted into it.\r\n */\n\n\nfunction textPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({\n      state,\n      range,\n      match\n    }) => {\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\n\nclass Tracker {\n  constructor(transaction) {\n    this.transaction = transaction;\n    this.currentStep = this.transaction.steps.length;\n  }\n\n  map(position) {\n    let deleted = false;\n    const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step) => {\n      const mapResult = step.getMap().mapResult(newPosition);\n\n      if (mapResult.deleted) {\n        deleted = true;\n      }\n\n      return mapResult.pos;\n    }, position);\n    return {\n      position: mappedPosition,\n      deleted\n    };\n  }\n\n}\n\nexport { CommandManager, Editor, Extension, InputRule, Mark, Node, NodeView, PasteRule, Tracker, callOrReturn, combineTransactionSteps, defaultBlockAt, escapeForRegEx, extensions, findChildren, findChildrenInRange, findParentNode, findParentNodeClosestToPos, generateHTML, generateJSON, generateText, getAttributes, getChangedRanges, getDebugJSON, getExtensionField, getHTMLFromFragment, getMarkAttributes, getMarkRange, getMarkType, getMarksBetween, getNodeAttributes, getNodeType, getSchema, getText, getTextBetween, getTextContentFromNodes, getTextSerializersFromSchema, inputRulesPlugin, isActive, isList, isMarkActive, isNodeActive, isNodeEmpty, isNodeSelection, isTextSelection, markInputRule, markPasteRule, mergeAttributes, nodeInputRule, nodePasteRule, pasteRulesPlugin, posToDOMRect, textInputRule, textPasteRule, textblockTypeInputRule, wrappingInputRule };","map":{"version":3,"mappings":"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","names":["createChainableState","config","state","transaction","selection","doc","storedMarks","apply","bind","applyTransaction","filterTransaction","plugins","schema","reconfigure","toJSON","tr","CommandManager","constructor","props","editor","rawCommands","extensionManager","commands","customState","hasCustomState","view","buildProps","Object","fromEntries","entries","map","name","command","method","args","callback","getMeta","dispatch","chain","createChain","can","createCan","startTr","shouldDispatch","callbacks","hasStartTransaction","run","every","chainedCommand","push","undefined","formattedCommands","setStoredMarks","EventEmitter","on","event","fn","emit","forEach","off","filter","removeAllListeners","getExtensionField","extension","field","context","parent","value","splitExtensions","extensions","baseExtensions","type","nodeExtensions","markExtensions","getAttributesFromExtensions","extensionAttributes","nodeAndMarkExtensions","defaultAttribute","default","rendered","renderHTML","parseHTML","keepOnSplit","isRequired","options","storage","addGlobalAttributes","globalAttributes","globalAttribute","types","attributes","attribute","addAttributes","mergedAttr","nameOrType","nodes","Error","objects","item","reduce","items","mergedAttributes","key","exists","join","nodeOrMark","attrs","mergeAttributes","isFunction","callOrReturn","keys","length","fromString","match","Number","parseRule","style","getAttrs","node","oldAttributes","newAttributes","getAttribute","cleanUpSchemaItem","data","isEmptyObject","getSchemaByResolvedExtensions","allAttributes","topNode","find","_a","extraNodeFields","fields","e","extendNodeSchema","content","marks","group","inline","atom","selectable","draggable","code","defining","isolating","extensionAttribute","parseDOM","injectExtensionAttributesToParseRule","toDOM","HTMLAttributes","getRenderedAttributes","renderText","toText","extraMarkFields","extendMarkSchema","inclusive","excludes","spanning","mark","Schema","enabled","Array","isArray","some","enabledExtension","$from","maxMatch","textBefore","nodesBetween","Math","max","parentOffset","pos","index","spec","_b","nodeBefore","_c","text","isRegExp","prototype","toString","call","InputRule","handler","inputRuleMatcherHandler","exec","inputRuleMatch","result","input","replaceWith","includes","console","warn","from","to","rules","plugin","composing","resolve","nodeAfter","matched","getTextContentFromNodes","rule","range","steps","setMeta","transform","inputRulesPlugin","Plugin","init","prev","stored","selectionSet","docChanged","handleTextInput","handleDOMEvents","compositionend","setTimeout","$cursor","handleKeyDown","isInputRules","isNumber","PasteRule","pasteRuleMatcherHandler","matchAll","matches","pasteRuleMatch","handlers","isTextblock","resolvedFrom","resolvedTo","min","size","textToMatch","textBetween","start","end","mapping","success","pasteRulesPlugin","dragSourceElement","isPastedFromProseMirror","isDroppedFromProseMirror","handleDragstart","dom","parentElement","contains","target","window","addEventListener","destroy","removeEventListener","drop","paste","html","clipboardData","getData","appendTransaction","transactions","oldState","isPaste","isDrop","findDiffStart","findDiffEnd","b","chainableState","findDuplicates","filtered","el","indexOf","Set","ExtensionManager","splittableMarks","extensionStorage","getSchemaTypeByName","onBeforeCreate","onCreate","onUpdate","onSelectionUpdate","onTransaction","onFocus","onBlur","onDestroy","resolvedExtensions","sort","flatten","duplicatedNames","addExtensions","flat","defaultPriority","a","priorityA","priorityB","addCommands","reverse","inputRules","pasteRules","allPlugins","addKeyboardShortcuts","bindings","shortcut","keyMapPlugin","keymap","addInputRules","isExtensionRulesEnabled","enableInputRules","addPasteRules","enablePasteRules","addProseMirrorPlugins","proseMirrorPlugins","nodeViews","getNodeType","addNodeView","nodeview","getPos","decorations","getType","slice","isPlainObject","getPrototypeOf","source","output","assign","mergeDeep","Extension","child","defaultOptions","addOptions","create","configure","extend","extendedConfig","getTextBetween","startNode","blockSeparator","textSerializers","separated","textSerializer","isBlock","isText","getTextSerializersFromSchema","ClipboardTextSerializer","PluginKey","clipboardTextSerializer","ranges","$to","blur","requestAnimationFrame","isDestroyed","getSelection","removeAllRanges","clearContent","emitUpdate","setContent","clearNodes","$mappedFrom","$mappedTo","nodeSize","nodeRange","blockRange","targetLiftDepth","liftTarget","defaultType","contentMatchAt","setNodeMarkup","lift","createParagraphNear","originalCreateParagraphNear","deleteNode","typeOrName","$pos","$anchor","depth","before","after","delete","scrollIntoView","deleteRange","deleteSelection","originalDeleteSelection","enter","keyboardShortcut","exitCode","originalExitCode","object1","object2","strict","test","findMarkInSet","objectIncludes","isMarkInSet","getMarkRange","childAfter","offset","childBefore","startIndex","startPos","endIndex","endPos","isInSet","childCount","extendMarkRange","getMarkType","newSelection","TextSelection","setSelection","first","i","isClass","substring","isObject","isTextSelection","resolveFocusPosition","position","selectionAtStart","Selection","atStart","selectionAtEnd","atEnd","minPos","maxPos","minMax","isiOS","navigator","platform","userAgent","document","focus","delayedFocus","hasFocus","isSameSelection","eq","insertContent","insertContentAt","elementFromString","wrappedValue","DOMParser","parseFromString","body","createNodeFromContent","parseOptions","Fragment","fromArray","nodeFromJSON","error","parser","fromSchema","parseSlice","parse","selectionToInsertionEnd","startLen","bias","last","step","ReplaceStep","ReplaceAroundStep","maps","_from","_to","_newFrom","newTo","near","isFragment","nodeOrFragment","startsWith","updateSelection","preserveWhitespace","isOnlyTextContent","isOnlyBlockContent","check","isEmptyTextBlock","insertText","joinBackward","originalJoinBackward","joinForward","originalJoinForward","isMacOS","normalizeKeyName","parts","split","alt","ctrl","shift","meta","mod","KeyboardEvent","altKey","ctrlKey","metaKey","shiftKey","bubbles","cancelable","capturedTransaction","captureTransaction","someProp","f","newStep","maybeStep","isNodeActive","empty","nodeRanges","relativeFrom","relativeTo","selectionRange","matchedNodeRanges","sum","isActive","originalLift","liftEmptyBlock","originalLiftEmptyBlock","liftListItem","originalLiftListItem","newlineInCode","originalNewlineInCode","obj","propOrProps","newObj","prop","resetAttributes","nodeType","markType","schemaType","getSchemaTypeNameByName","deleteProps","addMark","selectAll","setTextSelection","selectNodeBackward","originalSelectNodeBackward","selectNodeForward","originalSelectNodeForward","selectParentNode","originalSelectParentNode","selectTextblockEnd","originalSelectTextblockEnd","selectTextblockStart","originalSelectTextblockStart","createDocument","$head","markItem","setMark","getMarkAttributes","addStoredMark","trimmedFrom","trimmedTo","someHasMark","setNode","canSetBlock","setBlockType","updatedState","setNodeSelection","resolvedPos","NodeSelection","resolvedEnd","sinkListItem","originalSinkListItem","getSplittedAttributes","typeName","defaultBlockAt","edgeCount","edge","hasRequiredAttrs","ensureMarks","filteredMarks","splitBlock","keepMarks","canSplit","deflt","indexAfter","$first","canReplaceWith","splitListItem","sameParent","grandParent","wrap","depthBefore","d","copy","depthAfter","newNextTypeAttributes","nextType","contentMatch","createAndFill","append","replace","Slice","sel","n","newTypeAttributes","predicate","findParentNode","findParentNodeClosestToPos","joinListBackwards","listType","list","nodeAt","canJoinBackwards","canJoin","joinListForwards","canJoinForwards","toggleList","listTypeOrName","itemTypeOrName","itemType","parentList","isList","validContent","canWrapInList","wrapInList","isMarkActive","markRanges","matchedRange","markRange","excludedRange","toggleMark","extendEmptyMarkRange","unsetMark","toggleNode","toggleTypeOrName","toggleType","toggleWrap","wrapIn","undoInputRule","undoable","getState","toUndo","j","invert","docs","unsetAllMarks","removeMark","removeStoredMark","updateAttributes","originalWrapIn","originalWrapInList","Commands","Editable","editable","FocusEvents","isFocused","Keymap","handleBackspace","isAtStart","textContent","handleDelete","handleEnter","baseKeymap","Enter","Backspace","Delete","pcKeymap","macKeymap","newState","docChanges","allFrom","allEnd","allWasSelected","isEmpty","Tabindex","isEditable","tabindex","nodeItem","getNodeAttributes","fragment","documentFragment","DOMSerializer","serializeFragment","temporaryDocument","implementation","createHTMLDocument","container","createElement","appendChild","innerHTML","isNodeEmpty","defaultContent","JSON","stringify","nonce","tipTapStyleTag","querySelector","styleNode","setAttribute","getElementsByTagName","Editor","element","injectCSS","injectNonce","autofocus","editorProps","enableCoreExtensions","isCapturingTransaction","setOptions","createExtensionManager","createCommandManager","createSchema","createView","commandManager","css","createStyleTag","setProps","updateState","setEditable","registerPlugin","handlePlugins","unregisterPlugin","nameOrPluginKey","coreExtensions","values","allExtensions","EditorView","dispatchTransaction","EditorState","createNodeViews","selectionHasChanged","getAttributes","nameOrAttributes","attributesOrUndefined","getJSON","getHTML","getHTMLFromFragment","getText","getCharacterCount","docView","oldDoc","Transform","nodesWithPos","descendants","findChildrenInRange","getSchema","contentNode","Node","fromJSON","generateText","removeDuplicates","array","by","seen","hasOwnProperty","simplifyChangedRanges","changes","uniqueChanges","change","rest","_","otherChange","oldRange","newRange","getChangedRanges","stepMap","newStart","newEnd","oldStart","oldEnd","getDebugJSON","startOffset","isTopNode","topNodeType","increment","getMarksBetween","isNodeSelection","posToDOMRect","coordsAtPos","top","bottom","left","right","width","height","x","y","markInputRule","captureGroup","fullMatch","markEnd","startSpaces","search","textStart","textEnd","excludedMarks","excluded","nodeInputRule","lastIndexOf","matchStart","lastChar","textblockTypeInputRule","$start","textInputRule","insert","cutOff","wrappingInputRule","wrapping","findWrapping","joinPredicate","Mark","NodeView","component","isDragging","stopEvent","ignoreMutation","mount","contentDOM","onDragStart","dragHandle","closest","domBox","getBoundingClientRect","handleBox","offsetX","nativeEvent","_d","offsetY","_e","_f","dataTransfer","_g","setDragImage","isInElement","isDropEvent","isInput","tagName","isContentEditable","isDraggable","isSelectable","isCopyEvent","isPasteEvent","isCutEvent","isClickEvent","isDragEvent","preventDefault","isValidDragHandle","once","mutation","isLeaf","isAtom","changedNodes","addedNodes","removedNodes","markPasteRule","escapeForRegEx","string","nodePasteRule","textPasteRule","Tracker","currentStep","deleted","mappedPosition","newPosition","mapResult","getMap"],"sources":["../src/helpers/createChainableState.ts","../src/CommandManager.ts","../src/EventEmitter.ts","../src/helpers/getExtensionField.ts","../src/helpers/splitExtensions.ts","../src/helpers/getAttributesFromExtensions.ts","../src/helpers/getNodeType.ts","../src/utilities/mergeAttributes.ts","../src/helpers/getRenderedAttributes.ts","../src/utilities/isFunction.ts","../src/utilities/callOrReturn.ts","../src/utilities/isEmptyObject.ts","../src/utilities/fromString.ts","../src/helpers/injectExtensionAttributesToParseRule.ts","../src/helpers/getSchemaByResolvedExtensions.ts","../src/helpers/getSchemaTypeByName.ts","../src/helpers/isExtensionRulesEnabled.ts","../src/helpers/getTextContentFromNodes.ts","../src/utilities/isRegExp.ts","../src/InputRule.ts","../src/utilities/isNumber.ts","../src/PasteRule.ts","../src/utilities/findDuplicates.ts","../src/ExtensionManager.ts","../src/utilities/isPlainObject.ts","../src/utilities/mergeDeep.ts","../src/Extension.ts","../src/helpers/getTextBetween.ts","../src/helpers/getTextSerializersFromSchema.ts","../src/extensions/clipboardTextSerializer.ts","../src/commands/blur.ts","../src/commands/clearContent.ts","../src/commands/clearNodes.ts","../src/commands/command.ts","../src/commands/createParagraphNear.ts","../src/commands/deleteNode.ts","../src/commands/deleteRange.ts","../src/commands/deleteSelection.ts","../src/commands/enter.ts","../src/commands/exitCode.ts","../src/utilities/objectIncludes.ts","../src/helpers/getMarkRange.ts","../src/helpers/getMarkType.ts","../src/commands/extendMarkRange.ts","../src/commands/first.ts","../src/utilities/isClass.ts","../src/utilities/isObject.ts","../src/helpers/isTextSelection.ts","../src/utilities/minMax.ts","../src/helpers/resolveFocusPosition.ts","../src/utilities/isiOS.ts","../src/commands/focus.ts","../src/commands/forEach.ts","../src/commands/insertContent.ts","../src/utilities/elementFromString.ts","../src/helpers/createNodeFromContent.ts","../src/helpers/selectionToInsertionEnd.ts","../src/commands/insertContentAt.ts","../src/commands/joinBackward.ts","../src/commands/joinForward.ts","../src/utilities/isMacOS.ts","../src/commands/keyboardShortcut.ts","../src/helpers/isNodeActive.ts","../src/commands/lift.ts","../src/commands/liftEmptyBlock.ts","../src/commands/liftListItem.ts","../src/commands/newlineInCode.ts","../src/helpers/getSchemaTypeNameByName.ts","../src/utilities/deleteProps.ts","../src/commands/resetAttributes.ts","../src/commands/scrollIntoView.ts","../src/commands/selectAll.ts","../src/commands/selectNodeBackward.ts","../src/commands/selectNodeForward.ts","../src/commands/selectParentNode.ts","../src/commands/selectTextblockEnd.ts","../src/commands/selectTextblockStart.ts","../src/helpers/createDocument.ts","../src/commands/setContent.ts","../src/helpers/getMarkAttributes.ts","../src/commands/setMark.ts","../src/commands/setMeta.ts","../src/commands/setNode.ts","../src/commands/setNodeSelection.ts","../src/commands/setTextSelection.ts","../src/commands/sinkListItem.ts","../src/helpers/getSplittedAttributes.ts","../src/commands/splitBlock.ts","../src/commands/splitListItem.ts","../src/helpers/findParentNodeClosestToPos.ts","../src/helpers/findParentNode.ts","../src/helpers/isList.ts","../src/commands/toggleList.ts","../src/helpers/isMarkActive.ts","../src/commands/toggleMark.ts","../src/commands/toggleNode.ts","../src/commands/toggleWrap.ts","../src/commands/undoInputRule.ts","../src/commands/unsetAllMarks.ts","../src/commands/unsetMark.ts","../src/commands/updateAttributes.ts","../src/commands/wrapIn.ts","../src/commands/wrapInList.ts","../src/extensions/commands.ts","../src/extensions/editable.ts","../src/extensions/focusEvents.ts","../src/extensions/keymap.ts","../src/extensions/tabindex.ts","../src/helpers/getNodeAttributes.ts","../src/helpers/getAttributes.ts","../src/helpers/getHTMLFromFragment.ts","../src/helpers/getText.ts","../src/helpers/isActive.ts","../src/helpers/isNodeEmpty.ts","../src/style.ts","../src/utilities/createStyleTag.ts","../src/Editor.ts","../src/helpers/combineTransactionSteps.ts","../src/helpers/defaultBlockAt.ts","../src/helpers/findChildren.ts","../src/helpers/findChildrenInRange.ts","../src/helpers/getSchema.ts","../src/helpers/generateHTML.ts","../src/helpers/generateJSON.ts","../src/helpers/generateText.ts","../src/utilities/removeDuplicates.ts","../src/helpers/getChangedRanges.ts","../src/helpers/getDebugJSON.ts","../src/helpers/getMarksBetween.ts","../src/helpers/isNodeSelection.ts","../src/helpers/posToDOMRect.ts","../src/inputRules/markInputRule.ts","../src/inputRules/nodeInputRule.ts","../src/inputRules/textblockTypeInputRule.ts","../src/inputRules/textInputRule.ts","../src/inputRules/wrappingInputRule.ts","../src/Mark.ts","../src/Node.ts","../src/NodeView.ts","../src/pasteRules/markPasteRule.ts","../src/utilities/escapeForRegEx.ts","../src/pasteRules/nodePasteRule.ts","../src/pasteRules/textPasteRule.ts","../src/Tracker.ts"],"sourcesContent":["import { EditorState, Transaction } from 'prosemirror-state'\n\nexport function createChainableState(config: {\n  transaction: Transaction,\n  state: EditorState,\n}): EditorState {\n  const { state, transaction } = config\n  let { selection } = transaction\n  let { doc } = transaction\n  let { storedMarks } = transaction\n\n  return {\n    ...state,\n    apply: state.apply.bind(state),\n    applyTransaction: state.applyTransaction.bind(state),\n    filterTransaction: state.filterTransaction,\n    plugins: state.plugins,\n    schema: state.schema,\n    reconfigure: state.reconfigure.bind(state),\n    toJSON: state.toJSON.bind(state),\n    get storedMarks() {\n      return storedMarks\n    },\n    get selection() {\n      return selection\n    },\n    get doc() {\n      return doc\n    },\n    get tr() {\n      selection = transaction.selection\n      doc = transaction.doc\n      storedMarks = transaction.storedMarks\n\n      return transaction\n    },\n  }\n}\n","import { EditorState, Transaction } from 'prosemirror-state'\n\nimport { Editor } from './Editor'\nimport { createChainableState } from './helpers/createChainableState'\nimport {\n  AnyCommands,\n  CanCommands,\n  ChainedCommands,\n  CommandProps,\n  SingleCommands,\n} from './types'\n\nexport class CommandManager {\n\n  editor: Editor\n\n  rawCommands: AnyCommands\n\n  customState?: EditorState\n\n  constructor(props: {\n    editor: Editor,\n    state?: EditorState,\n  }) {\n    this.editor = props.editor\n    this.rawCommands = this.editor.extensionManager.commands\n    this.customState = props.state\n  }\n\n  get hasCustomState(): boolean {\n    return !!this.customState\n  }\n\n  get state(): EditorState {\n    return this.customState || this.editor.state\n  }\n\n  get commands(): SingleCommands {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n    const { tr } = state\n    const props = this.buildProps(tr)\n\n    return Object.fromEntries(Object\n      .entries(rawCommands)\n      .map(([name, command]) => {\n        const method = (...args: any[]) => {\n          const callback = command(...args)(props)\n\n          if (!tr.getMeta('preventDispatch') && !this.hasCustomState) {\n            view.dispatch(tr)\n          }\n\n          return callback\n        }\n\n        return [name, method]\n      })) as unknown as SingleCommands\n  }\n\n  get chain(): () => ChainedCommands {\n    return () => this.createChain()\n  }\n\n  get can(): () => CanCommands {\n    return () => this.createCan()\n  }\n\n  public createChain(startTr?: Transaction, shouldDispatch = true): ChainedCommands {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n    const callbacks: boolean[] = []\n    const hasStartTransaction = !!startTr\n    const tr = startTr || state.tr\n\n    const run = () => {\n      if (\n        !hasStartTransaction\n        && shouldDispatch\n        && !tr.getMeta('preventDispatch')\n        && !this.hasCustomState\n      ) {\n        view.dispatch(tr)\n      }\n\n      return callbacks.every(callback => callback === true)\n    }\n\n    const chain = {\n      ...Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\n        const chainedCommand = (...args: never[]) => {\n          const props = this.buildProps(tr, shouldDispatch)\n          const callback = command(...args)(props)\n\n          callbacks.push(callback)\n\n          return chain\n        }\n\n        return [name, chainedCommand]\n      })),\n      run,\n    } as unknown as ChainedCommands\n\n    return chain\n  }\n\n  public createCan(startTr?: Transaction): CanCommands {\n    const { rawCommands, state } = this\n    const dispatch = undefined\n    const tr = startTr || state.tr\n    const props = this.buildProps(tr, dispatch)\n    const formattedCommands = Object.fromEntries(Object\n      .entries(rawCommands)\n      .map(([name, command]) => {\n        return [name, (...args: never[]) => command(...args)({ ...props, dispatch })]\n      })) as unknown as SingleCommands\n\n    return {\n      ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch),\n    } as CanCommands\n  }\n\n  public buildProps(tr: Transaction, shouldDispatch = true): CommandProps {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n\n    if (state.storedMarks) {\n      tr.setStoredMarks(state.storedMarks)\n    }\n\n    const props: CommandProps = {\n      tr,\n      editor,\n      view,\n      state: createChainableState({\n        state,\n        transaction: tr,\n      }),\n      dispatch: shouldDispatch\n        ? () => undefined\n        : undefined,\n      chain: () => this.createChain(tr),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(Object\n          .entries(rawCommands)\n          .map(([name, command]) => {\n            return [name, (...args: never[]) => command(...args)(props)]\n          })) as unknown as SingleCommands\n      },\n    }\n\n    return props\n  }\n\n}\n","type StringKeyOf<T> = Extract<keyof T, string>\ntype CallbackType<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>,\n> = T[EventName] extends any[] ? T[EventName] : [T[EventName]]\ntype CallbackFunction<\n  T extends Record<string, any>,\n  EventName extends StringKeyOf<T>,\n> = (...props: CallbackType<T, EventName>) => any\n\nexport class EventEmitter<T extends Record<string, any>> {\n\n  private callbacks: { [key: string]: Function[] } = {}\n\n  public on<EventName extends StringKeyOf<T>>(event: EventName, fn: CallbackFunction<T, EventName>): this {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = []\n    }\n\n    this.callbacks[event].push(fn)\n\n    return this\n  }\n\n  protected emit<EventName extends StringKeyOf<T>>(event: EventName, ...args: CallbackType<T, EventName>): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      callbacks.forEach(callback => callback.apply(this, args))\n    }\n\n    return this\n  }\n\n  public off<EventName extends StringKeyOf<T>>(event: EventName, fn?: CallbackFunction<T, EventName>): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter(callback => callback !== fn)\n      } else {\n        delete this.callbacks[event]\n      }\n    }\n\n    return this\n  }\n\n  protected removeAllListeners(): void {\n    this.callbacks = {}\n  }\n}\n","import { AnyExtension, MaybeThisParameterType, RemoveThis } from '../types'\n\nexport function getExtensionField<T = any>(\n  extension: AnyExtension,\n  field: string,\n  context?: Omit<MaybeThisParameterType<T>, 'parent'>,\n): RemoveThis<T> {\n\n  if (extension.config[field] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context)\n  }\n\n  if (typeof extension.config[field] === 'function') {\n    const value = extension.config[field].bind({\n      ...context,\n      parent: extension.parent\n        ? getExtensionField(extension.parent, field, context)\n        : null,\n    })\n\n    return value\n  }\n\n  return extension.config[field]\n}\n","import { Extension } from '../Extension'\nimport { Mark } from '../Mark'\nimport { Node } from '../Node'\nimport { Extensions } from '../types'\n\nexport function splitExtensions(extensions: Extensions) {\n  const baseExtensions = extensions.filter(extension => extension.type === 'extension') as Extension[]\n  const nodeExtensions = extensions.filter(extension => extension.type === 'node') as Node[]\n  const markExtensions = extensions.filter(extension => extension.type === 'mark') as Mark[]\n\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions,\n  }\n}\n","import { MarkConfig, NodeConfig } from '..'\nimport {\n  AnyConfig,\n  Attribute,\n  Attributes,\n  ExtensionAttribute,\n  Extensions,\n  GlobalAttributes,\n} from '../types'\nimport { getExtensionField } from './getExtensionField'\nimport { splitExtensions } from './splitExtensions'\n\n/**\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\n * @param extensions List of extensions\n */\nexport function getAttributesFromExtensions(extensions: Extensions): ExtensionAttribute[] {\n  const extensionAttributes: ExtensionAttribute[] = []\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions]\n  const defaultAttribute: Required<Attribute> = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n    isRequired: false,\n  }\n\n  extensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    const addGlobalAttributes = getExtensionField<AnyConfig['addGlobalAttributes']>(\n      extension,\n      'addGlobalAttributes',\n      context,\n    )\n\n    if (!addGlobalAttributes) {\n      return\n    }\n\n    // TODO: remove `as GlobalAttributes`\n    const globalAttributes = addGlobalAttributes() as GlobalAttributes\n\n    globalAttributes.forEach(globalAttribute => {\n      globalAttribute.types.forEach(type => {\n        Object\n          .entries(globalAttribute.attributes)\n          .forEach(([name, attribute]) => {\n            extensionAttributes.push({\n              type,\n              name,\n              attribute: {\n                ...defaultAttribute,\n                ...attribute,\n              },\n            })\n          })\n      })\n    })\n  })\n\n  nodeAndMarkExtensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    const addAttributes = getExtensionField<NodeConfig['addAttributes'] | MarkConfig['addAttributes']>(\n      extension,\n      'addAttributes',\n      context,\n    )\n\n    if (!addAttributes) {\n      return\n    }\n\n    // TODO: remove `as Attributes`\n    const attributes = addAttributes() as Attributes\n\n    Object\n      .entries(attributes)\n      .forEach(([name, attribute]) => {\n        const mergedAttr = {\n          ...defaultAttribute,\n          ...attribute,\n        }\n\n        if (attribute.isRequired && attribute.default === undefined) {\n          delete mergedAttr.default\n        }\n\n        extensionAttributes.push({\n          type: extension.name,\n          name,\n          attribute: mergedAttr,\n        })\n      })\n  })\n\n  return extensionAttributes\n}\n","import { NodeType, Schema } from 'prosemirror-model'\n\nexport function getNodeType(nameOrType: string | NodeType, schema: Schema): NodeType {\n  if (typeof nameOrType === 'string') {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`)\n    }\n\n    return schema.nodes[nameOrType]\n  }\n\n  return nameOrType\n}\n","export function mergeAttributes(...objects: Record<string, any>[]): Record<string, any> {\n  return objects\n    .filter(item => !!item)\n    .reduce((items, item) => {\n      const mergedAttributes = { ...items }\n\n      Object.entries(item).forEach(([key, value]) => {\n        const exists = mergedAttributes[key]\n\n        if (!exists) {\n          mergedAttributes[key] = value\n\n          return\n        }\n\n        if (key === 'class') {\n          mergedAttributes[key] = [mergedAttributes[key], value].join(' ')\n        } else if (key === 'style') {\n          mergedAttributes[key] = [mergedAttributes[key], value].join('; ')\n        } else {\n          mergedAttributes[key] = value\n        }\n      })\n\n      return mergedAttributes\n    }, {})\n}\n","import { Mark, Node } from 'prosemirror-model'\n\nimport { ExtensionAttribute } from '../types'\nimport { mergeAttributes } from '../utilities/mergeAttributes'\n\nexport function getRenderedAttributes(nodeOrMark: Node | Mark, extensionAttributes: ExtensionAttribute[]): Record<string, any> {\n  return extensionAttributes\n    .filter(item => item.attribute.rendered)\n    .map(item => {\n      if (!item.attribute.renderHTML) {\n        return {\n          [item.name]: nodeOrMark.attrs[item.name],\n        }\n      }\n\n      return item.attribute.renderHTML(nodeOrMark.attrs) || {}\n    })\n    .reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {})\n}\n","export function isFunction(value: any): value is Function {\n  return typeof value === 'function'\n}\n","import { MaybeReturnType } from '../types'\nimport { isFunction } from './isFunction'\n\n/**\n * Optionally calls `value` as a function.\n * Otherwise it is returned directly.\n * @param value Function or any value.\n * @param context Optional context to bind to function.\n * @param props Optional props to pass to function.\n */\nexport function callOrReturn<T>(value: T, context: any = undefined, ...props: any[]): MaybeReturnType<T> {\n  if (isFunction(value)) {\n    if (context) {\n      return value.bind(context)(...props)\n    }\n\n    return value(...props)\n  }\n\n  return value as MaybeReturnType<T>\n}\n","export function isEmptyObject(value = {}): boolean {\n  return Object.keys(value).length === 0 && value.constructor === Object\n}\n","export function fromString(value: any): any {\n  if (typeof value !== 'string') {\n    return value\n  }\n\n  if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n    return Number(value)\n  }\n\n  if (value === 'true') {\n    return true\n  }\n\n  if (value === 'false') {\n    return false\n  }\n\n  return value\n}\n","import { ParseRule } from 'prosemirror-model'\n\nimport { ExtensionAttribute } from '../types'\nimport { fromString } from '../utilities/fromString'\n\n/**\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\n * Cancels when `getAttrs` returned `false`.\n * @param parseRule ProseMirror ParseRule\n * @param extensionAttributes List of attributes to inject\n */\nexport function injectExtensionAttributesToParseRule(parseRule: ParseRule, extensionAttributes: ExtensionAttribute[]): ParseRule {\n  if (parseRule.style) {\n    return parseRule\n  }\n\n  return {\n    ...parseRule,\n    getAttrs: node => {\n      const oldAttributes = parseRule.getAttrs\n        ? parseRule.getAttrs(node)\n        : parseRule.attrs\n\n      if (oldAttributes === false) {\n        return false\n      }\n\n      const newAttributes = extensionAttributes.reduce((items, item) => {\n        const value = item.attribute.parseHTML\n          ? item.attribute.parseHTML(node as HTMLElement)\n          : fromString((node as HTMLElement).getAttribute(item.name))\n\n        if (value === null || value === undefined) {\n          return items\n        }\n\n        return {\n          ...items,\n          [item.name]: value,\n        }\n      }, {})\n\n      return { ...oldAttributes, ...newAttributes }\n    },\n  }\n}\n","import { MarkSpec, NodeSpec, Schema } from 'prosemirror-model'\n\nimport { MarkConfig, NodeConfig } from '..'\nimport { AnyConfig, Extensions } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\nimport { isEmptyObject } from '../utilities/isEmptyObject'\nimport { getAttributesFromExtensions } from './getAttributesFromExtensions'\nimport { getExtensionField } from './getExtensionField'\nimport { getRenderedAttributes } from './getRenderedAttributes'\nimport { injectExtensionAttributesToParseRule } from './injectExtensionAttributesToParseRule'\nimport { splitExtensions } from './splitExtensions'\n\nfunction cleanUpSchemaItem<T>(data: T) {\n  return Object.fromEntries(Object.entries(data).filter(([key, value]) => {\n    if (key === 'attrs' && isEmptyObject(value)) {\n      return false\n    }\n\n    return value !== null && value !== undefined\n  })) as T\n}\n\nexport function getSchemaByResolvedExtensions(extensions: Extensions): Schema {\n  const allAttributes = getAttributesFromExtensions(extensions)\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const topNode = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))?.name\n\n  const nodes = Object.fromEntries(nodeExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name)\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    const extraNodeFields = extensions.reduce((fields, e) => {\n      const extendNodeSchema = getExtensionField<AnyConfig['extendNodeSchema']>(\n        e,\n        'extendNodeSchema',\n        context,\n      )\n\n      return {\n        ...fields,\n        ...(extendNodeSchema ? extendNodeSchema(extension) : {}),\n      }\n    }, {})\n\n    const schema: NodeSpec = cleanUpSchemaItem({\n      ...extraNodeFields,\n      content: callOrReturn(getExtensionField<NodeConfig['content']>(extension, 'content', context)),\n      marks: callOrReturn(getExtensionField<NodeConfig['marks']>(extension, 'marks', context)),\n      group: callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context)),\n      inline: callOrReturn(getExtensionField<NodeConfig['inline']>(extension, 'inline', context)),\n      atom: callOrReturn(getExtensionField<NodeConfig['atom']>(extension, 'atom', context)),\n      selectable: callOrReturn(getExtensionField<NodeConfig['selectable']>(extension, 'selectable', context)),\n      draggable: callOrReturn(getExtensionField<NodeConfig['draggable']>(extension, 'draggable', context)),\n      code: callOrReturn(getExtensionField<NodeConfig['code']>(extension, 'code', context)),\n      defining: callOrReturn(getExtensionField<NodeConfig['defining']>(extension, 'defining', context)),\n      isolating: callOrReturn(getExtensionField<NodeConfig['isolating']>(extension, 'isolating', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        return [extensionAttribute.name, { default: extensionAttribute?.attribute?.default }]\n      })),\n    })\n\n    const parseHTML = callOrReturn(getExtensionField<NodeConfig['parseHTML']>(extension, 'parseHTML', context))\n\n    if (parseHTML) {\n      schema.parseDOM = parseHTML\n        .map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes))\n    }\n\n    const renderHTML = getExtensionField<NodeConfig['renderHTML']>(extension, 'renderHTML', context)\n\n    if (renderHTML) {\n      schema.toDOM = node => renderHTML({\n        node,\n        HTMLAttributes: getRenderedAttributes(node, extensionAttributes),\n      })\n    }\n\n    const renderText = getExtensionField<NodeConfig['renderText']>(extension, 'renderText', context)\n\n    if (renderText) {\n      schema.toText = renderText\n    }\n\n    return [extension.name, schema]\n  }))\n\n  const marks = Object.fromEntries(markExtensions.map(extension => {\n    const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name)\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    const extraMarkFields = extensions.reduce((fields, e) => {\n      const extendMarkSchema = getExtensionField<AnyConfig['extendMarkSchema']>(\n        e,\n        'extendMarkSchema',\n        context,\n      )\n\n      return {\n        ...fields,\n        ...(extendMarkSchema ? extendMarkSchema(extension) : {}),\n      }\n    }, {})\n\n    const schema: MarkSpec = cleanUpSchemaItem({\n      ...extraMarkFields,\n      inclusive: callOrReturn(getExtensionField<MarkConfig['inclusive']>(extension, 'inclusive', context)),\n      excludes: callOrReturn(getExtensionField<MarkConfig['excludes']>(extension, 'excludes', context)),\n      group: callOrReturn(getExtensionField<MarkConfig['group']>(extension, 'group', context)),\n      spanning: callOrReturn(getExtensionField<MarkConfig['spanning']>(extension, 'spanning', context)),\n      code: callOrReturn(getExtensionField<MarkConfig['code']>(extension, 'code', context)),\n      attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n        return [extensionAttribute.name, { default: extensionAttribute?.attribute?.default }]\n      })),\n    })\n\n    const parseHTML = callOrReturn(getExtensionField<MarkConfig['parseHTML']>(extension, 'parseHTML', context))\n\n    if (parseHTML) {\n      schema.parseDOM = parseHTML\n        .map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes))\n    }\n\n    const renderHTML = getExtensionField<MarkConfig['renderHTML']>(extension, 'renderHTML', context)\n\n    if (renderHTML) {\n      schema.toDOM = mark => renderHTML({\n        mark,\n        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes),\n      })\n    }\n\n    return [extension.name, schema]\n  }))\n\n  return new Schema({\n    topNode,\n    nodes,\n    marks,\n  })\n}\n","import { MarkType, NodeType, Schema } from 'prosemirror-model'\n\nexport function getSchemaTypeByName(name: string, schema: Schema): NodeType | MarkType | null {\n  return schema.nodes[name] || schema.marks[name] || null\n}\n","import { AnyExtension, EnableRules } from '../types'\n\nexport function isExtensionRulesEnabled(extension: AnyExtension, enabled: EnableRules): boolean {\n  if (Array.isArray(enabled)) {\n    return enabled.some(enabledExtension => {\n      const name = typeof enabledExtension === 'string'\n        ? enabledExtension\n        : enabledExtension.name\n\n      return name === extension.name\n    })\n  }\n\n  return enabled\n}\n","import { ResolvedPos } from 'prosemirror-model'\n\nexport const getTextContentFromNodes = ($from: ResolvedPos, maxMatch = 500) => {\n  let textBefore = ''\n\n  $from.parent.nodesBetween(\n    Math.max(0, $from.parentOffset - maxMatch),\n    $from.parentOffset,\n    (node, pos, parent, index) => {\n      textBefore += node.type.spec.toText?.({\n        node, pos, parent, index,\n      }) || $from.nodeBefore?.text || '%leaf%'\n    },\n  )\n\n  return textBefore\n}\n","export function isRegExp(value: any): value is RegExp {\n  return Object.prototype.toString.call(value) === '[object RegExp]'\n}\n","import { EditorState, Plugin, TextSelection } from 'prosemirror-state'\n\nimport { CommandManager } from './CommandManager'\nimport { Editor } from './Editor'\nimport { createChainableState } from './helpers/createChainableState'\nimport { getTextContentFromNodes } from './helpers/getTextContentFromNodes'\nimport {\n  CanCommands,\n  ChainedCommands,\n  ExtendedRegExpMatchArray,\n  Range,\n  SingleCommands,\n} from './types'\nimport { isRegExp } from './utilities/isRegExp'\n\nexport type InputRuleMatch = {\n  index: number,\n  text: string,\n  replaceWith?: string,\n  match?: RegExpMatchArray,\n  data?: Record<string, any>,\n}\n\nexport type InputRuleFinder =\n  | RegExp\n  | ((text: string) => InputRuleMatch | null)\n\nexport class InputRule {\n  find: InputRuleFinder\n\n  handler: (props: {\n    state: EditorState,\n    range: Range,\n    match: ExtendedRegExpMatchArray,\n    commands: SingleCommands,\n    chain: () => ChainedCommands,\n    can: () => CanCommands,\n  }) => void | null\n\n  constructor(config: {\n    find: InputRuleFinder,\n    handler: (props: {\n      state: EditorState,\n      range: Range,\n      match: ExtendedRegExpMatchArray,\n      commands: SingleCommands,\n      chain: () => ChainedCommands,\n      can: () => CanCommands,\n    }) => void | null,\n  }) {\n    this.find = config.find\n    this.handler = config.handler\n  }\n}\n\nconst inputRuleMatcherHandler = (text: string, find: InputRuleFinder): ExtendedRegExpMatchArray | null => {\n  if (isRegExp(find)) {\n    return find.exec(text)\n  }\n\n  const inputRuleMatch = find(text)\n\n  if (!inputRuleMatch) {\n    return null\n  }\n\n  const result: ExtendedRegExpMatchArray = []\n\n  result.push(inputRuleMatch.text)\n  result.index = inputRuleMatch.index\n  result.input = text\n  result.data = inputRuleMatch.data\n\n  if (inputRuleMatch.replaceWith) {\n    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n      console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".')\n    }\n\n    result.push(inputRuleMatch.replaceWith)\n  }\n\n  return result\n}\n\nfunction run(config: {\n  editor: Editor,\n  from: number,\n  to: number,\n  text: string,\n  rules: InputRule[],\n  plugin: Plugin,\n}): boolean {\n  const {\n    editor,\n    from,\n    to,\n    text,\n    rules,\n    plugin,\n  } = config\n  const { view } = editor\n\n  if (view.composing) {\n    return false\n  }\n\n  const $from = view.state.doc.resolve(from)\n\n  if (\n    // check for code node\n    $from.parent.type.spec.code\n    // check for code mark\n    || !!($from.nodeBefore || $from.nodeAfter)?.marks.find(mark => mark.type.spec.code)\n  ) {\n    return false\n  }\n\n  let matched = false\n\n  const textBefore = getTextContentFromNodes($from) + text\n\n  rules.forEach(rule => {\n    if (matched) {\n      return\n    }\n\n    const match = inputRuleMatcherHandler(textBefore, rule.find)\n\n    if (!match) {\n      return\n    }\n\n    const tr = view.state.tr\n    const state = createChainableState({\n      state: view.state,\n      transaction: tr,\n    })\n    const range = {\n      from: from - (match[0].length - text.length),\n      to,\n    }\n\n    const { commands, chain, can } = new CommandManager({\n      editor,\n      state,\n    })\n\n    const handler = rule.handler({\n      state,\n      range,\n      match,\n      commands,\n      chain,\n      can,\n    })\n\n    // stop if there are no changes\n    if (handler === null || !tr.steps.length) {\n      return\n    }\n\n    // store transform as meta data\n    // so we can undo input rules within the `undoInputRules` command\n    tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text,\n    })\n\n    view.dispatch(tr)\n    matched = true\n  })\n\n  return matched\n}\n\n/**\n * Create an input rules plugin. When enabled, it will cause text\n * input that matches any of the given rules to trigger the rule’s\n * action.\n */\nexport function inputRulesPlugin(props: { editor: Editor, rules: InputRule[] }): Plugin {\n  const { editor, rules } = props\n  const plugin = new Plugin({\n    state: {\n      init() {\n        return null\n      },\n      apply(tr, prev) {\n        const stored = tr.getMeta(plugin)\n\n        if (stored) {\n          return stored\n        }\n\n        return tr.selectionSet || tr.docChanged\n          ? null\n          : prev\n      },\n    },\n\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run({\n          editor,\n          from,\n          to,\n          text,\n          rules,\n          plugin,\n        })\n      },\n\n      handleDOMEvents: {\n        compositionend: view => {\n          setTimeout(() => {\n            const { $cursor } = view.state.selection as TextSelection\n\n            if ($cursor) {\n              run({\n                editor,\n                from: $cursor.pos,\n                to: $cursor.pos,\n                text: '',\n                rules,\n                plugin,\n              })\n            }\n          })\n\n          return false\n        },\n      },\n\n      // add support for input rules to trigger on enter\n      // this is useful for example for code blocks\n      handleKeyDown(view, event) {\n        if (event.key !== 'Enter') {\n          return false\n        }\n\n        const { $cursor } = view.state.selection as TextSelection\n\n        if ($cursor) {\n          return run({\n            editor,\n            from: $cursor.pos,\n            to: $cursor.pos,\n            text: '\\n',\n            rules,\n            plugin,\n          })\n        }\n\n        return false\n      },\n    },\n\n    // @ts-ignore\n    isInputRules: true,\n  }) as Plugin\n\n  return plugin\n}\n","export function isNumber(value: any): value is number {\n  return typeof value === 'number'\n}\n","import { EditorState, Plugin } from 'prosemirror-state'\n\nimport { CommandManager } from './CommandManager'\nimport { Editor } from './Editor'\nimport { createChainableState } from './helpers/createChainableState'\nimport {\n  CanCommands,\n  ChainedCommands,\n  ExtendedRegExpMatchArray,\n  Range,\n  SingleCommands,\n} from './types'\nimport { isNumber } from './utilities/isNumber'\nimport { isRegExp } from './utilities/isRegExp'\n\nexport type PasteRuleMatch = {\n  index: number,\n  text: string,\n  replaceWith?: string,\n  match?: RegExpMatchArray,\n  data?: Record<string, any>,\n}\n\nexport type PasteRuleFinder =\n  | RegExp\n  | ((text: string) => PasteRuleMatch[] | null | undefined)\n\nexport class PasteRule {\n  find: PasteRuleFinder\n\n  handler: (props: {\n    state: EditorState,\n    range: Range,\n    match: ExtendedRegExpMatchArray,\n    commands: SingleCommands,\n    chain: () => ChainedCommands,\n    can: () => CanCommands,\n  }) => void | null\n\n  constructor(config: {\n    find: PasteRuleFinder,\n    handler: (props: {\n      state: EditorState,\n      range: Range,\n      match: ExtendedRegExpMatchArray,\n      commands: SingleCommands,\n      chain: () => ChainedCommands,\n      can: () => CanCommands,\n    }) => void | null,\n  }) {\n    this.find = config.find\n    this.handler = config.handler\n  }\n}\n\nconst pasteRuleMatcherHandler = (text: string, find: PasteRuleFinder): ExtendedRegExpMatchArray[] => {\n  if (isRegExp(find)) {\n    return [...text.matchAll(find)]\n  }\n\n  const matches = find(text)\n\n  if (!matches) {\n    return []\n  }\n\n  return matches.map(pasteRuleMatch => {\n    const result: ExtendedRegExpMatchArray = []\n\n    result.push(pasteRuleMatch.text)\n    result.index = pasteRuleMatch.index\n    result.input = text\n    result.data = pasteRuleMatch.data\n\n    if (pasteRuleMatch.replaceWith) {\n      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n        console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".')\n      }\n\n      result.push(pasteRuleMatch.replaceWith)\n    }\n\n    return result\n  })\n}\n\nfunction run(config: {\n  editor: Editor,\n  state: EditorState,\n  from: number,\n  to: number,\n  rule: PasteRule,\n}): boolean {\n  const {\n    editor,\n    state,\n    from,\n    to,\n    rule,\n  } = config\n\n  const { commands, chain, can } = new CommandManager({\n    editor,\n    state,\n  })\n\n  const handlers: (void | null)[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isTextblock || node.type.spec.code) {\n      return\n    }\n\n    const resolvedFrom = Math.max(from, pos)\n    const resolvedTo = Math.min(to, pos + node.content.size)\n    const textToMatch = node.textBetween(\n      resolvedFrom - pos,\n      resolvedTo - pos,\n      undefined,\n      '\\ufffc',\n    )\n\n    const matches = pasteRuleMatcherHandler(textToMatch, rule.find)\n\n    matches.forEach(match => {\n      if (match.index === undefined) {\n        return\n      }\n\n      const start = resolvedFrom + match.index + 1\n      const end = start + match[0].length\n      const range = {\n        from: state.tr.mapping.map(start),\n        to: state.tr.mapping.map(end),\n      }\n\n      const handler = rule.handler({\n        state,\n        range,\n        match,\n        commands,\n        chain,\n        can,\n      })\n\n      handlers.push(handler)\n    })\n  })\n\n  const success = handlers.every(handler => handler !== null)\n\n  return success\n}\n\n/**\n * Create an paste rules plugin. When enabled, it will cause pasted\n * text that matches any of the given rules to trigger the rule’s\n * action.\n */\nexport function pasteRulesPlugin(props: { editor: Editor, rules: PasteRule[] }): Plugin[] {\n  const { editor, rules } = props\n  let dragSourceElement: Element | null = null\n  let isPastedFromProseMirror = false\n  let isDroppedFromProseMirror = false\n\n  const plugins = rules.map(rule => {\n    return new Plugin({\n      // we register a global drag handler to track the current drag source element\n      view(view) {\n        const handleDragstart = (event: DragEvent) => {\n          dragSourceElement = view.dom.parentElement?.contains(event.target as Element)\n            ? view.dom.parentElement\n            : null\n        }\n\n        window.addEventListener('dragstart', handleDragstart)\n\n        return {\n          destroy() {\n            window.removeEventListener('dragstart', handleDragstart)\n          },\n        }\n      },\n\n      props: {\n        handleDOMEvents: {\n          drop: view => {\n            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement\n\n            return false\n          },\n\n          paste: (view, event: Event) => {\n            const html = (event as ClipboardEvent).clipboardData?.getData('text/html')\n\n            isPastedFromProseMirror = !!html?.includes('data-pm-slice')\n\n            return false\n          },\n        },\n      },\n\n      appendTransaction: (transactions, oldState, state) => {\n        const transaction = transactions[0]\n        const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror\n        const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror\n\n        if (!isPaste && !isDrop) {\n          return\n        }\n\n        // stop if there is no changed range\n        const from = oldState.doc.content.findDiffStart(state.doc.content)\n        const to = oldState.doc.content.findDiffEnd(state.doc.content)\n\n        if (!isNumber(from) || !to || from === to.b) {\n          return\n        }\n\n        // build a chainable state\n        // so we can use a single transaction for all paste rules\n        const tr = state.tr\n        const chainableState = createChainableState({\n          state,\n          transaction: tr,\n        })\n\n        const handler = run({\n          editor,\n          state: chainableState,\n          from: Math.max(from - 1, 0),\n          to: to.b,\n          rule,\n        })\n\n        // stop if there are no changes\n        if (!handler || !tr.steps.length) {\n          return\n        }\n\n        return tr\n      },\n    })\n  })\n\n  return plugins\n}\n","export function findDuplicates(items: any[]): any[] {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index)\n\n  return [...new Set(filtered)]\n}\n","import { keymap } from 'prosemirror-keymap'\nimport { Node as ProsemirrorNode, Schema } from 'prosemirror-model'\nimport { Plugin } from 'prosemirror-state'\nimport { Decoration, EditorView } from 'prosemirror-view'\n\nimport { NodeConfig } from '.'\nimport { Editor } from './Editor'\nimport { getAttributesFromExtensions } from './helpers/getAttributesFromExtensions'\nimport { getExtensionField } from './helpers/getExtensionField'\nimport { getNodeType } from './helpers/getNodeType'\nimport { getRenderedAttributes } from './helpers/getRenderedAttributes'\nimport { getSchemaByResolvedExtensions } from './helpers/getSchemaByResolvedExtensions'\nimport { getSchemaTypeByName } from './helpers/getSchemaTypeByName'\nimport { isExtensionRulesEnabled } from './helpers/isExtensionRulesEnabled'\nimport { splitExtensions } from './helpers/splitExtensions'\nimport { inputRulesPlugin } from './InputRule'\nimport { pasteRulesPlugin } from './PasteRule'\nimport { AnyConfig, Extensions, RawCommands } from './types'\nimport { callOrReturn } from './utilities/callOrReturn'\nimport { findDuplicates } from './utilities/findDuplicates'\n\nexport class ExtensionManager {\n\n  editor: Editor\n\n  schema: Schema\n\n  extensions: Extensions\n\n  splittableMarks: string[] = []\n\n  constructor(extensions: Extensions, editor: Editor) {\n    this.editor = editor\n    this.extensions = ExtensionManager.resolve(extensions)\n    this.schema = getSchemaByResolvedExtensions(this.extensions)\n\n    this.extensions.forEach(extension => {\n      // store extension storage in editor\n      this.editor.extensionStorage[extension.name] = extension.storage\n\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      if (extension.type === 'mark') {\n        const keepOnSplit = callOrReturn(getExtensionField(extension, 'keepOnSplit', context)) ?? true\n\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name)\n        }\n      }\n\n      const onBeforeCreate = getExtensionField<AnyConfig['onBeforeCreate']>(\n        extension,\n        'onBeforeCreate',\n        context,\n      )\n\n      if (onBeforeCreate) {\n        this.editor.on('beforeCreate', onBeforeCreate)\n      }\n\n      const onCreate = getExtensionField<AnyConfig['onCreate']>(\n        extension,\n        'onCreate',\n        context,\n      )\n\n      if (onCreate) {\n        this.editor.on('create', onCreate)\n      }\n\n      const onUpdate = getExtensionField<AnyConfig['onUpdate']>(\n        extension,\n        'onUpdate',\n        context,\n      )\n\n      if (onUpdate) {\n        this.editor.on('update', onUpdate)\n      }\n\n      const onSelectionUpdate = getExtensionField<AnyConfig['onSelectionUpdate']>(\n        extension,\n        'onSelectionUpdate',\n        context,\n      )\n\n      if (onSelectionUpdate) {\n        this.editor.on('selectionUpdate', onSelectionUpdate)\n      }\n\n      const onTransaction = getExtensionField<AnyConfig['onTransaction']>(\n        extension,\n        'onTransaction',\n        context,\n      )\n\n      if (onTransaction) {\n        this.editor.on('transaction', onTransaction)\n      }\n\n      const onFocus = getExtensionField<AnyConfig['onFocus']>(\n        extension,\n        'onFocus',\n        context,\n      )\n\n      if (onFocus) {\n        this.editor.on('focus', onFocus)\n      }\n\n      const onBlur = getExtensionField<AnyConfig['onBlur']>(\n        extension,\n        'onBlur',\n        context,\n      )\n\n      if (onBlur) {\n        this.editor.on('blur', onBlur)\n      }\n\n      const onDestroy = getExtensionField<AnyConfig['onDestroy']>(\n        extension,\n        'onDestroy',\n        context,\n      )\n\n      if (onDestroy) {\n        this.editor.on('destroy', onDestroy)\n      }\n    })\n  }\n\n  static resolve(extensions: Extensions): Extensions {\n    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions))\n    const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name))\n\n    if (duplicatedNames.length) {\n      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map(item => `'${item}'`).join(', ')}]. This can lead to issues.`)\n    }\n\n    return resolvedExtensions\n  }\n\n  static flatten(extensions: Extensions): Extensions {\n    return extensions\n      .map(extension => {\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          storage: extension.storage,\n        }\n\n        const addExtensions = getExtensionField<AnyConfig['addExtensions']>(\n          extension,\n          'addExtensions',\n          context,\n        )\n\n        if (addExtensions) {\n          return [\n            extension,\n            ...this.flatten(addExtensions()),\n          ]\n        }\n\n        return extension\n      })\n      // `Infinity` will break TypeScript so we set a number that is probably high enough\n      .flat(10)\n  }\n\n  static sort(extensions: Extensions): Extensions {\n    const defaultPriority = 100\n\n    return extensions.sort((a, b) => {\n      const priorityA = getExtensionField<AnyConfig['priority']>(a, 'priority') || defaultPriority\n      const priorityB = getExtensionField<AnyConfig['priority']>(b, 'priority') || defaultPriority\n\n      if (priorityA > priorityB) {\n        return -1\n      }\n\n      if (priorityA < priorityB) {\n        return 1\n      }\n\n      return 0\n    })\n  }\n\n  get commands(): RawCommands {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      const addCommands = getExtensionField<AnyConfig['addCommands']>(\n        extension,\n        'addCommands',\n        context,\n      )\n\n      if (!addCommands) {\n        return commands\n      }\n\n      return {\n        ...commands,\n        ...addCommands(),\n      }\n    }, {} as RawCommands)\n  }\n\n  get plugins(): Plugin[] {\n    const { editor } = this\n\n    // With ProseMirror, first plugins within an array are executed first.\n    // In tiptap, we provide the ability to override plugins,\n    // so it feels more natural to run plugins at the end of an array first.\n    // That’s why we have to reverse the `extensions` array and sort again\n    // based on the `priority` option.\n    const extensions = ExtensionManager.sort([...this.extensions].reverse())\n\n    const inputRules: any[] = []\n    const pasteRules: any[] = []\n\n    const allPlugins = extensions\n      .map(extension => {\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          storage: extension.storage,\n          editor,\n          type: getSchemaTypeByName(extension.name, this.schema),\n        }\n\n        const plugins: Plugin[] = []\n\n        const addKeyboardShortcuts = getExtensionField<AnyConfig['addKeyboardShortcuts']>(\n          extension,\n          'addKeyboardShortcuts',\n          context,\n        )\n\n        if (addKeyboardShortcuts) {\n          const bindings = Object.fromEntries(\n            Object\n              .entries(addKeyboardShortcuts())\n              .map(([shortcut, method]) => {\n                return [shortcut, () => method({ editor })]\n              }),\n          )\n\n          const keyMapPlugin = keymap(bindings)\n\n          plugins.push(keyMapPlugin)\n        }\n\n        const addInputRules = getExtensionField<AnyConfig['addInputRules']>(\n          extension,\n          'addInputRules',\n          context,\n        )\n\n        if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n          inputRules.push(...addInputRules())\n        }\n\n        const addPasteRules = getExtensionField<AnyConfig['addPasteRules']>(\n          extension,\n          'addPasteRules',\n          context,\n        )\n\n        if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n          pasteRules.push(...addPasteRules())\n        }\n\n        const addProseMirrorPlugins = getExtensionField<AnyConfig['addProseMirrorPlugins']>(\n          extension,\n          'addProseMirrorPlugins',\n          context,\n        )\n\n        if (addProseMirrorPlugins) {\n          const proseMirrorPlugins = addProseMirrorPlugins()\n\n          plugins.push(...proseMirrorPlugins)\n        }\n\n        return plugins\n      })\n      .flat()\n\n    return [\n      inputRulesPlugin({\n        editor,\n        rules: inputRules,\n      }),\n      ...pasteRulesPlugin({\n        editor,\n        rules: pasteRules,\n      }),\n      ...allPlugins,\n    ]\n  }\n\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions)\n  }\n\n  get nodeViews() {\n    const { editor } = this\n    const { nodeExtensions } = splitExtensions(this.extensions)\n\n    return Object.fromEntries(nodeExtensions\n      .filter(extension => !!getExtensionField(extension, 'addNodeView'))\n      .map(extension => {\n        const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name)\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          storage: extension.storage,\n          editor,\n          type: getNodeType(extension.name, this.schema),\n        }\n        const addNodeView = getExtensionField<NodeConfig['addNodeView']>(\n          extension,\n          'addNodeView',\n          context,\n        )\n\n        if (!addNodeView) {\n          return []\n        }\n\n        const nodeview = (\n          node: ProsemirrorNode,\n          view: EditorView,\n          getPos: (() => number) | boolean,\n          decorations: Decoration[],\n        ) => {\n          const HTMLAttributes = getRenderedAttributes(node, extensionAttributes)\n\n          return addNodeView()({\n            editor,\n            node,\n            getPos,\n            decorations,\n            HTMLAttributes,\n            extension,\n          })\n        }\n\n        return [extension.name, nodeview]\n      }))\n  }\n}\n","// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\n\nfunction getType(value: any): string {\n  return Object.prototype.toString.call(value).slice(8, -1)\n}\n\nexport function isPlainObject(value: any): value is Record<string, any> {\n  if (getType(value) !== 'Object') {\n    return false\n  }\n\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype\n}\n","import { isPlainObject } from './isPlainObject'\n\nexport function mergeDeep(target: Record<string, any>, source: Record<string, any>): Record<string, any> {\n  const output = { ...target }\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, { [key]: source[key] })\n        } else {\n          output[key] = mergeDeep(target[key], source[key])\n        }\n      } else {\n        Object.assign(output, { [key]: source[key] })\n      }\n    })\n  }\n\n  return output\n}\n","import { Plugin, Transaction } from 'prosemirror-state'\n\nimport { ExtensionConfig } from '.'\nimport { Editor } from './Editor'\nimport { getExtensionField } from './helpers/getExtensionField'\nimport { InputRule } from './InputRule'\nimport { Mark } from './Mark'\nimport { Node } from './Node'\nimport { PasteRule } from './PasteRule'\nimport {\n  AnyConfig,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  ParentConfig,\n  RawCommands,\n} from './types'\nimport { callOrReturn } from './utilities/callOrReturn'\nimport { mergeDeep } from './utilities/mergeDeep'\n\ndeclare module '@tiptap/core' {\n  interface ExtensionConfig<Options = any, Storage = any> {\n    [key: string]: any;\n\n    /**\n     * Name\n     */\n    name: string,\n\n    /**\n     * Priority\n     */\n    priority?: number,\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options,\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string,\n      parent: Exclude<ParentConfig<ExtensionConfig<Options, Storage>>['addOptions'], undefined>,\n    }) => Options,\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string,\n      options: Options,\n      parent: Exclude<ParentConfig<ExtensionConfig<Options, Storage>>['addStorage'], undefined>,\n    }) => Storage,\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addGlobalAttributes'],\n    }) => GlobalAttributes | {},\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addCommands'],\n    }) => Partial<RawCommands>,\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addKeyboardShortcuts'],\n    }) => {\n      [key: string]: KeyboardShortcutCommand,\n    },\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addInputRules'],\n    }) => InputRule[],\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addPasteRules'],\n    }) => PasteRule[],\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addProseMirrorPlugins'],\n    }) => Plugin[],\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['addExtensions'],\n    }) => Extensions,\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        parent: ParentConfig<ExtensionConfig<Options, Storage>>['extendNodeSchema'],\n      },\n      extension: Node,\n    ) => Record<string, any>) | null,\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        parent: ParentConfig<ExtensionConfig<Options, Storage>>['extendMarkSchema'],\n      },\n      extension: Mark,\n    ) => Record<string, any>) | null,\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?: ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['onBeforeCreate'],\n    }) => void) | null,\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?: ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['onCreate'],\n    }) => void) | null,\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?: ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['onUpdate'],\n    }) => void) | null,\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?: ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['onSelectionUpdate'],\n    }) => void) | null,\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        editor: Editor,\n        parent: ParentConfig<ExtensionConfig<Options, Storage>>['onTransaction'],\n      },\n      props: {\n        transaction: Transaction,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        editor: Editor,\n        parent: ParentConfig<ExtensionConfig<Options, Storage>>['onFocus'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        editor: Editor,\n        parent: ParentConfig<ExtensionConfig<Options, Storage>>['onBlur'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?: ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      parent: ParentConfig<ExtensionConfig<Options, Storage>>['onDestroy'],\n    }) => void) | null,\n  }\n}\n\nexport class Extension<Options = any, Storage = any> {\n  type = 'extension'\n\n  name = 'extension'\n\n  parent: Extension | null = null\n\n  child: Extension | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: ExtensionConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<ExtensionConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`)\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField<AnyConfig['addOptions']>(\n        this,\n        'addOptions',\n        {\n          name: this.name,\n        },\n      ))\n    }\n\n    this.storage = callOrReturn(getExtensionField<AnyConfig['addStorage']>(\n      this,\n      'addStorage',\n      {\n        name: this.name,\n        options: this.options,\n      },\n    )) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<ExtensionConfig<O, S>> = {}) {\n    return new Extension<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options, options) as Options\n\n    extension.storage = callOrReturn(getExtensionField<AnyConfig['addStorage']>(\n      extension,\n      'addStorage',\n      {\n        name: extension.name,\n        options: extension.options,\n      },\n    ))\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(extendedConfig: Partial<ExtensionConfig<ExtendedOptions, ExtendedStorage>> = {}) {\n    const extension = new Extension<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name\n      ? extendedConfig.name\n      : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`)\n    }\n\n    extension.options = callOrReturn(getExtensionField<AnyConfig['addOptions']>(\n      extension,\n      'addOptions',\n      {\n        name: extension.name,\n      },\n    ))\n\n    extension.storage = callOrReturn(getExtensionField<AnyConfig['addStorage']>(\n      extension,\n      'addStorage',\n      {\n        name: extension.name,\n        options: extension.options,\n      },\n    ))\n\n    return extension\n  }\n}\n","import { Node as ProseMirrorNode } from 'prosemirror-model'\n\nimport { Range, TextSerializer } from '../types'\n\nexport function getTextBetween(\n  startNode: ProseMirrorNode,\n  range: Range,\n  options?: {\n    blockSeparator?: string,\n    textSerializers?: Record<string, TextSerializer>,\n  },\n): string {\n  const { from, to } = range\n  const {\n    blockSeparator = '\\n\\n',\n    textSerializers = {},\n  } = options || {}\n  let text = ''\n  let separated = true\n\n  startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n    const textSerializer = textSerializers?.[node.type.name]\n\n    if (textSerializer) {\n      if (node.isBlock && !separated) {\n        text += blockSeparator\n        separated = true\n      }\n\n      if (parent) {\n        text += textSerializer({\n          node,\n          pos,\n          parent,\n          index,\n          range,\n        })\n      }\n    } else if (node.isText) {\n      text += node?.text?.slice(Math.max(from, pos) - pos, to - pos) // eslint-disable-line\n      separated = false\n    } else if (node.isBlock && !separated) {\n      text += blockSeparator\n      separated = true\n    }\n  })\n\n  return text\n}\n","import { Schema } from 'prosemirror-model'\n\nimport { TextSerializer } from '../types'\n\nexport function getTextSerializersFromSchema(schema: Schema): Record<string, TextSerializer> {\n  return Object.fromEntries(Object\n    .entries(schema.nodes)\n    .filter(([, node]) => node.spec.toText)\n    .map(([name, node]) => [name, node.spec.toText]))\n}\n","import { Plugin, PluginKey } from 'prosemirror-state'\n\nimport { Extension } from '../Extension'\nimport { getTextBetween } from '../helpers/getTextBetween'\nimport { getTextSerializersFromSchema } from '../helpers/getTextSerializersFromSchema'\n\nexport const ClipboardTextSerializer = Extension.create({\n  name: 'clipboardTextSerializer',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('clipboardTextSerializer'),\n        props: {\n          clipboardTextSerializer: () => {\n            const { editor } = this\n            const { state, schema } = editor\n            const { doc, selection } = state\n            const { ranges } = selection\n            const from = Math.min(...ranges.map(range => range.$from.pos))\n            const to = Math.max(...ranges.map(range => range.$to.pos))\n            const textSerializers = getTextSerializersFromSchema(schema)\n            const range = { from, to }\n\n            return getTextBetween(doc, range, {\n              textSerializers,\n            })\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    blur: {\n      /**\n       * Removes focus from the editor.\n       */\n      blur: () => ReturnType,\n    }\n  }\n}\n\nexport const blur: RawCommands['blur'] = () => ({ editor, view }) => {\n  requestAnimationFrame(() => {\n    if (!editor.isDestroyed) {\n      (view.dom as HTMLElement).blur()\n\n      // Browsers should remove the caret on blur but safari does not.\n      // See: https://github.com/ueberdosis/tiptap/issues/2405\n      window?.getSelection()?.removeAllRanges()\n    }\n  })\n\n  return true\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    clearContent: {\n      /**\n       * Clear the whole document.\n       */\n      clearContent: (emitUpdate?: boolean) => ReturnType,\n    }\n  }\n}\n\nexport const clearContent: RawCommands['clearContent'] = (emitUpdate = false) => ({ commands }) => {\n  return commands.setContent('', emitUpdate)\n}\n","import { liftTarget } from 'prosemirror-transform'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    clearNodes: {\n      /**\n       * Normalize nodes to a simple paragraph.\n       */\n      clearNodes: () => ReturnType,\n    }\n  }\n}\n\nexport const clearNodes: RawCommands['clearNodes'] = () => ({ state, tr, dispatch }) => {\n  const { selection } = tr\n  const { ranges } = selection\n\n  if (!dispatch) {\n    return true\n  }\n\n  ranges.forEach(({ $from, $to }) => {\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return\n      }\n\n      const { doc, mapping } = tr\n      const $mappedFrom = doc.resolve(mapping.map(pos))\n      const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize))\n      const nodeRange = $mappedFrom.blockRange($mappedTo)\n\n      if (!nodeRange) {\n        return\n      }\n\n      const targetLiftDepth = liftTarget(nodeRange)\n\n      if (node.type.isTextblock) {\n        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index())\n\n        tr.setNodeMarkup(nodeRange.start, defaultType)\n      }\n\n      if (targetLiftDepth || targetLiftDepth === 0) {\n        tr.lift(nodeRange, targetLiftDepth)\n      }\n    })\n  })\n\n  return true\n}\n","import { Command, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    command: {\n      /**\n       * Define a command inline.\n       */\n      command: (fn: (props: Parameters<Command>[0]) => boolean) => ReturnType,\n    }\n  }\n}\n\nexport const command: RawCommands['command'] = fn => props => {\n  return fn(props)\n}\n","import { createParagraphNear as originalCreateParagraphNear } from 'prosemirror-commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    createParagraphNear: {\n      /**\n       * Create a paragraph nearby.\n       */\n      createParagraphNear: () => ReturnType,\n    }\n  }\n}\n\nexport const createParagraphNear: RawCommands['createParagraphNear'] = () => ({ state, dispatch }) => {\n  return originalCreateParagraphNear(state, dispatch)\n}\n","import { NodeType } from 'prosemirror-model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteNode: {\n      /**\n       * Delete a node.\n       */\n      deleteNode: (typeOrName: string | NodeType) => ReturnType,\n    }\n  }\n}\n\nexport const deleteNode: RawCommands['deleteNode'] = typeOrName => ({ tr, state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const $pos = tr.selection.$anchor\n\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth)\n\n    if (node.type === type) {\n      if (dispatch) {\n        const from = $pos.before(depth)\n        const to = $pos.after(depth)\n\n        tr.delete(from, to).scrollIntoView()\n      }\n\n      return true\n    }\n  }\n\n  return false\n}\n","import { Range, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteRange: {\n      /**\n       * Delete a given range.\n       */\n      deleteRange: (range: Range) => ReturnType,\n    }\n  }\n}\n\nexport const deleteRange: RawCommands['deleteRange'] = range => ({ tr, dispatch }) => {\n  const { from, to } = range\n\n  if (dispatch) {\n    tr.delete(from, to)\n  }\n\n  return true\n}\n","import { deleteSelection as originalDeleteSelection } from 'prosemirror-commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteSelection: {\n      /**\n       * Delete the selection, if there is one.\n       */\n      deleteSelection: () => ReturnType,\n    }\n  }\n}\n\nexport const deleteSelection: RawCommands['deleteSelection'] = () => ({ state, dispatch }) => {\n  return originalDeleteSelection(state, dispatch)\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    enter: {\n      /**\n       * Trigger enter.\n       */\n      enter: () => ReturnType,\n    }\n  }\n}\n\nexport const enter: RawCommands['enter'] = () => ({ commands }) => {\n  return commands.keyboardShortcut('Enter')\n}\n","import { exitCode as originalExitCode } from 'prosemirror-commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    exitCode: {\n      /**\n       * Exit from a code block.\n       */\n      exitCode: () => ReturnType,\n    }\n  }\n}\n\nexport const exitCode: RawCommands['exitCode'] = () => ({ state, dispatch }) => {\n  return originalExitCode(state, dispatch)\n}\n","import { isRegExp } from './isRegExp'\n\n/**\n * Check if object1 includes object2\n * @param object1 Object\n * @param object2 Object\n */\nexport function objectIncludes(\n  object1: Record<string, any>,\n  object2: Record<string, any>,\n  options: { strict: boolean } = { strict: true },\n): boolean {\n  const keys = Object.keys(object2)\n\n  if (!keys.length) {\n    return true\n  }\n\n  return keys.every(key => {\n    if (options.strict) {\n      return object2[key] === object1[key]\n    }\n\n    if (isRegExp(object2[key])) {\n      return object2[key].test(object1[key])\n    }\n\n    return object2[key] === object1[key]\n  })\n}\n","import { Mark as ProseMirrorMark, MarkType, ResolvedPos } from 'prosemirror-model'\n\nimport { Range } from '../types'\nimport { objectIncludes } from '../utilities/objectIncludes'\n\nfunction findMarkInSet(\n  marks: ProseMirrorMark[],\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): ProseMirrorMark | undefined {\n  return marks.find(item => {\n    return item.type === type && objectIncludes(item.attrs, attributes)\n  })\n}\n\nfunction isMarkInSet(\n  marks: ProseMirrorMark[],\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): boolean {\n  return !!findMarkInSet(marks, type, attributes)\n}\n\nexport function getMarkRange(\n  $pos: ResolvedPos,\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): Range | void {\n  if (!$pos || !type) {\n    return\n  }\n\n  let start = $pos.parent.childAfter($pos.parentOffset)\n\n  if ($pos.parentOffset === start.offset && start.offset !== 0) {\n    start = $pos.parent.childBefore($pos.parentOffset)\n  }\n\n  if (!start.node) {\n    return\n  }\n\n  const mark = findMarkInSet([...start.node.marks], type, attributes)\n\n  if (!mark) {\n    return\n  }\n\n  let startIndex = start.index\n  let startPos = $pos.start() + start.offset\n  let endIndex = startIndex + 1\n  let endPos = startPos + start.node.nodeSize\n\n  findMarkInSet([...start.node.marks], type, attributes)\n\n  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1\n    startPos -= $pos.parent.child(startIndex).nodeSize\n  }\n\n  while (\n    endIndex < $pos.parent.childCount\n    && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)\n  ) {\n    endPos += $pos.parent.child(endIndex).nodeSize\n    endIndex += 1\n  }\n\n  return {\n    from: startPos,\n    to: endPos,\n  }\n}\n","import { MarkType, Schema } from 'prosemirror-model'\n\nexport function getMarkType(nameOrType: string | MarkType, schema: Schema): MarkType {\n  if (typeof nameOrType === 'string') {\n    if (!schema.marks[nameOrType]) {\n      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`)\n    }\n\n    return schema.marks[nameOrType]\n  }\n\n  return nameOrType\n}\n","import { MarkType } from 'prosemirror-model'\nimport { TextSelection } from 'prosemirror-state'\n\nimport { getMarkRange } from '../helpers/getMarkRange'\nimport { getMarkType } from '../helpers/getMarkType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    extendMarkRange: {\n      /**\n       * Extends the text selection to the current mark.\n       */\n      extendMarkRange: (typeOrName: string | MarkType, attributes?: Record<string, any>) => ReturnType,\n    }\n  }\n}\n\nexport const extendMarkRange: RawCommands['extendMarkRange'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const type = getMarkType(typeOrName, state.schema)\n  const { doc, selection } = tr\n  const { $from, from, to } = selection\n\n  if (dispatch) {\n    const range = getMarkRange($from, type, attributes)\n\n    if (range && range.from <= from && range.to >= to) {\n      const newSelection = TextSelection.create(doc, range.from, range.to)\n\n      tr.setSelection(newSelection)\n    }\n  }\n\n  return true\n}\n","import { Command, CommandProps, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    first: {\n      /**\n       * Runs one command after the other and stops at the first which returns true.\n       */\n      first: (commands: Command[] | ((props: CommandProps) => Command[])) => ReturnType,\n    }\n  }\n}\n\nexport const first: RawCommands['first'] = commands => props => {\n  const items = typeof commands === 'function'\n    ? commands(props)\n    : commands\n\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true\n    }\n  }\n\n  return false\n}\n","export function isClass(value: any): boolean {\n  if (value.constructor?.toString().substring(0, 5) !== 'class') {\n    return false\n  }\n\n  return true\n}\n","import { isClass } from './isClass'\n\nexport function isObject(value: any): boolean {\n  return (\n    value\n    && typeof value === 'object'\n    && !Array.isArray(value)\n    && !isClass(value)\n  )\n}\n","import { TextSelection } from 'prosemirror-state'\n\nimport { isObject } from '../utilities/isObject'\n\nexport function isTextSelection(value: unknown): value is TextSelection {\n  return isObject(value) && value instanceof TextSelection\n}\n","export function minMax(value = 0, min = 0, max = 0): number {\n  return Math.min(Math.max(value, min), max)\n}\n","import { Node as ProseMirrorNode } from 'prosemirror-model'\nimport { Selection, TextSelection } from 'prosemirror-state'\n\nimport { FocusPosition } from '../types'\nimport { minMax } from '../utilities/minMax'\n\nexport function resolveFocusPosition(\n  doc: ProseMirrorNode,\n  position: FocusPosition = null,\n): Selection | null {\n\n  if (!position) {\n    return null\n  }\n\n  const selectionAtStart = Selection.atStart(doc)\n  const selectionAtEnd = Selection.atEnd(doc)\n\n  if (position === 'start' || position === true) {\n    return selectionAtStart\n  }\n\n  if (position === 'end') {\n    return selectionAtEnd\n  }\n\n  const minPos = selectionAtStart.from\n  const maxPos = selectionAtEnd.to\n\n  if (position === 'all') {\n    return TextSelection.create(\n      doc,\n      minMax(0, minPos, maxPos),\n      minMax(doc.content.size, minPos, maxPos),\n    )\n  }\n\n  return TextSelection.create(\n    doc,\n    minMax(position, minPos, maxPos),\n    minMax(position, minPos, maxPos),\n  )\n}\n","export function isiOS(): boolean {\n  return [\n    'iPad Simulator',\n    'iPhone Simulator',\n    'iPod Simulator',\n    'iPad',\n    'iPhone',\n    'iPod',\n  ].includes(navigator.platform)\n  // iPad on iOS 13 detection\n  || (navigator.userAgent.includes('Mac') && 'ontouchend' in document)\n}\n","import { isTextSelection } from '../helpers/isTextSelection'\nimport { resolveFocusPosition } from '../helpers/resolveFocusPosition'\nimport { FocusPosition, RawCommands } from '../types'\nimport { isiOS } from '../utilities/isiOS'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    focus: {\n      /**\n       * Focus the editor at the given position.\n       */\n      focus: (\n        position?: FocusPosition,\n        options?: {\n          scrollIntoView?: boolean,\n        },\n      ) => ReturnType,\n    }\n  }\n}\n\nexport const focus: RawCommands['focus'] = (position = null, options = {}) => ({\n  editor,\n  view,\n  tr,\n  dispatch,\n}) => {\n  options = {\n    scrollIntoView: true,\n    ...options,\n  }\n\n  const delayedFocus = () => {\n    // focus within `requestAnimationFrame` breaks focus on iOS\n    // so we have to call this\n    if (isiOS()) {\n      (view.dom as HTMLElement).focus()\n    }\n\n    // For React we have to focus asynchronously. Otherwise wild things happen.\n    // see: https://github.com/ueberdosis/tiptap/issues/1520\n    requestAnimationFrame(() => {\n      if (!editor.isDestroyed) {\n        view.focus()\n\n        if (options?.scrollIntoView) {\n          editor.commands.scrollIntoView()\n        }\n      }\n    })\n  }\n\n  if ((view.hasFocus() && position === null) || position === false) {\n    return true\n  }\n\n  // we don’t try to resolve a NodeSelection or CellSelection\n  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n    delayedFocus()\n    return true\n  }\n\n  // pass through tr.doc instead of editor.state.doc\n  // since transactions could change the editors state before this command has been run\n  const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection\n  const isSameSelection = editor.state.selection.eq(selection)\n\n  if (dispatch) {\n    if (!isSameSelection) {\n      tr.setSelection(selection)\n    }\n\n    // `tr.setSelection` resets the stored marks\n    // so we’ll restore them if the selection is the same as before\n    if (isSameSelection && tr.storedMarks) {\n      tr.setStoredMarks(tr.storedMarks)\n    }\n\n    delayedFocus()\n  }\n\n  return true\n}\n","import { CommandProps, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    forEach: {\n      /**\n       * Loop through an array of items.\n       */\n      forEach: <T>(\n        items: T[],\n        fn: (\n          item: T,\n          props: CommandProps & {\n            index: number,\n          },\n        ) => boolean,\n      ) => ReturnType,\n    }\n  }\n}\n\nexport const forEach: RawCommands['forEach'] = (items, fn) => props => {\n  return items.every((item, index) => fn(item, { ...props, index }))\n}\n","import { ParseOptions } from 'prosemirror-model'\n\nimport { Content, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    insertContent: {\n      /**\n       * Insert a node or string of HTML at the current position.\n       */\n      insertContent: (\n        value: Content,\n        options?: {\n          parseOptions?: ParseOptions,\n          updateSelection?: boolean,\n        },\n      ) => ReturnType,\n    }\n  }\n}\n\nexport const insertContent: RawCommands['insertContent'] = (value, options) => ({ tr, commands }) => {\n  return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options)\n}\n","export function elementFromString(value: string): HTMLElement {\n  // add a wrapper to preserve leading and trailing whitespace\n  const wrappedValue = `<body>${value}</body>`\n\n  return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body\n}\n","import {\n  DOMParser,\n  Fragment,\n  Node as ProseMirrorNode,\n  ParseOptions,\n  Schema,\n} from 'prosemirror-model'\n\nimport { Content } from '../types'\nimport { elementFromString } from '../utilities/elementFromString'\n\nexport type CreateNodeFromContentOptions = {\n  slice?: boolean,\n  parseOptions?: ParseOptions,\n}\n\nexport function createNodeFromContent(\n  content: Content,\n  schema: Schema,\n  options?: CreateNodeFromContentOptions,\n): ProseMirrorNode | Fragment {\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options,\n  }\n\n  if (typeof content === 'object' && content !== null) {\n    try {\n      if (Array.isArray(content)) {\n        return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)))\n      }\n\n      return schema.nodeFromJSON(content)\n    } catch (error) {\n      console.warn(\n        '[tiptap warn]: Invalid content.',\n        'Passed value:',\n        content,\n        'Error:',\n        error,\n      )\n\n      return createNodeFromContent('', schema, options)\n    }\n  }\n\n  if (typeof content === 'string') {\n    const parser = DOMParser.fromSchema(schema)\n\n    return options.slice\n      ? parser.parseSlice(elementFromString(content), options.parseOptions).content\n      : parser.parse(elementFromString(content), options.parseOptions)\n  }\n\n  return createNodeFromContent('', schema, options)\n}\n","import { Selection, Transaction } from 'prosemirror-state'\nimport { ReplaceAroundStep, ReplaceStep } from 'prosemirror-transform'\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nexport function selectionToInsertionEnd(tr: Transaction, startLen: number, bias: number) {\n  const last = tr.steps.length - 1\n\n  if (last < startLen) {\n    return\n  }\n\n  const step = tr.steps[last]\n\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return\n  }\n\n  const map = tr.mapping.maps[last]\n  let end = 0\n\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo\n    }\n  })\n\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias))\n}\n","import { Fragment, Node as ProseMirrorNode, ParseOptions } from 'prosemirror-model'\n\nimport { createNodeFromContent } from '../helpers/createNodeFromContent'\nimport { selectionToInsertionEnd } from '../helpers/selectionToInsertionEnd'\nimport {\n  Content,\n  Range,\n  RawCommands,\n} from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    insertContentAt: {\n      /**\n       * Insert a node or string of HTML at a specific position.\n       */\n      insertContentAt: (\n        position: number | Range,\n        value: Content,\n        options?: {\n          parseOptions?: ParseOptions,\n          updateSelection?: boolean,\n        },\n      ) => ReturnType,\n    }\n  }\n}\n\nconst isFragment = (nodeOrFragment: ProseMirrorNode | Fragment): nodeOrFragment is Fragment => {\n  return nodeOrFragment.toString().startsWith('<')\n}\n\nexport const insertContentAt: RawCommands['insertContentAt'] = (position, value, options) => ({ tr, dispatch, editor }) => {\n  if (dispatch) {\n    options = {\n      parseOptions: {},\n      updateSelection: true,\n      ...options,\n    }\n\n    const content = createNodeFromContent(value, editor.schema, {\n      parseOptions: {\n        preserveWhitespace: 'full',\n        ...options.parseOptions,\n      },\n    })\n\n    // don’t dispatch an empty fragment because this can lead to strange errors\n    if (content.toString() === '<>') {\n      return true\n    }\n\n    let { from, to } = typeof position === 'number'\n      ? { from: position, to: position }\n      : position\n\n    let isOnlyTextContent = true\n    let isOnlyBlockContent = true\n    const nodes = isFragment(content)\n      ? content\n      : [content]\n\n    nodes.forEach(node => {\n      // check if added node is valid\n      node.check()\n\n      isOnlyTextContent = isOnlyTextContent\n        ? node.isText && node.marks.length === 0\n        : false\n\n      isOnlyBlockContent = isOnlyBlockContent\n        ? node.isBlock\n        : false\n    })\n\n    // check if we can replace the wrapping node by\n    // the newly inserted content\n    // example:\n    // replace an empty paragraph by an inserted image\n    // instead of inserting the image below the paragraph\n    if (from === to && isOnlyBlockContent) {\n      const { parent } = tr.doc.resolve(from)\n      const isEmptyTextBlock = parent.isTextblock\n        && !parent.type.spec.code\n        && !parent.childCount\n\n      if (isEmptyTextBlock) {\n        from -= 1\n        to += 1\n      }\n    }\n\n    // if there is only plain text we have to use `insertText`\n    // because this will keep the current marks\n    if (isOnlyTextContent) {\n      tr.insertText(value as string, from, to)\n    } else {\n      tr.replaceWith(from, to, content)\n    }\n\n    // set cursor at end of inserted content\n    if (options.updateSelection) {\n      selectionToInsertionEnd(tr, tr.steps.length - 1, -1)\n    }\n  }\n\n  return true\n}\n","import { joinBackward as originalJoinBackward } from 'prosemirror-commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinBackward: {\n      /**\n       * Join two nodes backward.\n       */\n      joinBackward: () => ReturnType,\n    }\n  }\n}\n\nexport const joinBackward: RawCommands['joinBackward'] = () => ({ state, dispatch }) => {\n  return originalJoinBackward(state, dispatch)\n}\n","import { joinForward as originalJoinForward } from 'prosemirror-commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinForward: {\n      /**\n       * Join two nodes forward.\n       */\n      joinForward: () => ReturnType,\n    }\n  }\n}\n\nexport const joinForward: RawCommands['joinForward'] = () => ({ state, dispatch }) => {\n  return originalJoinForward(state, dispatch)\n}\n","export function isMacOS(): boolean {\n  return typeof navigator !== 'undefined'\n    ? /Mac/.test(navigator.platform)\n    : false\n}\n","import { RawCommands } from '../types'\nimport { isiOS } from '../utilities/isiOS'\nimport { isMacOS } from '../utilities/isMacOS'\n\nfunction normalizeKeyName(name: string) {\n  const parts = name.split(/-(?!$)/)\n  let result = parts[parts.length - 1]\n\n  if (result === 'Space') {\n    result = ' '\n  }\n\n  let alt\n  let ctrl\n  let shift\n  let meta\n\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i]\n\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true\n    } else if (/^mod$/i.test(mod)) {\n      if (isiOS() || isMacOS()) {\n        meta = true\n      } else {\n        ctrl = true\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`)\n    }\n  }\n\n  if (alt) {\n    result = `Alt-${result}`\n  }\n\n  if (ctrl) {\n    result = `Ctrl-${result}`\n  }\n\n  if (meta) {\n    result = `Meta-${result}`\n  }\n\n  if (shift) {\n    result = `Shift-${result}`\n  }\n\n  return result\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    keyboardShortcut: {\n      /**\n       * Trigger a keyboard shortcut.\n       */\n      keyboardShortcut: (name: string) => ReturnType,\n    }\n  }\n}\n\nexport const keyboardShortcut: RawCommands['keyboardShortcut'] = name => ({\n  editor,\n  view,\n  tr,\n  dispatch,\n}) => {\n  const keys = normalizeKeyName(name).split(/-(?!$)/)\n  const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item))\n  const event = new KeyboardEvent('keydown', {\n    key: key === 'Space'\n      ? ' '\n      : key,\n    altKey: keys.includes('Alt'),\n    ctrlKey: keys.includes('Ctrl'),\n    metaKey: keys.includes('Meta'),\n    shiftKey: keys.includes('Shift'),\n    bubbles: true,\n    cancelable: true,\n  })\n\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp('handleKeyDown', f => f(view, event))\n  })\n\n  capturedTransaction?.steps.forEach(step => {\n    const newStep = step.map(tr.mapping)\n\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep)\n    }\n  })\n\n  return true\n}\n","import { NodeType } from 'prosemirror-model'\nimport { EditorState } from 'prosemirror-state'\n\nimport { NodeRange } from '../types'\nimport { objectIncludes } from '../utilities/objectIncludes'\nimport { getNodeType } from './getNodeType'\n\nexport function isNodeActive(\n  state: EditorState,\n  typeOrName: NodeType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { from, to, empty } = state.selection\n  const type = typeOrName\n    ? getNodeType(typeOrName, state.schema)\n    : null\n\n  const nodeRanges: NodeRange[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      return\n    }\n\n    const relativeFrom = Math.max(from, pos)\n    const relativeTo = Math.min(to, pos + node.nodeSize)\n\n    nodeRanges.push({\n      node,\n      from: relativeFrom,\n      to: relativeTo,\n    })\n  })\n\n  const selectionRange = to - from\n  const matchedNodeRanges = nodeRanges\n    .filter(nodeRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === nodeRange.node.type.name\n    })\n    .filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }))\n\n  if (empty) {\n    return !!matchedNodeRanges.length\n  }\n\n  const range = matchedNodeRanges\n    .reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0)\n\n  return range >= selectionRange\n}\n","import { lift as originalLift } from 'prosemirror-commands'\nimport { NodeType } from 'prosemirror-model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { isNodeActive } from '../helpers/isNodeActive'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    lift: {\n      /**\n       * Removes an existing wrap.\n       */\n      lift: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType,\n    }\n  }\n}\n\nexport const lift: RawCommands['lift'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (!isActive) {\n    return false\n  }\n\n  return originalLift(state, dispatch)\n}\n","import { liftEmptyBlock as originalLiftEmptyBlock } from 'prosemirror-commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    liftEmptyBlock: {\n      /**\n       * Lift block if empty.\n       */\n      liftEmptyBlock: () => ReturnType,\n    }\n  }\n}\n\nexport const liftEmptyBlock: RawCommands['liftEmptyBlock'] = () => ({ state, dispatch }) => {\n  return originalLiftEmptyBlock(state, dispatch)\n}\n","import { NodeType } from 'prosemirror-model'\nimport { liftListItem as originalLiftListItem } from 'prosemirror-schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    liftListItem: {\n      /**\n       * Lift the list item into a wrapping list.\n       */\n      liftListItem: (typeOrName: string | NodeType) => ReturnType,\n    }\n  }\n}\n\nexport const liftListItem: RawCommands['liftListItem'] = typeOrName => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalLiftListItem(type)(state, dispatch)\n}\n","import { newlineInCode as originalNewlineInCode } from 'prosemirror-commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    newlineInCode: {\n      /**\n       * Add a newline character in code.\n       */\n      newlineInCode: () => ReturnType,\n    }\n  }\n}\n\nexport const newlineInCode: RawCommands['newlineInCode'] = () => ({ state, dispatch }) => {\n  return originalNewlineInCode(state, dispatch)\n}\n","import { Schema } from 'prosemirror-model'\n\nexport function getSchemaTypeNameByName(name: string, schema: Schema): 'node' | 'mark' | null {\n  if (schema.nodes[name]) {\n    return 'node'\n  }\n\n  if (schema.marks[name]) {\n    return 'mark'\n  }\n\n  return null\n}\n","/**\n * Remove a property or an array of properties from an object\n * @param obj Object\n * @param key Key to remove\n */\nexport function deleteProps(obj: Record<string, any>, propOrProps: string | string[]): Record<string, any> {\n  const props = typeof propOrProps === 'string'\n    ? [propOrProps]\n    : propOrProps\n\n  return Object\n    .keys(obj)\n    .reduce((newObj: Record<string, any>, prop) => {\n      if (!props.includes(prop)) {\n        newObj[prop] = obj[prop]\n      }\n\n      return newObj\n    }, {})\n}\n","import { MarkType, NodeType } from 'prosemirror-model'\n\nimport { getMarkType } from '../helpers/getMarkType'\nimport { getNodeType } from '../helpers/getNodeType'\nimport { getSchemaTypeNameByName } from '../helpers/getSchemaTypeNameByName'\nimport { RawCommands } from '../types'\nimport { deleteProps } from '../utilities/deleteProps'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    resetAttributes: {\n      /**\n       * Resets some node attributes to the default value.\n       */\n      resetAttributes: (typeOrName: string | NodeType | MarkType, attributes: string | string[]) => ReturnType,\n    }\n  }\n}\n\nexport const resetAttributes: RawCommands['resetAttributes'] = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\n  let nodeType: NodeType | null = null\n  let markType: MarkType | null = null\n\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string'\n      ? typeOrName\n      : typeOrName.name,\n    state.schema,\n  )\n\n  if (!schemaType) {\n    return false\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName as NodeType, state.schema)\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName as MarkType, state.schema)\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes))\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)))\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return true\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    scrollIntoView: {\n      /**\n       * Scroll the selection into view.\n       */\n      scrollIntoView: () => ReturnType,\n    }\n  }\n}\n\nexport const scrollIntoView: RawCommands['scrollIntoView'] = () => ({ tr, dispatch }) => {\n  if (dispatch) {\n    tr.scrollIntoView()\n  }\n\n  return true\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectAll: {\n      /**\n       * Select the whole document.\n       */\n      selectAll: () => ReturnType,\n    }\n  }\n}\n\nexport const selectAll: RawCommands['selectAll'] = () => ({ tr, commands }) => {\n  return commands.setTextSelection({\n    from: 0,\n    to: tr.doc.content.size,\n  })\n}\n","import { selectNodeBackward as originalSelectNodeBackward } from 'prosemirror-commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectNodeBackward: {\n      /**\n       * Select a node backward.\n       */\n      selectNodeBackward: () => ReturnType,\n    }\n  }\n}\n\nexport const selectNodeBackward: RawCommands['selectNodeBackward'] = () => ({ state, dispatch }) => {\n  return originalSelectNodeBackward(state, dispatch)\n}\n","import { selectNodeForward as originalSelectNodeForward } from 'prosemirror-commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectNodeForward: {\n      /**\n       * Select a node forward.\n       */\n      selectNodeForward: () => ReturnType,\n    }\n  }\n}\n\nexport const selectNodeForward: RawCommands['selectNodeForward'] = () => ({ state, dispatch }) => {\n  return originalSelectNodeForward(state, dispatch)\n}\n","import { selectParentNode as originalSelectParentNode } from 'prosemirror-commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectParentNode: {\n      /**\n       * Select the parent node.\n       */\n      selectParentNode: () => ReturnType,\n    }\n  }\n}\n\nexport const selectParentNode: RawCommands['selectParentNode'] = () => ({ state, dispatch }) => {\n  return originalSelectParentNode(state, dispatch)\n}\n","// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nimport { selectTextblockEnd as originalSelectTextblockEnd } from 'prosemirror-commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectTextblockEnd: {\n      /**\n       * Moves the cursor to the end of current text block.\n       */\n      selectTextblockEnd: () => ReturnType,\n    }\n  }\n}\n\nexport const selectTextblockEnd: RawCommands['selectTextblockEnd'] = () => ({ state, dispatch }) => {\n  return originalSelectTextblockEnd(state, dispatch)\n}\n","// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nimport { selectTextblockStart as originalSelectTextblockStart } from 'prosemirror-commands'\n\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectTextblockStart: {\n      /**\n       * Moves the cursor to the start of current text block.\n       */\n      selectTextblockStart: () => ReturnType,\n    }\n  }\n}\n\nexport const selectTextblockStart: RawCommands['selectTextblockStart'] = () => ({ state, dispatch }) => {\n  return originalSelectTextblockStart(state, dispatch)\n}\n","import { Node as ProseMirrorNode, ParseOptions, Schema } from 'prosemirror-model'\n\nimport { Content } from '../types'\nimport { createNodeFromContent } from './createNodeFromContent'\n\nexport function createDocument(\n  content: Content,\n  schema: Schema,\n  parseOptions: ParseOptions = {},\n): ProseMirrorNode {\n  return createNodeFromContent(content, schema, { slice: false, parseOptions }) as ProseMirrorNode\n}\n","import { ParseOptions } from 'prosemirror-model'\n\nimport { createDocument } from '../helpers/createDocument'\nimport { Content, RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setContent: {\n      /**\n       * Replace the whole document with new content.\n       */\n      setContent: (\n        content: Content,\n        emitUpdate?: boolean,\n        parseOptions?: ParseOptions,\n      ) => ReturnType,\n    }\n  }\n}\n\nexport const setContent: RawCommands['setContent'] = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {\n  const { doc } = tr\n  const document = createDocument(content, editor.schema, parseOptions)\n\n  if (dispatch) {\n    tr.replaceWith(0, doc.content.size, document)\n      .setMeta('preventUpdate', !emitUpdate)\n  }\n\n  return true\n}\n","import { Mark, MarkType } from 'prosemirror-model'\nimport { EditorState } from 'prosemirror-state'\n\nimport { getMarkType } from './getMarkType'\n\nexport function getMarkAttributes(state: EditorState, typeOrName: string | MarkType): Record<string, any> {\n  const type = getMarkType(typeOrName, state.schema)\n  const { from, to, empty } = state.selection\n  const marks: Mark[] = []\n\n  if (empty) {\n    if (state.storedMarks) {\n      marks.push(...state.storedMarks)\n    }\n\n    marks.push(...state.selection.$head.marks())\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks.push(...node.marks)\n    })\n  }\n\n  const mark = marks.find(markItem => markItem.type.name === type.name)\n\n  if (!mark) {\n    return {}\n  }\n\n  return { ...mark.attrs }\n}\n","import { MarkType } from 'prosemirror-model'\n\nimport { getMarkAttributes } from '../helpers/getMarkAttributes'\nimport { getMarkType } from '../helpers/getMarkType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setMark: {\n      /**\n       * Add a mark with new attributes.\n       */\n      setMark: (typeOrName: string | MarkType, attributes?: Record<string, any>) => ReturnType,\n    }\n  }\n}\n\nexport const setMark: RawCommands['setMark'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const { selection } = tr\n  const { empty, ranges } = selection\n  const type = getMarkType(typeOrName, state.schema)\n\n  if (dispatch) {\n    if (empty) {\n      const oldAttributes = getMarkAttributes(state, type)\n\n      tr.addStoredMark(type.create({\n        ...oldAttributes,\n        ...attributes,\n      }))\n    } else {\n      ranges.forEach(range => {\n        const from = range.$from.pos\n        const to = range.$to.pos\n\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          const trimmedFrom = Math.max(pos, from)\n          const trimmedTo = Math.min(pos + node.nodeSize, to)\n          const someHasMark = node.marks.find(mark => mark.type === type)\n\n          // if there is already a mark of this type\n          // we know that we have to merge its attributes\n          // otherwise we add a fresh new mark\n          if (someHasMark) {\n            node.marks.forEach(mark => {\n              if (type === mark.type) {\n                tr.addMark(trimmedFrom, trimmedTo, type.create({\n                  ...mark.attrs,\n                  ...attributes,\n                }))\n              }\n            })\n          } else {\n            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes))\n          }\n        })\n      })\n    }\n  }\n\n  return true\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setMeta: {\n      /**\n       * Store a metadata property in the current transaction.\n       */\n      setMeta: (key: string, value: any) => ReturnType,\n    }\n  }\n}\n\nexport const setMeta: RawCommands['setMeta'] = (key, value) => ({ tr }) => {\n  tr.setMeta(key, value)\n\n  return true\n}\n","import { setBlockType } from 'prosemirror-commands'\nimport { NodeType } from 'prosemirror-model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setNode: {\n      /**\n       * Replace a given range with a node.\n       */\n      setNode: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType,\n    }\n  }\n}\n\nexport const setNode: RawCommands['setNode'] = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  // TODO: use a fallback like insertContent?\n  if (!type.isTextblock) {\n    console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.')\n\n    return false\n  }\n\n  return chain()\n    // try to convert node to default node if needed\n    .command(({ commands }) => {\n      const canSetBlock = setBlockType(type, attributes)(state)\n\n      if (canSetBlock) {\n        return true\n      }\n\n      return commands.clearNodes()\n    })\n    .command(({ state: updatedState }) => {\n      return setBlockType(type, attributes)(updatedState, dispatch)\n    })\n    .run()\n}\n","import { NodeSelection, Selection } from 'prosemirror-state'\n\nimport { RawCommands } from '../types'\nimport { minMax } from '../utilities/minMax'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setNodeSelection: {\n      /**\n       * Creates a NodeSelection.\n       */\n      setNodeSelection: (position: number) => ReturnType,\n    }\n  }\n}\n\nexport const setNodeSelection: RawCommands['setNodeSelection'] = position => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr\n    const minPos = Selection.atStart(doc).from\n    const maxPos = Selection.atEnd(doc).to\n    const resolvedPos = minMax(position, minPos, maxPos)\n    const selection = NodeSelection.create(doc, resolvedPos)\n\n    tr.setSelection(selection)\n  }\n\n  return true\n}\n","import { TextSelection } from 'prosemirror-state'\n\nimport { Range, RawCommands } from '../types'\nimport { minMax } from '../utilities/minMax'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setTextSelection: {\n      /**\n       * Creates a TextSelection.\n       */\n      setTextSelection: (position: number | Range) => ReturnType,\n    }\n  }\n}\n\nexport const setTextSelection: RawCommands['setTextSelection'] = position => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr\n    const { from, to } = typeof position === 'number'\n      ? { from: position, to: position }\n      : position\n    const minPos = TextSelection.atStart(doc).from\n    const maxPos = TextSelection.atEnd(doc).to\n    const resolvedFrom = minMax(from, minPos, maxPos)\n    const resolvedEnd = minMax(to, minPos, maxPos)\n    const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd)\n\n    tr.setSelection(selection)\n  }\n\n  return true\n}\n","import { NodeType } from 'prosemirror-model'\nimport { sinkListItem as originalSinkListItem } from 'prosemirror-schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    sinkListItem: {\n      /**\n       * Sink the list item down into an inner list.\n       */\n      sinkListItem: (typeOrName: string | NodeType) => ReturnType,\n    }\n  }\n}\n\nexport const sinkListItem: RawCommands['sinkListItem'] = typeOrName => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalSinkListItem(type)(state, dispatch)\n}\n","import { ExtensionAttribute } from '../types'\n\nexport function getSplittedAttributes(\n  extensionAttributes: ExtensionAttribute[],\n  typeName: string,\n  attributes: Record<string, any>,\n): Record<string, any> {\n  return Object.fromEntries(Object\n    .entries(attributes)\n    .filter(([name]) => {\n      const extensionAttribute = extensionAttributes.find(item => {\n        return item.type === typeName && item.name === name\n      })\n\n      if (!extensionAttribute) {\n        return false\n      }\n\n      return extensionAttribute.attribute.keepOnSplit\n    }))\n}\n","import { ContentMatch } from 'prosemirror-model'\nimport { EditorState, NodeSelection, TextSelection } from 'prosemirror-state'\nimport { canSplit } from 'prosemirror-transform'\n\nimport { getSplittedAttributes } from '../helpers/getSplittedAttributes'\nimport { RawCommands } from '../types'\n\nfunction defaultBlockAt(match: ContentMatch) {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const { type } = match.edge(i)\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type\n    }\n  }\n  return null\n}\n\nfunction ensureMarks(state: EditorState, splittableMarks?: string[]) {\n  const marks = state.storedMarks\n    || (state.selection.$to.parentOffset && state.selection.$from.marks())\n\n  if (marks) {\n    const filteredMarks = marks.filter(mark => splittableMarks?.includes(mark.type.name))\n\n    state.tr.ensureMarks(filteredMarks)\n  }\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    splitBlock: {\n      /**\n       * Forks a new node from an existing node.\n       */\n      splitBlock: (options?: { keepMarks?: boolean }) => ReturnType,\n    }\n  }\n}\n\nexport const splitBlock: RawCommands['splitBlock'] = ({ keepMarks = true } = {}) => ({\n  tr,\n  state,\n  dispatch,\n  editor,\n}) => {\n  const { selection, doc } = tr\n  const { $from, $to } = selection\n  const extensionAttributes = editor.extensionManager.attributes\n  const newAttributes = getSplittedAttributes(\n    extensionAttributes,\n    $from.node().type.name,\n    $from.node().attrs,\n  )\n\n  if (selection instanceof NodeSelection && selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n      return false\n    }\n\n    if (dispatch) {\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks)\n      }\n\n      tr.split($from.pos).scrollIntoView()\n    }\n\n    return true\n  }\n\n  if (!$from.parent.isBlock) {\n    return false\n  }\n\n  if (dispatch) {\n    const atEnd = $to.parentOffset === $to.parent.content.size\n\n    if (selection instanceof TextSelection) {\n      tr.deleteSelection()\n    }\n\n    const deflt = $from.depth === 0\n      ? undefined\n      : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n\n    let types = atEnd && deflt\n      ? [{\n        type: deflt,\n        attrs: newAttributes,\n      }]\n      : undefined\n\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n\n    if (\n      !types\n      && !can\n      && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)\n    ) {\n      can = true\n      types = deflt\n        ? [{\n          type: deflt,\n          attrs: newAttributes,\n        }]\n        : undefined\n    }\n\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types)\n\n      if (\n        deflt\n        && !atEnd\n        && !$from.parentOffset\n        && $from.parent.type !== deflt\n      ) {\n        const first = tr.mapping.map($from.before())\n        const $first = tr.doc.resolve(first)\n\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt)\n        }\n      }\n    }\n\n    if (keepMarks) {\n      ensureMarks(state, editor.extensionManager.splittableMarks)\n    }\n\n    tr.scrollIntoView()\n  }\n\n  return true\n}\n","import {\n  Fragment,\n  Node as ProseMirrorNode,\n  NodeType,\n  Slice,\n} from 'prosemirror-model'\nimport { TextSelection } from 'prosemirror-state'\nimport { canSplit } from 'prosemirror-transform'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { getSplittedAttributes } from '../helpers/getSplittedAttributes'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    splitListItem: {\n      /**\n       * Splits one list item into two list items.\n       */\n      splitListItem: (typeOrName: string | NodeType) => ReturnType,\n    }\n  }\n}\n\nexport const splitListItem: RawCommands['splitListItem'] = typeOrName => ({\n  tr, state, dispatch, editor,\n}) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const { $from, $to } = state.selection\n\n  // @ts-ignore\n  // eslint-disable-next-line\n  const node: ProseMirrorNode = state.selection.node\n\n  if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\n    return false\n  }\n\n  const grandParent = $from.node(-1)\n\n  if (grandParent.type !== type) {\n    return false\n  }\n\n  const extensionAttributes = editor.extensionManager.attributes\n\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    // In an empty block. If this is a nested list, the wrapping\n    // list item should be split. Otherwise, bail out and let next\n    // command handle lifting.\n    if (\n      $from.depth === 2\n      || $from.node(-3).type !== type\n      || $from.index(-2) !== $from.node(-2).childCount - 1\n    ) {\n      return false\n    }\n\n    if (dispatch) {\n      let wrap = Fragment.empty\n      // eslint-disable-next-line\n      const depthBefore = $from.index(-1)\n        ? 1\n        : $from.index(-2)\n          ? 2\n          : 3\n\n      // Build a fragment containing empty versions of the structure\n      // from the outer list item to the parent node of the cursor\n      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n        wrap = Fragment.from($from.node(d).copy(wrap))\n      }\n\n      // eslint-disable-next-line\n      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount\n        ? 1\n        : $from.indexAfter(-2) < $from.node(-3).childCount\n          ? 2\n          : 3\n\n      // Add a second list item with an empty default start node\n      const newNextTypeAttributes = getSplittedAttributes(\n        extensionAttributes,\n        $from.node().type.name,\n        $from.node().attrs,\n      )\n      const nextType = type.contentMatch.defaultType?.createAndFill(newNextTypeAttributes) || undefined\n\n      wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined))\n\n      const start = $from.before($from.depth - (depthBefore - 1))\n\n      tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0))\n\n      let sel = -1\n\n      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n        if (sel > -1) {\n          return false\n        }\n\n        if (n.isTextblock && n.content.size === 0) {\n          sel = pos + 1\n        }\n      })\n\n      if (sel > -1) {\n        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)))\n      }\n\n      tr.scrollIntoView()\n    }\n\n    return true\n  }\n\n  const nextType = $to.pos === $from.end()\n    ? grandParent.contentMatchAt(0).defaultType\n    : null\n\n  const newTypeAttributes = getSplittedAttributes(\n    extensionAttributes,\n    grandParent.type.name,\n    grandParent.attrs,\n  )\n  const newNextTypeAttributes = getSplittedAttributes(\n    extensionAttributes,\n    $from.node().type.name,\n    $from.node().attrs,\n  )\n\n  tr.delete($from.pos, $to.pos)\n\n  const types = nextType\n    ? [{ type, attrs: newTypeAttributes }, { type: nextType, attrs: newNextTypeAttributes }]\n    : [{ type, attrs: newTypeAttributes }]\n\n  if (!canSplit(tr.doc, $from.pos, 2)) {\n    return false\n  }\n\n  if (dispatch) {\n    tr.split($from.pos, 2, types).scrollIntoView()\n  }\n\n  return true\n}\n","import { Node as ProseMirrorNode, ResolvedPos } from 'prosemirror-model'\n\nimport { Predicate } from '../types'\n\nexport function findParentNodeClosestToPos($pos: ResolvedPos, predicate: Predicate): ({\n  pos: number,\n  start: number,\n  depth: number,\n  node: ProseMirrorNode,\n} | undefined) {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i)\n\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node,\n      }\n    }\n  }\n}\n","import { Selection } from 'prosemirror-state'\n\nimport { Predicate } from '../types'\nimport { findParentNodeClosestToPos } from './findParentNodeClosestToPos'\n\nexport function findParentNode(predicate: Predicate) {\n  return (selection: Selection) => findParentNodeClosestToPos(selection.$from, predicate)\n}\n","import { NodeConfig } from '..'\nimport { getExtensionField } from '../helpers/getExtensionField'\nimport { Extensions } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\nimport { splitExtensions } from './splitExtensions'\n\nexport function isList(name: string, extensions: Extensions): boolean {\n  const { nodeExtensions } = splitExtensions(extensions)\n  const extension = nodeExtensions.find(item => item.name === name)\n\n  if (!extension) {\n    return false\n  }\n\n  const context = {\n    name: extension.name,\n    options: extension.options,\n    storage: extension.storage,\n  }\n  const group = callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context))\n\n  if (typeof group !== 'string') {\n    return false\n  }\n\n  return group.split(' ').includes('list')\n}\n","import { NodeType } from 'prosemirror-model'\nimport { Transaction } from 'prosemirror-state'\nimport { canJoin } from 'prosemirror-transform'\n\nimport { findParentNode } from '../helpers/findParentNode'\nimport { getNodeType } from '../helpers/getNodeType'\nimport { isList } from '../helpers/isList'\nimport { RawCommands } from '../types'\n\nconst joinListBackwards = (tr: Transaction, listType: NodeType): boolean => {\n  const list = findParentNode(node => node.type === listType)(tr.selection)\n\n  if (!list) {\n    return true\n  }\n\n  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth)\n\n  if (before === undefined) {\n    return true\n  }\n\n  const nodeBefore = tr.doc.nodeAt(before)\n  const canJoinBackwards = list.node.type === nodeBefore?.type\n    && canJoin(tr.doc, list.pos)\n\n  if (!canJoinBackwards) {\n    return true\n  }\n\n  tr.join(list.pos)\n\n  return true\n}\n\nconst joinListForwards = (tr: Transaction, listType: NodeType): boolean => {\n  const list = findParentNode(node => node.type === listType)(tr.selection)\n\n  if (!list) {\n    return true\n  }\n\n  const after = tr.doc.resolve(list.start).after(list.depth)\n\n  if (after === undefined) {\n    return true\n  }\n\n  const nodeAfter = tr.doc.nodeAt(after)\n  const canJoinForwards = list.node.type === nodeAfter?.type\n    && canJoin(tr.doc, after)\n\n  if (!canJoinForwards) {\n    return true\n  }\n\n  tr.join(after)\n\n  return true\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleList: {\n      /**\n       * Toggle between different list types.\n       */\n      toggleList: (listTypeOrName: string | NodeType, itemTypeOrName: string | NodeType) => ReturnType,\n    }\n  }\n}\n\nexport const toggleList: RawCommands['toggleList'] = (listTypeOrName, itemTypeOrName) => ({\n  editor, tr, state, dispatch, chain, commands, can,\n}) => {\n  const { extensions } = editor.extensionManager\n  const listType = getNodeType(listTypeOrName, state.schema)\n  const itemType = getNodeType(itemTypeOrName, state.schema)\n  const { selection } = state\n  const { $from, $to } = selection\n  const range = $from.blockRange($to)\n\n  if (!range) {\n    return false\n  }\n\n  const parentList = findParentNode(node => isList(node.type.name, extensions))(selection)\n\n  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n    // remove list\n    if (parentList.node.type === listType) {\n      return commands.liftListItem(itemType)\n    }\n\n    // change list type\n    if (\n      isList(parentList.node.type.name, extensions)\n      && listType.validContent(parentList.node.content)\n      && dispatch\n    ) {\n      return chain()\n        .command(() => {\n          tr.setNodeMarkup(parentList.pos, listType)\n\n          return true\n        })\n        .command(() => joinListBackwards(tr, listType))\n        .command(() => joinListForwards(tr, listType))\n        .run()\n    }\n  }\n\n  return chain()\n    // try to convert node to default node if needed\n    .command(() => {\n      const canWrapInList = can().wrapInList(listType)\n\n      if (canWrapInList) {\n        return true\n      }\n\n      return commands.clearNodes()\n    })\n    .wrapInList(listType)\n    .command(() => joinListBackwards(tr, listType))\n    .command(() => joinListForwards(tr, listType))\n    .run()\n}\n","import { MarkType } from 'prosemirror-model'\nimport { EditorState } from 'prosemirror-state'\n\nimport { MarkRange } from '../types'\nimport { objectIncludes } from '../utilities/objectIncludes'\nimport { getMarkType } from './getMarkType'\n\nexport function isMarkActive(\n  state: EditorState,\n  typeOrName: MarkType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { empty, ranges } = state.selection\n  const type = typeOrName\n    ? getMarkType(typeOrName, state.schema)\n    : null\n\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks())\n      .filter(mark => {\n        if (!type) {\n          return true\n        }\n\n        return type.name === mark.type.name\n      })\n      .find(mark => objectIncludes(mark.attrs, attributes, { strict: false }))\n  }\n\n  let selectionRange = 0\n  const markRanges: MarkRange[] = []\n\n  ranges.forEach(({ $from, $to }) => {\n    const from = $from.pos\n    const to = $to.pos\n\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (!node.isText && !node.marks.length) {\n        return\n      }\n\n      const relativeFrom = Math.max(from, pos)\n      const relativeTo = Math.min(to, pos + node.nodeSize)\n      const range = relativeTo - relativeFrom\n\n      selectionRange += range\n\n      markRanges.push(...node.marks.map(mark => ({\n        mark,\n        from: relativeFrom,\n        to: relativeTo,\n      })))\n    })\n  })\n\n  if (selectionRange === 0) {\n    return false\n  }\n\n  // calculate range of matched mark\n  const matchedRange = markRanges\n    .filter(markRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === markRange.mark.type.name\n    })\n    .filter(markRange => objectIncludes(markRange.mark.attrs, attributes, { strict: false }))\n    .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0)\n\n  // calculate range of marks that excludes the searched mark\n  // for example `code` doesn’t allow any other marks\n  const excludedRange = markRanges\n    .filter(markRange => {\n      if (!type) {\n        return true\n      }\n\n      return markRange.mark.type !== type\n        && markRange.mark.type.excludes(type)\n    })\n    .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0)\n\n  // we only include the result of `excludedRange`\n  // if there is a match at all\n  const range = matchedRange > 0\n    ? matchedRange + excludedRange\n    : matchedRange\n\n  return range >= selectionRange\n}\n","import { MarkType } from 'prosemirror-model'\n\nimport { getMarkType } from '../helpers/getMarkType'\nimport { isMarkActive } from '../helpers/isMarkActive'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleMark: {\n      /**\n       * Toggle a mark on and off.\n       */\n      toggleMark: (\n        typeOrName: string | MarkType,\n        attributes?: Record<string, any>,\n        options?: {\n          /**\n           * Removes the mark even across the current selection. Defaults to `false`.\n           */\n          extendEmptyMarkRange?: boolean,\n        },\n      ) => ReturnType,\n    }\n  }\n}\n\nexport const toggleMark: RawCommands['toggleMark'] = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {\n  const { extendEmptyMarkRange = false } = options\n  const type = getMarkType(typeOrName, state.schema)\n  const isActive = isMarkActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.unsetMark(type, { extendEmptyMarkRange })\n  }\n\n  return commands.setMark(type, attributes)\n}\n","import { NodeType } from 'prosemirror-model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { isNodeActive } from '../helpers/isNodeActive'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleNode: {\n      /**\n       * Toggle a node with another node.\n       */\n      toggleNode: (typeOrName: string | NodeType, toggleTypeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType,\n    }\n  }\n}\n\nexport const toggleNode: RawCommands['toggleNode'] = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const toggleType = getNodeType(toggleTypeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.setNode(toggleType)\n  }\n\n  return commands.setNode(type, attributes)\n}\n","import { NodeType } from 'prosemirror-model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { isNodeActive } from '../helpers/isNodeActive'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleWrap: {\n      /**\n       * Wraps nodes in another node, or removes an existing wrap.\n       */\n      toggleWrap: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType,\n    }\n  }\n}\n\nexport const toggleWrap: RawCommands['toggleWrap'] = (typeOrName, attributes = {}) => ({ state, commands }) => {\n  const type = getNodeType(typeOrName, state.schema)\n  const isActive = isNodeActive(state, type, attributes)\n\n  if (isActive) {\n    return commands.lift(type)\n  }\n\n  return commands.wrapIn(type, attributes)\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    undoInputRule: {\n      /**\n       * Undo an input rule.\n       */\n      undoInputRule: () => ReturnType,\n    }\n  }\n}\n\nexport const undoInputRule: RawCommands['undoInputRule'] = () => ({ state, dispatch }) => {\n  const plugins = state.plugins\n\n  for (let i = 0; i < plugins.length; i += 1) {\n    const plugin = plugins[i]\n    let undoable\n\n    // @ts-ignore\n    // eslint-disable-next-line\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        const tr = state.tr\n        const toUndo = undoable.transform\n\n        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]))\n        }\n\n        if (undoable.text) {\n          const marks = tr.doc.resolve(undoable.from).marks()\n\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks))\n        } else {\n          tr.delete(undoable.from, undoable.to)\n        }\n      }\n\n      return true\n    }\n  }\n\n  return false\n}\n","import { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    unsetAllMarks: {\n      /**\n       * Remove all marks in the current selection.\n       */\n      unsetAllMarks: () => ReturnType,\n    }\n  }\n}\n\nexport const unsetAllMarks: RawCommands['unsetAllMarks'] = () => ({ tr, dispatch }) => {\n  const { selection } = tr\n  const { empty, ranges } = selection\n\n  if (empty) {\n    return true\n  }\n\n  if (dispatch) {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos)\n    })\n  }\n\n  return true\n}\n","import { MarkType } from 'prosemirror-model'\n\nimport { getMarkRange } from '../helpers/getMarkRange'\nimport { getMarkType } from '../helpers/getMarkType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    unsetMark: {\n      /**\n       * Remove all marks in the current selection.\n       */\n      unsetMark: (\n        typeOrName: string | MarkType,\n        options?: {\n          /**\n           * Removes the mark even across the current selection. Defaults to `false`.\n           */\n          extendEmptyMarkRange?: boolean,\n        },\n      ) => ReturnType,\n    }\n  }\n}\n\nexport const unsetMark: RawCommands['unsetMark'] = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {\n  const { extendEmptyMarkRange = false } = options\n  const { selection } = tr\n  const type = getMarkType(typeOrName, state.schema)\n  const { $from, empty, ranges } = selection\n\n  if (!dispatch) {\n    return true\n  }\n\n  if (empty && extendEmptyMarkRange) {\n    let { from, to } = selection\n    const attrs = $from.marks().find(mark => mark.type === type)?.attrs\n    const range = getMarkRange($from, type, attrs)\n\n    if (range) {\n      from = range.from\n      to = range.to\n    }\n\n    tr.removeMark(from, to, type)\n  } else {\n    ranges.forEach(range => {\n      tr.removeMark(range.$from.pos, range.$to.pos, type)\n    })\n  }\n\n  tr.removeStoredMark(type)\n\n  return true\n}\n","import { MarkType, NodeType } from 'prosemirror-model'\n\nimport { getMarkType } from '../helpers/getMarkType'\nimport { getNodeType } from '../helpers/getNodeType'\nimport { getSchemaTypeNameByName } from '../helpers/getSchemaTypeNameByName'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    updateAttributes: {\n      /**\n       * Update attributes of a node or mark.\n       */\n      updateAttributes: (typeOrName: string | NodeType | MarkType, attributes: Record<string, any>) => ReturnType,\n    }\n  }\n}\n\nexport const updateAttributes: RawCommands['updateAttributes'] = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  let nodeType: NodeType | null = null\n  let markType: MarkType | null = null\n\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string'\n      ? typeOrName\n      : typeOrName.name,\n    state.schema,\n  )\n\n  if (!schemaType) {\n    return false\n  }\n\n  if (schemaType === 'node') {\n    nodeType = getNodeType(typeOrName as NodeType, state.schema)\n  }\n\n  if (schemaType === 'mark') {\n    markType = getMarkType(typeOrName as MarkType, state.schema)\n  }\n\n  if (dispatch) {\n    tr.selection.ranges.forEach(range => {\n      const from = range.$from.pos\n      const to = range.$to.pos\n\n      state.doc.nodesBetween(from, to, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, undefined, {\n            ...node.attrs,\n            ...attributes,\n          })\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              const trimmedFrom = Math.max(pos, from)\n              const trimmedTo = Math.min(pos + node.nodeSize, to)\n\n              tr.addMark(trimmedFrom, trimmedTo, markType.create({\n                ...mark.attrs,\n                ...attributes,\n              }))\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return true\n}\n","import { wrapIn as originalWrapIn } from 'prosemirror-commands'\nimport { NodeType } from 'prosemirror-model'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    wrapIn: {\n      /**\n       * Wraps nodes in another node.\n       */\n      wrapIn: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType,\n    }\n  }\n}\n\nexport const wrapIn: RawCommands['wrapIn'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalWrapIn(type, attributes)(state, dispatch)\n}\n","import { NodeType } from 'prosemirror-model'\nimport { wrapInList as originalWrapInList } from 'prosemirror-schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType'\nimport { RawCommands } from '../types'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    wrapInList: {\n      /**\n       * Wrap a node in a list.\n       */\n      wrapInList: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType,\n    }\n  }\n}\n\nexport const wrapInList: RawCommands['wrapInList'] = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema)\n\n  return originalWrapInList(type, attributes)(state, dispatch)\n}\n","import * as commands from '../commands'\nimport { Extension } from '../Extension'\n\nexport * from '../commands'\n\nexport const Commands = Extension.create({\n  name: 'commands',\n\n  addCommands() {\n    return {\n      ...commands,\n    }\n  },\n})\n","import { Plugin, PluginKey } from 'prosemirror-state'\n\nimport { Extension } from '../Extension'\n\nexport const Editable = Extension.create({\n  name: 'editable',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('editable'),\n        props: {\n          editable: () => this.editor.options.editable,\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from 'prosemirror-state'\n\nimport { Extension } from '../Extension'\n\nexport const FocusEvents = Extension.create({\n  name: 'focusEvents',\n\n  addProseMirrorPlugins() {\n    const { editor } = this\n\n    return [\n      new Plugin({\n        key: new PluginKey('focusEvents'),\n        props: {\n          handleDOMEvents: {\n            focus: (view, event: Event) => {\n              editor.isFocused = true\n\n              const transaction = editor.state.tr\n                .setMeta('focus', { event })\n                .setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n            blur: (view, event: Event) => {\n              editor.isFocused = false\n\n              const transaction = editor.state.tr\n                .setMeta('blur', { event })\n                .setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey, Selection } from 'prosemirror-state'\n\nimport { CommandManager } from '../CommandManager'\nimport { Extension } from '../Extension'\nimport { createChainableState } from '../helpers/createChainableState'\nimport { isiOS } from '../utilities/isiOS'\nimport { isMacOS } from '../utilities/isMacOS'\n\nexport const Keymap = Extension.create({\n  name: 'keymap',\n\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(({ commands }) => [\n      () => commands.undoInputRule(),\n      // maybe convert first text block node to default node\n      () => commands.command(({ tr }) => {\n        const { selection, doc } = tr\n        const { empty, $anchor } = selection\n        const { pos, parent } = $anchor\n        const isAtStart = Selection.atStart(doc).from === pos\n\n        if (\n          !empty\n          || !isAtStart\n          || !parent.type.isTextblock\n          || parent.textContent.length\n        ) {\n          return false\n        }\n\n        return commands.clearNodes()\n      }),\n      () => commands.deleteSelection(),\n      () => commands.joinBackward(),\n      () => commands.selectNodeBackward(),\n    ])\n\n    const handleDelete = () => this.editor.commands.first(({ commands }) => [\n      () => commands.deleteSelection(),\n      () => commands.joinForward(),\n      () => commands.selectNodeForward(),\n    ])\n\n    const handleEnter = () => this.editor.commands.first(({ commands }) => [\n      () => commands.newlineInCode(),\n      () => commands.createParagraphNear(),\n      () => commands.liftEmptyBlock(),\n      () => commands.splitBlock(),\n    ])\n\n    const baseKeymap = {\n      Enter: handleEnter,\n      'Mod-Enter': () => this.editor.commands.exitCode(),\n      Backspace: handleBackspace,\n      'Mod-Backspace': handleBackspace,\n      'Shift-Backspace': handleBackspace,\n      Delete: handleDelete,\n      'Mod-Delete': handleDelete,\n      'Mod-a': () => this.editor.commands.selectAll(),\n    }\n\n    const pcKeymap = {\n      ...baseKeymap,\n    }\n\n    const macKeymap = {\n      ...baseKeymap,\n      'Ctrl-h': handleBackspace,\n      'Alt-Backspace': handleBackspace,\n      'Ctrl-d': handleDelete,\n      'Ctrl-Alt-Backspace': handleDelete,\n      'Alt-Delete': handleDelete,\n      'Alt-d': handleDelete,\n      'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\n      'Ctrl-e': () => this.editor.commands.selectTextblockEnd(),\n    }\n\n    if (isiOS() || isMacOS()) {\n      return macKeymap\n    }\n\n    return pcKeymap\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      // With this plugin we check if the whole document was selected and deleted.\n      // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n      // to a paragraph if necessary.\n      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\n      // with many other commands.\n      new Plugin({\n        key: new PluginKey('clearDocument'),\n        appendTransaction: (transactions, oldState, newState) => {\n          const docChanges = transactions.some(transaction => transaction.docChanged)\n            && !oldState.doc.eq(newState.doc)\n\n          if (!docChanges) {\n            return\n          }\n\n          const { empty, from, to } = oldState.selection\n          const allFrom = Selection.atStart(oldState.doc).from\n          const allEnd = Selection.atEnd(oldState.doc).to\n          const allWasSelected = from === allFrom && to === allEnd\n          const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, ' ', ' ').length === 0\n\n          if (empty || !allWasSelected || !isEmpty) {\n            return\n          }\n\n          const tr = newState.tr\n          const state = createChainableState({\n            state: newState,\n            transaction: tr,\n          })\n          const { commands } = new CommandManager({\n            editor: this.editor,\n            state,\n          })\n\n          commands.clearNodes()\n\n          if (!tr.steps.length) {\n            return\n          }\n\n          return tr\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from 'prosemirror-state'\n\nimport { Extension } from '../Extension'\n\nexport const Tabindex = Extension.create({\n  name: 'tabindex',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('tabindex'),\n        props: {\n          attributes: this.editor.isEditable ? { tabindex: '0' } : {},\n        },\n      }),\n    ]\n  },\n})\n","import { Node, NodeType } from 'prosemirror-model'\nimport { EditorState } from 'prosemirror-state'\n\nimport { getNodeType } from './getNodeType'\n\nexport function getNodeAttributes(state: EditorState, typeOrName: string | NodeType): Record<string, any> {\n  const type = getNodeType(typeOrName, state.schema)\n  const { from, to } = state.selection\n  const nodes: Node[] = []\n\n  state.doc.nodesBetween(from, to, node => {\n    nodes.push(node)\n  })\n\n  const node = nodes\n    .reverse()\n    .find(nodeItem => nodeItem.type.name === type.name)\n\n  if (!node) {\n    return {}\n  }\n\n  return { ...node.attrs }\n}\n","import { MarkType, NodeType } from 'prosemirror-model'\nimport { EditorState } from 'prosemirror-state'\n\nimport { getMarkAttributes } from './getMarkAttributes'\nimport { getNodeAttributes } from './getNodeAttributes'\nimport { getSchemaTypeNameByName } from './getSchemaTypeNameByName'\n\nexport function getAttributes(\n  state: EditorState,\n  typeOrName: string | NodeType | MarkType,\n): Record<string, any> {\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string'\n      ? typeOrName\n      : typeOrName.name,\n    state.schema,\n  )\n\n  if (schemaType === 'node') {\n    return getNodeAttributes(state, typeOrName as NodeType)\n  }\n\n  if (schemaType === 'mark') {\n    return getMarkAttributes(state, typeOrName as MarkType)\n  }\n\n  return {}\n}\n","import { DOMSerializer, Fragment, Schema } from 'prosemirror-model'\n\nexport function getHTMLFromFragment(fragment: Fragment, schema: Schema): string {\n  const documentFragment = DOMSerializer\n    .fromSchema(schema)\n    .serializeFragment(fragment)\n\n  const temporaryDocument = document.implementation.createHTMLDocument()\n  const container = temporaryDocument.createElement('div')\n\n  container.appendChild(documentFragment)\n\n  return container.innerHTML\n}\n","import { Node as ProseMirrorNode } from 'prosemirror-model'\n\nimport { TextSerializer } from '../types'\nimport { getTextBetween } from './getTextBetween'\n\nexport function getText(\n  node: ProseMirrorNode,\n  options?: {\n    blockSeparator?: string,\n    textSerializers?: Record<string, TextSerializer>,\n  },\n) {\n  const range = {\n    from: 0,\n    to: node.content.size,\n  }\n\n  return getTextBetween(node, range, options)\n}\n","import { EditorState } from 'prosemirror-state'\n\nimport { getSchemaTypeNameByName } from './getSchemaTypeNameByName'\nimport { isMarkActive } from './isMarkActive'\nimport { isNodeActive } from './isNodeActive'\n\nexport function isActive(state: EditorState, name: string | null, attributes: Record<string, any> = {}): boolean {\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes)\n  }\n\n  const schemaType = getSchemaTypeNameByName(name, state.schema)\n\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes)\n  }\n\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes)\n  }\n\n  return false\n}\n","import { Node as ProseMirrorNode } from 'prosemirror-model'\n\nexport function isNodeEmpty(node: ProseMirrorNode): boolean {\n  const defaultContent = node.type.createAndFill()?.toJSON()\n  const content = node.toJSON()\n\n  return JSON.stringify(defaultContent) === JSON.stringify(content)\n}\n","export const style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`\n","export function createStyleTag(style: string, nonce?: string): HTMLStyleElement {\n  const tipTapStyleTag = (<HTMLStyleElement>document.querySelector('style[data-tiptap-style]'))\n\n  if (tipTapStyleTag !== null) {\n    return tipTapStyleTag\n  }\n\n  const styleNode = document.createElement('style')\n\n  if (nonce) {\n    styleNode.setAttribute('nonce', nonce)\n  }\n\n  styleNode.setAttribute('data-tiptap-style', '')\n  styleNode.innerHTML = style\n  document.getElementsByTagName('head')[0].appendChild(styleNode)\n\n  return styleNode\n}\n","import { MarkType, NodeType, Schema } from 'prosemirror-model'\nimport {\n  EditorState,\n  Plugin,\n  PluginKey,\n  Transaction,\n} from 'prosemirror-state'\nimport { EditorView } from 'prosemirror-view'\n\nimport { CommandManager } from './CommandManager'\nimport { EventEmitter } from './EventEmitter'\nimport { ExtensionManager } from './ExtensionManager'\nimport * as extensions from './extensions'\nimport { createDocument } from './helpers/createDocument'\nimport { getAttributes } from './helpers/getAttributes'\nimport { getHTMLFromFragment } from './helpers/getHTMLFromFragment'\nimport { getText } from './helpers/getText'\nimport { getTextSerializersFromSchema } from './helpers/getTextSerializersFromSchema'\nimport { isActive } from './helpers/isActive'\nimport { isNodeEmpty } from './helpers/isNodeEmpty'\nimport { resolveFocusPosition } from './helpers/resolveFocusPosition'\nimport { style } from './style'\nimport {\n  CanCommands,\n  ChainedCommands,\n  EditorEvents,\n  EditorOptions,\n  JSONContent,\n  SingleCommands,\n  TextSerializer,\n} from './types'\nimport { createStyleTag } from './utilities/createStyleTag'\nimport { isFunction } from './utilities/isFunction'\n\nexport { extensions }\n\nexport interface HTMLElement {\n  editor?: Editor\n}\n\nexport class Editor extends EventEmitter<EditorEvents> {\n\n  private commandManager!: CommandManager\n\n  public extensionManager!: ExtensionManager\n\n  private css!: HTMLStyleElement\n\n  public schema!: Schema\n\n  public view!: EditorView\n\n  public isFocused = false\n\n  public extensionStorage: Record<string, any> = {}\n\n  public options: EditorOptions = {\n    element: document.createElement('div'),\n    content: '',\n    injectCSS: true,\n    injectNonce: undefined,\n    extensions: [],\n    autofocus: false,\n    editable: true,\n    editorProps: {},\n    parseOptions: {},\n    enableInputRules: true,\n    enablePasteRules: true,\n    enableCoreExtensions: true,\n    onBeforeCreate: () => null,\n    onCreate: () => null,\n    onUpdate: () => null,\n    onSelectionUpdate: () => null,\n    onTransaction: () => null,\n    onFocus: () => null,\n    onBlur: () => null,\n    onDestroy: () => null,\n  }\n\n  constructor(options: Partial<EditorOptions> = {}) {\n    super()\n    this.setOptions(options)\n    this.createExtensionManager()\n    this.createCommandManager()\n    this.createSchema()\n    this.on('beforeCreate', this.options.onBeforeCreate)\n    this.emit('beforeCreate', { editor: this })\n    this.createView()\n    this.injectCSS()\n    this.on('create', this.options.onCreate)\n    this.on('update', this.options.onUpdate)\n    this.on('selectionUpdate', this.options.onSelectionUpdate)\n    this.on('transaction', this.options.onTransaction)\n    this.on('focus', this.options.onFocus)\n    this.on('blur', this.options.onBlur)\n    this.on('destroy', this.options.onDestroy)\n\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return\n      }\n\n      this.commands.focus(this.options.autofocus)\n      this.emit('create', { editor: this })\n    }, 0)\n  }\n\n  /**\n   * Returns the editor storage.\n   */\n  public get storage(): Record<string, any> {\n    return this.extensionStorage\n  }\n\n  /**\n   * An object of all registered commands.\n   */\n  public get commands(): SingleCommands {\n    return this.commandManager.commands\n  }\n\n  /**\n   * Create a command chain to call multiple commands at once.\n   */\n  public chain(): ChainedCommands {\n    return this.commandManager.chain()\n  }\n\n  /**\n   * Check if a command or a command chain can be executed. Without executing it.\n   */\n  public can(): CanCommands {\n    return this.commandManager.can()\n  }\n\n  /**\n   * Inject CSS styles.\n   */\n  private injectCSS(): void {\n    if (this.options.injectCSS && document) {\n      this.css = createStyleTag(style, this.options.injectNonce)\n    }\n  }\n\n  /**\n   * Update editor options.\n   *\n   * @param options A list of options\n   */\n  public setOptions(options: Partial<EditorOptions> = {}): void {\n    this.options = {\n      ...this.options,\n      ...options,\n    }\n\n    if (!this.view || !this.state || this.isDestroyed) {\n      return\n    }\n\n    if (this.options.editorProps) {\n      this.view.setProps(this.options.editorProps)\n    }\n\n    this.view.updateState(this.state)\n  }\n\n  /**\n   * Update editable state of the editor.\n   */\n  public setEditable(editable: boolean): void {\n    this.setOptions({ editable })\n  }\n\n  /**\n   * Returns whether the editor is editable.\n   */\n  public get isEditable(): boolean {\n    // since plugins are applied after creating the view\n    // `editable` is always `true` for one tick.\n    // that’s why we also have to check for `options.editable`\n    return this.options.editable\n      && this.view\n      && this.view.editable\n  }\n\n  /**\n   * Returns the editor state.\n   */\n  public get state(): EditorState {\n    return this.view.state\n  }\n\n  /**\n   * Register a ProseMirror plugin.\n   *\n   * @param plugin A ProseMirror plugin\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\n   */\n  public registerPlugin(plugin: Plugin, handlePlugins?: (newPlugin: Plugin, plugins: Plugin[]) => Plugin[]): void {\n    const plugins = isFunction(handlePlugins)\n      ? handlePlugins(plugin, [...this.state.plugins])\n      : [...this.state.plugins, plugin]\n\n    const state = this.state.reconfigure({ plugins })\n\n    this.view.updateState(state)\n  }\n\n  /**\n   * Unregister a ProseMirror plugin.\n   *\n   * @param nameOrPluginKey The plugins name\n   */\n  public unregisterPlugin(nameOrPluginKey: string | PluginKey): void {\n    if (this.isDestroyed) {\n      return\n    }\n\n    const name = typeof nameOrPluginKey === 'string'\n      ? `${nameOrPluginKey}$`\n      // @ts-ignore\n      : nameOrPluginKey.key\n\n    const state = this.state.reconfigure({\n      // @ts-ignore\n      plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name)),\n    })\n\n    this.view.updateState(state)\n  }\n\n  /**\n   * Creates an extension manager.\n   */\n  private createExtensionManager(): void {\n    const coreExtensions = this.options.enableCoreExtensions\n      ? Object.values(extensions)\n      : []\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n      return ['extension', 'node', 'mark'].includes(extension?.type)\n    })\n\n    this.extensionManager = new ExtensionManager(allExtensions, this)\n  }\n\n  /**\n   * Creates an command manager.\n   */\n  private createCommandManager(): void {\n    this.commandManager = new CommandManager({\n      editor: this,\n    })\n  }\n\n  /**\n   * Creates a ProseMirror schema.\n   */\n  private createSchema(): void {\n    this.schema = this.extensionManager.schema\n  }\n\n  /**\n   * Creates a ProseMirror view.\n   */\n  private createView(): void {\n    const doc = createDocument(this.options.content, this.schema, this.options.parseOptions)\n    const selection = resolveFocusPosition(doc, this.options.autofocus)\n\n    this.view = new EditorView(this.options.element, {\n      ...this.options.editorProps,\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: EditorState.create({\n        doc,\n        selection: selection || undefined,\n      }),\n    })\n\n    // `editor.view` is not yet available at this time.\n    // Therefore we will add all plugins and node views directly afterwards.\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins,\n    })\n\n    this.view.updateState(newState)\n\n    this.createNodeViews()\n\n    // Let’s store the editor instance in the DOM element.\n    // So we’ll have access to it for tests.\n    const dom = this.view.dom as HTMLElement\n\n    dom.editor = this\n  }\n\n  /**\n   * Creates all node views.\n   */\n  public createNodeViews(): void {\n    this.view.setProps({\n      nodeViews: this.extensionManager.nodeViews,\n    })\n  }\n\n  public isCapturingTransaction = false\n\n  private capturedTransaction: Transaction | null = null\n\n  public captureTransaction(fn: Function) {\n    this.isCapturingTransaction = true\n    fn()\n    this.isCapturingTransaction = false\n\n    const tr = this.capturedTransaction\n\n    this.capturedTransaction = null\n\n    return tr\n  }\n\n  /**\n   * The callback over which to send transactions (state updates) produced by the view.\n   *\n   * @param transaction An editor state transaction\n   */\n  private dispatchTransaction(transaction: Transaction): void {\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction\n\n        return\n      }\n\n      transaction.steps.forEach(step => this.capturedTransaction?.step(step))\n\n      return\n    }\n\n    const state = this.state.apply(transaction)\n    const selectionHasChanged = !this.state.selection.eq(state.selection)\n\n    this.view.updateState(state)\n    this.emit('transaction', {\n      editor: this,\n      transaction,\n    })\n\n    if (selectionHasChanged) {\n      this.emit('selectionUpdate', {\n        editor: this,\n        transaction,\n      })\n    }\n\n    const focus = transaction.getMeta('focus')\n    const blur = transaction.getMeta('blur')\n\n    if (focus) {\n      this.emit('focus', {\n        editor: this,\n        event: focus.event,\n        transaction,\n      })\n    }\n\n    if (blur) {\n      this.emit('blur', {\n        editor: this,\n        event: blur.event,\n        transaction,\n      })\n    }\n\n    if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n      return\n    }\n\n    this.emit('update', {\n      editor: this,\n      transaction,\n    })\n  }\n\n  /**\n   * Get attributes of the currently selected node or mark.\n   */\n  public getAttributes(nameOrType: string | NodeType | MarkType): Record<string, any> {\n    return getAttributes(this.state, nameOrType)\n  }\n\n  /**\n   * Returns if the currently selected node or mark is active.\n   *\n   * @param name Name of the node or mark\n   * @param attributes Attributes of the node or mark\n   */\n  public isActive(name: string, attributes?: {}): boolean;\n  public isActive(attributes: {}): boolean;\n  public isActive(nameOrAttributes: string, attributesOrUndefined?: {}): boolean {\n    const name = typeof nameOrAttributes === 'string'\n      ? nameOrAttributes\n      : null\n\n    const attributes = typeof nameOrAttributes === 'string'\n      ? attributesOrUndefined\n      : nameOrAttributes\n\n    return isActive(this.state, name, attributes)\n  }\n\n  /**\n   * Get the document as JSON.\n   */\n  public getJSON(): JSONContent {\n    return this.state.doc.toJSON()\n  }\n\n  /**\n   * Get the document as HTML.\n   */\n  public getHTML(): string {\n    return getHTMLFromFragment(this.state.doc.content, this.schema)\n  }\n\n  /**\n   * Get the document as text.\n   */\n  public getText(options?: {\n    blockSeparator?: string,\n    textSerializers?: Record<string, TextSerializer>,\n  }): string {\n    const {\n      blockSeparator = '\\n\\n',\n      textSerializers = {},\n    } = options || {}\n\n    return getText(this.state.doc, {\n      blockSeparator,\n      textSerializers: {\n        ...textSerializers,\n        ...getTextSerializersFromSchema(this.schema),\n      },\n    })\n  }\n\n  /**\n   * Check if there is no content.\n   */\n  public get isEmpty(): boolean {\n    return isNodeEmpty(this.state.doc)\n  }\n\n  /**\n   * Get the number of characters for the current document.\n   *\n   * @deprecated\n   */\n  public getCharacterCount(): number {\n    console.warn('[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.')\n\n    return this.state.doc.content.size - 2\n  }\n\n  /**\n   * Destroy the editor.\n   */\n  public destroy(): void {\n    this.emit('destroy')\n\n    if (this.view) {\n      this.view.destroy()\n    }\n\n    this.removeAllListeners()\n  }\n\n  /**\n   * Check if the editor is already destroyed.\n   */\n  public get isDestroyed(): boolean {\n    // @ts-ignore\n    return !this.view?.docView\n  }\n\n}\n","import { Node as ProseMirrorNode } from 'prosemirror-model'\nimport { Transaction } from 'prosemirror-state'\nimport { Transform } from 'prosemirror-transform'\n\n/**\n * Returns a new `Transform` based on all steps of the passed transactions.\n */\nexport function combineTransactionSteps(oldDoc: ProseMirrorNode, transactions: Transaction[]): Transform {\n  const transform = new Transform(oldDoc)\n\n  transactions.forEach(transaction => {\n    transaction.steps.forEach(step => {\n      transform.step(step)\n    })\n  })\n\n  return transform\n}\n","import { ContentMatch, NodeType } from 'prosemirror-model'\n\nexport function defaultBlockAt(match: ContentMatch): NodeType | null {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const { type } = match.edge(i)\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type\n    }\n  }\n\n  return null\n}\n","import { Node as ProseMirrorNode } from 'prosemirror-model'\n\nimport { NodeWithPos, Predicate } from '../types'\n\nexport function findChildren(node: ProseMirrorNode, predicate: Predicate): NodeWithPos[] {\n  const nodesWithPos: NodeWithPos[] = []\n\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos,\n      })\n    }\n  })\n\n  return nodesWithPos\n}\n","import { Node as ProseMirrorNode } from 'prosemirror-model'\n\nimport { NodeWithPos, Predicate, Range } from '../types'\n\n/**\n * Same as `findChildren` but searches only within a `range`.\n */\nexport function findChildrenInRange(node: ProseMirrorNode, range: Range, predicate: Predicate): NodeWithPos[] {\n  const nodesWithPos: NodeWithPos[] = []\n\n  // if (range.from === range.to) {\n  //   const nodeAt = node.nodeAt(range.from)\n\n  //   if (nodeAt) {\n  //     nodesWithPos.push({\n  //       node: nodeAt,\n  //       pos: range.from,\n  //     })\n  //   }\n  // }\n\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos,\n      })\n    }\n  })\n\n  return nodesWithPos\n}\n","import { Schema } from 'prosemirror-model'\n\nimport { ExtensionManager } from '../ExtensionManager'\nimport { Extensions } from '../types'\nimport { getSchemaByResolvedExtensions } from './getSchemaByResolvedExtensions'\n\nexport function getSchema(extensions: Extensions): Schema {\n  const resolvedExtensions = ExtensionManager.resolve(extensions)\n\n  return getSchemaByResolvedExtensions(resolvedExtensions)\n}\n","import { Node } from 'prosemirror-model'\n\nimport { Extensions, JSONContent } from '../types'\nimport { getHTMLFromFragment } from './getHTMLFromFragment'\nimport { getSchema } from './getSchema'\n\nexport function generateHTML(doc: JSONContent, extensions: Extensions): string {\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getHTMLFromFragment(contentNode.content, schema)\n}\n","import { DOMParser } from 'prosemirror-model'\n\nimport { Extensions } from '../types'\nimport { elementFromString } from '../utilities/elementFromString'\nimport { getSchema } from './getSchema'\n\nexport function generateJSON(html: string, extensions: Extensions): Record<string, any> {\n  const schema = getSchema(extensions)\n  const dom = elementFromString(html)\n\n  return DOMParser.fromSchema(schema)\n    .parse(dom)\n    .toJSON()\n}\n","import { Node } from 'prosemirror-model'\n\nimport { Extensions, JSONContent, TextSerializer } from '../types'\nimport { getSchema } from './getSchema'\nimport { getText } from './getText'\nimport { getTextSerializersFromSchema } from './getTextSerializersFromSchema'\n\nexport function generateText(\n  doc: JSONContent,\n  extensions: Extensions,\n  options?: {\n    blockSeparator?: string,\n    textSerializers?: Record<string, TextSerializer>,\n  },\n): string {\n  const {\n    blockSeparator = '\\n\\n',\n    textSerializers = {},\n  } = options || {}\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: {\n      ...textSerializers,\n      ...getTextSerializersFromSchema(schema),\n    },\n  })\n}\n","/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */\nexport function removeDuplicates<T>(array: T[], by = JSON.stringify): T[] {\n  const seen: Record<any, any> = {}\n\n  return array.filter(item => {\n    const key = by(item)\n\n    return Object.prototype.hasOwnProperty.call(seen, key)\n      ? false\n      : (seen[key] = true)\n  })\n}\n","import { Step, Transform } from 'prosemirror-transform'\n\nimport { Range } from '../types'\nimport { removeDuplicates } from '../utilities/removeDuplicates'\n\nexport type ChangedRange = {\n  oldRange: Range,\n  newRange: Range,\n}\n\n/**\n * Removes duplicated ranges and ranges that are\n * fully captured by other ranges.\n */\nfunction simplifyChangedRanges(changes: ChangedRange[]): ChangedRange[] {\n  const uniqueChanges = removeDuplicates(changes)\n\n  return uniqueChanges.length === 1\n    ? uniqueChanges\n    : uniqueChanges.filter((change, index) => {\n      const rest = uniqueChanges.filter((_, i) => i !== index)\n\n      return !rest.some(otherChange => {\n        return change.oldRange.from >= otherChange.oldRange.from\n          && change.oldRange.to <= otherChange.oldRange.to\n          && change.newRange.from >= otherChange.newRange.from\n          && change.newRange.to <= otherChange.newRange.to\n      })\n    })\n}\n\n/**\n * Returns a list of changed ranges\n * based on the first and last state of all steps.\n */\nexport function getChangedRanges(transform: Transform): ChangedRange[] {\n  const { mapping, steps } = transform\n  const changes: ChangedRange[] = []\n\n  mapping.maps.forEach((stepMap, index) => {\n    const ranges: Range[] = []\n\n    // This accounts for step changes where no range was actually altered\n    // e.g. when setting a mark, node attribute, etc.\n    // @ts-ignore\n    if (!stepMap.ranges.length) {\n      const { from, to } = steps[index] as Step & {\n        from?: number,\n        to?: number,\n      }\n\n      if (from === undefined || to === undefined) {\n        return\n      }\n\n      ranges.push({ from, to })\n    } else {\n      stepMap.forEach((from, to) => {\n        ranges.push({ from, to })\n      })\n    }\n\n    ranges.forEach(({ from, to }) => {\n      const newStart = mapping.slice(index).map(from, -1)\n      const newEnd = mapping.slice(index).map(to)\n      const oldStart = mapping.invert().map(newStart, -1)\n      const oldEnd = mapping.invert().map(newEnd)\n\n      changes.push({\n        oldRange: {\n          from: oldStart,\n          to: oldEnd,\n        },\n        newRange: {\n          from: newStart,\n          to: newEnd,\n        },\n      })\n    })\n  })\n\n  return simplifyChangedRanges(changes)\n}\n","import { Node as ProseMirrorNode } from 'prosemirror-model'\n\nimport { JSONContent } from '../types'\n\ninterface DebugJSONContent extends JSONContent {\n  from: number,\n  to: number,\n}\n\nexport function getDebugJSON(node: ProseMirrorNode, startOffset = 0): DebugJSONContent {\n  const isTopNode = node.type === node.type.schema.topNodeType\n  const increment = isTopNode ? 0 : 1\n  const from = startOffset\n  const to = from + node.nodeSize\n  const marks = node.marks.map(mark => {\n    const output: { type: string, attrs?: Record<string, any> } = {\n      type: mark.type.name,\n    }\n\n    if (Object.keys(mark.attrs).length) {\n      output.attrs = { ...mark.attrs }\n    }\n\n    return output\n  })\n  const attrs = { ...node.attrs }\n  const output: DebugJSONContent = {\n    type: node.type.name,\n    from,\n    to,\n  }\n\n  if (Object.keys(attrs).length) {\n    output.attrs = attrs\n  }\n\n  if (marks.length) {\n    output.marks = marks\n  }\n\n  if (node.content.childCount) {\n    output.content = []\n\n    node.forEach((child, offset) => {\n      output.content?.push(getDebugJSON(child, startOffset + offset + increment))\n    })\n  }\n\n  if (node.text) {\n    output.text = node.text\n  }\n\n  return output\n}\n","import { Node as ProseMirrorNode } from 'prosemirror-model'\n\nimport { MarkRange } from '../types'\nimport { getMarkRange } from './getMarkRange'\n\nexport function getMarksBetween(from: number, to: number, doc: ProseMirrorNode): MarkRange[] {\n  const marks: MarkRange[] = []\n\n  // get all inclusive marks on empty selection\n  if (from === to) {\n    doc\n      .resolve(from)\n      .marks()\n      .forEach(mark => {\n        const $pos = doc.resolve(from - 1)\n        const range = getMarkRange($pos, mark.type)\n\n        if (!range) {\n          return\n        }\n\n        marks.push({\n          mark,\n          ...range,\n        })\n      })\n  } else {\n    doc.nodesBetween(from, to, (node, pos) => {\n      marks.push(...node.marks.map(mark => ({\n        from: pos,\n        to: pos + node.nodeSize,\n        mark,\n      })))\n    })\n  }\n\n  return marks\n}\n","import { NodeSelection } from 'prosemirror-state'\n\nimport { isObject } from '../utilities/isObject'\n\nexport function isNodeSelection(value: unknown): value is NodeSelection {\n  return isObject(value) && value instanceof NodeSelection\n}\n","import { EditorView } from 'prosemirror-view'\n\nimport { minMax } from '../utilities/minMax'\n\nexport function posToDOMRect(view: EditorView, from: number, to: number): DOMRect {\n  const minPos = 0\n  const maxPos = view.state.doc.content.size\n  const resolvedFrom = minMax(from, minPos, maxPos)\n  const resolvedEnd = minMax(to, minPos, maxPos)\n  const start = view.coordsAtPos(resolvedFrom)\n  const end = view.coordsAtPos(resolvedEnd, -1)\n  const top = Math.min(start.top, end.top)\n  const bottom = Math.max(start.bottom, end.bottom)\n  const left = Math.min(start.left, end.left)\n  const right = Math.max(start.right, end.right)\n  const width = right - left\n  const height = bottom - top\n  const x = left\n  const y = top\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y,\n  }\n\n  return {\n    ...data,\n    toJSON: () => data,\n  }\n}\n","import { MarkType } from 'prosemirror-model'\n\nimport { getMarksBetween } from '../helpers/getMarksBetween'\nimport { InputRule, InputRuleFinder } from '../InputRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\n\n/**\n * Build an input rule that adds a mark when the\n * matched text is typed into it.\n */\nexport function markInputRule(config: {\n  find: InputRuleFinder,\n  type: MarkType,\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n  ,\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      const { tr } = state\n      const captureGroup = match[match.length - 1]\n      const fullMatch = match[0]\n      let markEnd = range.to\n\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/)\n        const textStart = range.from + fullMatch.indexOf(captureGroup)\n        const textEnd = textStart + captureGroup.length\n\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n          .filter(item => {\n            // @ts-ignore\n            const excluded = item.mark.type.excluded as MarkType[]\n\n            return excluded.find(type => type === config.type && type !== item.mark.type)\n          })\n          .filter(item => item.to > textStart)\n\n        if (excludedMarks.length) {\n          return null\n        }\n\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to)\n        }\n\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart)\n        }\n\n        markEnd = range.from + startSpaces + captureGroup.length\n\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}))\n\n        tr.removeStoredMark(config.type)\n      }\n    },\n  })\n}\n","import { NodeType } from 'prosemirror-model'\n\nimport { InputRule, InputRuleFinder } from '../InputRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\n\n/**\n * Build an input rule that adds a node when the\n * matched text is typed into it.\n */\nexport function nodeInputRule(config: {\n  find: InputRuleFinder,\n  type: NodeType,\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n  ,\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n      const { tr } = state\n      const start = range.from\n      let end = range.to\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n        let matchStart = start + offset\n\n        if (matchStart > end) {\n          matchStart = end\n        } else {\n          end = matchStart + match[1].length\n        }\n\n        // insert last typed character\n        const lastChar = match[0][match[0].length - 1]\n\n        tr.insertText(lastChar, start + match[0].length - 1)\n\n        // insert node from input rule\n        tr.replaceWith(matchStart, end, config.type.create(attributes))\n      } else if (match[0]) {\n        tr.replaceWith(start, end, config.type.create(attributes))\n      }\n    },\n  })\n}\n","import { NodeType } from 'prosemirror-model'\n\nimport { InputRule, InputRuleFinder } from '../InputRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\n\n/**\n * Build an input rule that changes the type of a textblock when the\n * matched text is typed into it. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n */\nexport function textblockTypeInputRule(config: {\n  find: InputRuleFinder,\n  type: NodeType,\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n  ,\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const $start = state.doc.resolve(range.from)\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n\n      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n        return null\n      }\n\n      state.tr\n        .delete(range.from, range.to)\n        .setBlockType(range.from, range.from, config.type, attributes)\n    },\n  })\n}\n","import { InputRule, InputRuleFinder } from '../InputRule'\n\n/**\n * Build an input rule that replaces text when the\n * matched text is typed into it.\n */\nexport function textInputRule(config: {\n  find: InputRuleFinder,\n  replace: string,\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace\n      let start = range.from\n      const end = range.to\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n\n        insert += match[0].slice(offset + match[1].length)\n        start += offset\n\n        const cutOff = start - end\n\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert\n          start = end\n        }\n      }\n\n      state.tr.insertText(insert, start, end)\n    },\n  })\n}\n","import { Node as ProseMirrorNode, NodeType } from 'prosemirror-model'\nimport { canJoin, findWrapping } from 'prosemirror-transform'\n\nimport { InputRule, InputRuleFinder } from '../InputRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\n\n/**\n * Build an input rule for automatically wrapping a textblock when a\n * given string is typed. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n *\n * `type` is the type of node to wrap in.\n *\n * By default, if there’s a node with the same type above the newly\n * wrapped node, the rule will try to join those\n * two nodes. You can pass a join predicate, which takes a regular\n * expression match and the node before the wrapped node, and can\n * return a boolean to indicate whether a join should happen.\n */\nexport function wrappingInputRule(config: {\n  find: InputRuleFinder,\n  type: NodeType,\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n  ,\n  joinPredicate?: (match: ExtendedRegExpMatchArray, node: ProseMirrorNode) => boolean,\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n      const tr = state.tr.delete(range.from, range.to)\n      const $start = tr.doc.resolve(range.from)\n      const blockRange = $start.blockRange()\n      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes)\n\n      if (!wrapping) {\n        return null\n      }\n\n      tr.wrap(blockRange, wrapping)\n\n      const before = tr.doc.resolve(range.from - 1).nodeBefore\n\n      if (\n        before\n        && before.type === config.type\n        && canJoin(tr.doc, range.from - 1)\n        && (!config.joinPredicate || config.joinPredicate(match, before))\n      ) {\n        tr.join(range.from - 1)\n      }\n    },\n  })\n}\n","import {\n  DOMOutputSpec,\n  Mark as ProseMirrorMark,\n  MarkSpec,\n  MarkType,\n} from 'prosemirror-model'\nimport { Plugin, Transaction } from 'prosemirror-state'\n\nimport { MarkConfig } from '.'\nimport { Editor } from './Editor'\nimport { getExtensionField } from './helpers/getExtensionField'\nimport { InputRule } from './InputRule'\nimport { Node } from './Node'\nimport { PasteRule } from './PasteRule'\nimport {\n  AnyConfig,\n  Attributes,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  ParentConfig,\n  RawCommands,\n} from './types'\nimport { callOrReturn } from './utilities/callOrReturn'\nimport { mergeDeep } from './utilities/mergeDeep'\n\ndeclare module '@tiptap/core' {\n  export interface MarkConfig<Options = any, Storage = any> {\n    [key: string]: any;\n\n    /**\n     * Name\n     */\n    name: string,\n\n    /**\n     * Priority\n     */\n    priority?: number,\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options,\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string,\n      parent: Exclude<ParentConfig<MarkConfig<Options, Storage>>['addOptions'], undefined>,\n    }) => Options,\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string,\n      options: Options,\n      parent: Exclude<ParentConfig<MarkConfig<Options, Storage>>['addStorage'], undefined>,\n    }) => Storage,\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addGlobalAttributes'],\n    }) => GlobalAttributes | {},\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addCommands'],\n    }) => Partial<RawCommands>,\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addKeyboardShortcuts'],\n    }) => {\n      [key: string]: KeyboardShortcutCommand,\n    },\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addInputRules'],\n    }) => InputRule[],\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addPasteRules'],\n    }) => PasteRule[],\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addProseMirrorPlugins'],\n    }) => Plugin[],\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<MarkConfig<Options, Storage>>['addExtensions'],\n    }) => Extensions,\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        parent: ParentConfig<MarkConfig<Options, Storage>>['extendNodeSchema'],\n      },\n      extension: Node,\n    ) => Record<string, any>) | null,\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        parent: ParentConfig<MarkConfig<Options, Storage>>['extendMarkSchema'],\n      },\n      extension: Mark,\n    ) => Record<string, any>) | null,\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?: ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options, Storage>>['onBeforeCreate'],\n    }) => void) | null,\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?: ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options, Storage>>['onCreate'],\n    }) => void) | null,\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?: ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options, Storage>>['onUpdate'],\n    }) => void) | null,\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?: ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options, Storage>>['onSelectionUpdate'],\n    }) => void) | null,\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        editor: Editor,\n        type: MarkType,\n        parent: ParentConfig<MarkConfig<Options, Storage>>['onTransaction'],\n      },\n      props: {\n        transaction: Transaction,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        editor: Editor,\n        type: MarkType,\n        parent: ParentConfig<MarkConfig<Options, Storage>>['onFocus'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        editor: Editor,\n        type: MarkType,\n        parent: ParentConfig<MarkConfig<Options, Storage>>['onBlur'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?: ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: MarkType,\n      parent: ParentConfig<MarkConfig<Options, Storage>>['onDestroy'],\n    }) => void) | null,\n\n    /**\n     * Keep mark after split node\n     */\n    keepOnSplit?: boolean | (() => boolean),\n\n    /**\n     * Inclusive\n     */\n    inclusive?: MarkSpec['inclusive'] | ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<MarkConfig<Options, Storage>>['inclusive'],\n    }) => MarkSpec['inclusive']),\n\n    /**\n     * Excludes\n     */\n    excludes?: MarkSpec['excludes'] | ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<MarkConfig<Options, Storage>>['excludes'],\n    }) => MarkSpec['excludes']),\n\n    /**\n     * Group\n     */\n    group?: MarkSpec['group'] | ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<MarkConfig<Options, Storage>>['group'],\n    }) => MarkSpec['group']),\n\n    /**\n     * Spanning\n     */\n    spanning?: MarkSpec['spanning'] | ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<MarkConfig<Options, Storage>>['spanning'],\n    }) => MarkSpec['spanning']),\n\n    /**\n     * Code\n     */\n    code?: boolean | ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<MarkConfig<Options, Storage>>['code'],\n    }) => boolean),\n\n    /**\n     * Parse HTML\n     */\n    parseHTML?: (\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        parent: ParentConfig<MarkConfig<Options, Storage>>['parseHTML'],\n      },\n    ) => MarkSpec['parseDOM'],\n\n    /**\n     * Render HTML\n     */\n    renderHTML?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        parent: ParentConfig<MarkConfig<Options, Storage>>['renderHTML'],\n      },\n      props: {\n        mark: ProseMirrorMark,\n        HTMLAttributes: Record<string, any>,\n      },\n    ) => DOMOutputSpec) | null,\n\n    /**\n     * Attributes\n     */\n    addAttributes?: (\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        parent: ParentConfig<MarkConfig<Options, Storage>>['addAttributes'],\n      },\n    ) => Attributes | {},\n  }\n}\n\nexport class Mark<Options = any, Storage = any> {\n  type = 'mark'\n\n  name = 'mark'\n\n  parent: Mark | null = null\n\n  child: Mark | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: MarkConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<MarkConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`)\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField<AnyConfig['addOptions']>(\n        this,\n        'addOptions',\n        {\n          name: this.name,\n        },\n      ))\n    }\n\n    this.storage = callOrReturn(getExtensionField<AnyConfig['addStorage']>(\n      this,\n      'addStorage',\n      {\n        name: this.name,\n        options: this.options,\n      },\n    )) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<MarkConfig<O, S>> = {}) {\n    return new Mark<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options, options) as Options\n\n    extension.storage = callOrReturn(getExtensionField<AnyConfig['addStorage']>(\n      extension,\n      'addStorage',\n      {\n        name: extension.name,\n        options: extension.options,\n      },\n    ))\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(extendedConfig: Partial<MarkConfig<ExtendedOptions, ExtendedStorage>> = {}) {\n    const extension = new Mark<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name\n      ? extendedConfig.name\n      : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`)\n    }\n\n    extension.options = callOrReturn(getExtensionField<AnyConfig['addOptions']>(\n      extension,\n      'addOptions',\n      {\n        name: extension.name,\n      },\n    ))\n\n    extension.storage = callOrReturn(getExtensionField<AnyConfig['addStorage']>(\n      extension,\n      'addStorage',\n      {\n        name: extension.name,\n        options: extension.options,\n      },\n    ))\n\n    return extension\n  }\n}\n","import {\n  DOMOutputSpec,\n  Node as ProseMirrorNode,\n  NodeSpec,\n  NodeType,\n} from 'prosemirror-model'\nimport { Plugin, Transaction } from 'prosemirror-state'\n\nimport { NodeConfig } from '.'\nimport { Editor } from './Editor'\nimport { getExtensionField } from './helpers/getExtensionField'\nimport { InputRule } from './InputRule'\nimport { PasteRule } from './PasteRule'\nimport {\n  AnyConfig,\n  Attributes,\n  Extensions,\n  GlobalAttributes,\n  KeyboardShortcutCommand,\n  NodeViewRenderer,\n  ParentConfig,\n  RawCommands,\n} from './types'\nimport { callOrReturn } from './utilities/callOrReturn'\nimport { mergeDeep } from './utilities/mergeDeep'\n\ndeclare module '@tiptap/core' {\n  interface NodeConfig<Options = any, Storage = any> {\n    [key: string]: any;\n\n    /**\n     * Name\n     */\n    name: string,\n\n    /**\n     * Priority\n     */\n    priority?: number,\n\n    /**\n     * Default options\n     */\n    defaultOptions?: Options,\n\n    /**\n     * Default Options\n     */\n    addOptions?: (this: {\n      name: string,\n      parent: Exclude<ParentConfig<NodeConfig<Options, Storage>>['addOptions'], undefined>,\n    }) => Options,\n\n    /**\n     * Default Storage\n     */\n    addStorage?: (this: {\n      name: string,\n      options: Options,\n      parent: Exclude<ParentConfig<NodeConfig<Options, Storage>>['addStorage'], undefined>,\n    }) => Storage,\n\n    /**\n     * Global attributes\n     */\n    addGlobalAttributes?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addGlobalAttributes'],\n    }) => GlobalAttributes | {},\n\n    /**\n     * Raw\n     */\n    addCommands?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addCommands'],\n    }) => Partial<RawCommands>,\n\n    /**\n     * Keyboard shortcuts\n     */\n    addKeyboardShortcuts?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addKeyboardShortcuts'],\n    }) => {\n      [key: string]: KeyboardShortcutCommand,\n    },\n\n    /**\n     * Input rules\n     */\n    addInputRules?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addInputRules'],\n    }) => InputRule[],\n\n    /**\n     * Paste rules\n     */\n    addPasteRules?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addPasteRules'],\n    }) => PasteRule[],\n\n    /**\n     * ProseMirror plugins\n     */\n    addProseMirrorPlugins?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addProseMirrorPlugins'],\n    }) => Plugin[],\n\n    /**\n     * Extensions\n     */\n    addExtensions?: (this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addExtensions'],\n    }) => Extensions,\n\n    /**\n     * Extend Node Schema\n     */\n    extendNodeSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        parent: ParentConfig<NodeConfig<Options, Storage>>['extendNodeSchema'],\n      },\n      extension: Node,\n    ) => Record<string, any>) | null,\n\n    /**\n     * Extend Mark Schema\n     */\n    extendMarkSchema?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        parent: ParentConfig<NodeConfig<Options, Storage>>['extendMarkSchema'],\n      },\n      extension: Node,\n    ) => Record<string, any>) | null,\n\n    /**\n     * The editor is not ready yet.\n     */\n    onBeforeCreate?: ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['onBeforeCreate'],\n    }) => void) | null,\n\n    /**\n     * The editor is ready.\n     */\n    onCreate?: ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['onCreate'],\n    }) => void) | null,\n\n    /**\n     * The content has changed.\n     */\n    onUpdate?: ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['onUpdate'],\n    }) => void) | null,\n\n    /**\n     * The selection has changed.\n     */\n    onSelectionUpdate?: ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['onSelectionUpdate'],\n    }) => void) | null,\n\n    /**\n     * The editor state has changed.\n     */\n    onTransaction?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        editor: Editor,\n        type: NodeType,\n        parent: ParentConfig<NodeConfig<Options, Storage>>['onTransaction'],\n      },\n      props: {\n        transaction: Transaction,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is focused.\n     */\n    onFocus?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        editor: Editor,\n        type: NodeType,\n        parent: ParentConfig<NodeConfig<Options, Storage>>['onFocus'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor isn’t focused anymore.\n     */\n    onBlur?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        editor: Editor,\n        type: NodeType,\n        parent: ParentConfig<NodeConfig<Options, Storage>>['onBlur'],\n      },\n      props: {\n        event: FocusEvent,\n      },\n    ) => void) | null,\n\n    /**\n     * The editor is destroyed.\n     */\n    onDestroy?: ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['onDestroy'],\n    }) => void) | null,\n\n    /**\n     * Node View\n     */\n    addNodeView?: ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      editor: Editor,\n      type: NodeType,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['addNodeView'],\n    }) => NodeViewRenderer) | null,\n\n    /**\n     * TopNode\n     */\n    topNode?: boolean,\n\n    /**\n     * Content\n     */\n    content?: NodeSpec['content'] | ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['content'],\n    }) => NodeSpec['content']),\n\n    /**\n     * Marks\n     */\n    marks?: NodeSpec['marks'] | ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['marks'],\n    }) => NodeSpec['marks']),\n\n    /**\n     * Group\n     */\n    group?: NodeSpec['group'] | ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['group'],\n    }) => NodeSpec['group']),\n\n    /**\n     * Inline\n     */\n    inline?: NodeSpec['inline'] | ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['inline'],\n    }) => NodeSpec['inline']),\n\n    /**\n     * Atom\n     */\n    atom?: NodeSpec['atom'] | ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['atom'],\n    }) => NodeSpec['atom']),\n\n    /**\n     * Selectable\n     */\n    selectable?: NodeSpec['selectable'] | ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['selectable'],\n    }) => NodeSpec['selectable']),\n\n    /**\n     * Draggable\n     */\n    draggable?: NodeSpec['draggable'] | ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['draggable'],\n    }) => NodeSpec['draggable']),\n\n    /**\n     * Code\n     */\n    code?: NodeSpec['code'] | ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['code'],\n    }) => NodeSpec['code']),\n\n    /**\n     * Whitespace\n     */\n    whitespace?: NodeSpec['whitespace'] | ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['whitespace'],\n    }) => NodeSpec['whitespace']),\n\n    /**\n     * Defining\n     */\n    defining?: NodeSpec['defining'] | ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['defining'],\n    }) => NodeSpec['defining']),\n\n    /**\n     * Isolating\n     */\n    isolating?: NodeSpec['isolating'] | ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<NodeConfig<Options, Storage>>['isolating'],\n    }) => NodeSpec['isolating']),\n\n    /**\n     * Parse HTML\n     */\n    parseHTML?: (\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        parent: ParentConfig<NodeConfig<Options, Storage>>['parseHTML'],\n      },\n    ) => NodeSpec['parseDOM'],\n\n    /**\n     * Render HTML\n     */\n    renderHTML?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        parent: ParentConfig<NodeConfig<Options, Storage>>['renderHTML'],\n      },\n      props: {\n        node: ProseMirrorNode,\n        HTMLAttributes: Record<string, any>,\n      }\n    ) => DOMOutputSpec) | null,\n\n    /**\n     * Render Text\n     */\n    renderText?: ((\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        parent: ParentConfig<NodeConfig<Options, Storage>>['renderText'],\n      },\n      props: {\n        node: ProseMirrorNode,\n        pos: number,\n        parent: ProseMirrorNode,\n        index: number,\n      }\n    ) => string) | null,\n\n    /**\n     * Add Attributes\n     */\n    addAttributes?: (\n      this: {\n        name: string,\n        options: Options,\n        storage: Storage,\n        parent: ParentConfig<NodeConfig<Options, Storage>>['addAttributes'],\n      },\n    ) => Attributes | {},\n  }\n}\n\nexport class Node<Options = any, Storage = any> {\n  type = 'node'\n\n  name = 'node'\n\n  parent: Node | null = null\n\n  child: Node | null = null\n\n  options: Options\n\n  storage: Storage\n\n  config: NodeConfig = {\n    name: this.name,\n    defaultOptions: {},\n  }\n\n  constructor(config: Partial<NodeConfig<Options, Storage>> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = this.config.name\n\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`)\n    }\n\n    // TODO: remove `addOptions` fallback\n    this.options = this.config.defaultOptions\n\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField<AnyConfig['addOptions']>(\n        this,\n        'addOptions',\n        {\n          name: this.name,\n        },\n      ))\n    }\n\n    this.storage = callOrReturn(getExtensionField<AnyConfig['addStorage']>(\n      this,\n      'addStorage',\n      {\n        name: this.name,\n        options: this.options,\n      },\n    )) || {}\n  }\n\n  static create<O = any, S = any>(config: Partial<NodeConfig<O, S>> = {}) {\n    return new Node<O, S>(config)\n  }\n\n  configure(options: Partial<Options> = {}) {\n    // return a new instance so we can use the same extension\n    // with different calls of `configure`\n    const extension = this.extend()\n\n    extension.options = mergeDeep(this.options, options) as Options\n\n    extension.storage = callOrReturn(getExtensionField<AnyConfig['addStorage']>(\n      extension,\n      'addStorage',\n      {\n        name: extension.name,\n        options: extension.options,\n      },\n    ))\n\n    return extension\n  }\n\n  extend<ExtendedOptions = Options, ExtendedStorage = Storage>(extendedConfig: Partial<NodeConfig<ExtendedOptions, ExtendedStorage>> = {}) {\n    const extension = new Node<ExtendedOptions, ExtendedStorage>(extendedConfig)\n\n    extension.parent = this\n\n    this.child = extension\n\n    extension.name = extendedConfig.name\n      ? extendedConfig.name\n      : extension.parent.name\n\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`)\n    }\n\n    extension.options = callOrReturn(getExtensionField<AnyConfig['addOptions']>(\n      extension,\n      'addOptions',\n      {\n        name: extension.name,\n      },\n    ))\n\n    extension.storage = callOrReturn(getExtensionField<AnyConfig['addStorage']>(\n      extension,\n      'addStorage',\n      {\n        name: extension.name,\n        options: extension.options,\n      },\n    ))\n\n    return extension\n  }\n}\n","import { Node as ProseMirrorNode } from 'prosemirror-model'\nimport { NodeSelection } from 'prosemirror-state'\nimport { Decoration, NodeView as ProseMirrorNodeView } from 'prosemirror-view'\n\nimport { Editor as CoreEditor } from './Editor'\nimport { Node } from './Node'\nimport { NodeViewRendererOptions, NodeViewRendererProps } from './types'\nimport { isiOS } from './utilities/isiOS'\n\nexport class NodeView<\n  Component,\n  Editor extends CoreEditor = CoreEditor,\n  Options extends NodeViewRendererOptions = NodeViewRendererOptions,\n> implements ProseMirrorNodeView {\n\n  component: Component\n\n  editor: Editor\n\n  options: Options\n\n  extension: Node\n\n  node: ProseMirrorNode\n\n  decorations: Decoration[]\n\n  getPos: any\n\n  isDragging = false\n\n  constructor(component: Component, props: NodeViewRendererProps, options?: Partial<Options>) {\n    this.component = component\n    this.editor = props.editor as Editor\n    this.options = {\n      stopEvent: null,\n      ignoreMutation: null,\n      ...options,\n    } as Options\n    this.extension = props.extension\n    this.node = props.node\n    this.decorations = props.decorations\n    this.getPos = props.getPos\n    this.mount()\n  }\n\n  mount() {\n    // eslint-disable-next-line\n    return\n  }\n\n  get dom(): HTMLElement {\n    return this.editor.view.dom as HTMLElement\n  }\n\n  get contentDOM(): HTMLElement | null {\n    return null\n  }\n\n  onDragStart(event: DragEvent) {\n    const { view } = this.editor\n    const target = (event.target as HTMLElement)\n\n    // get the drag handle element\n    // `closest` is not available for text nodes so we may have to use its parent\n    const dragHandle = target.nodeType === 3\n      ? target.parentElement?.closest('[data-drag-handle]')\n      : target.closest('[data-drag-handle]')\n\n    if (\n      !this.dom\n      || this.contentDOM?.contains(target)\n      || !dragHandle\n    ) {\n      return\n    }\n\n    let x = 0\n    let y = 0\n\n    // calculate offset for drag element if we use a different drag handle element\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect()\n      const handleBox = dragHandle.getBoundingClientRect()\n\n      // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n      const offsetX = event.offsetX ?? (event as any).nativeEvent?.offsetX\n      const offsetY = event.offsetY ?? (event as any).nativeEvent?.offsetY\n\n      x = handleBox.x - domBox.x + offsetX\n      y = handleBox.y - domBox.y + offsetY\n    }\n\n    event.dataTransfer?.setDragImage(this.dom, x, y)\n\n    // we need to tell ProseMirror that we want to move the whole node\n    // so we create a NodeSelection\n    const selection = NodeSelection.create(view.state.doc, this.getPos())\n    const transaction = view.state.tr.setSelection(selection)\n\n    view.dispatch(transaction)\n  }\n\n  stopEvent(event: Event) {\n    if (!this.dom) {\n      return false\n    }\n\n    if (typeof this.options.stopEvent === 'function') {\n      return this.options.stopEvent({ event })\n    }\n\n    const target = (event.target as HTMLElement)\n    const isInElement = this.dom.contains(target) && !this.contentDOM?.contains(target)\n\n    // any event from child nodes should be handled by ProseMirror\n    if (!isInElement) {\n      return false\n    }\n\n    const isDropEvent = event.type === 'drop'\n    const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName)\n      || target.isContentEditable\n\n    // any input event within node views should be ignored by ProseMirror\n    if (isInput && !isDropEvent) {\n      return true\n    }\n\n    const { isEditable } = this.editor\n    const { isDragging } = this\n    const isDraggable = !!this.node.type.spec.draggable\n    const isSelectable = NodeSelection.isSelectable(this.node)\n    const isCopyEvent = event.type === 'copy'\n    const isPasteEvent = event.type === 'paste'\n    const isCutEvent = event.type === 'cut'\n    const isClickEvent = event.type === 'mousedown'\n    const isDragEvent = event.type.startsWith('drag')\n\n    // ProseMirror tries to drag selectable nodes\n    // even if `draggable` is set to `false`\n    // this fix prevents that\n    if (!isDraggable && isSelectable && isDragEvent) {\n      event.preventDefault()\n    }\n\n    if (isDraggable && isDragEvent && !isDragging) {\n      event.preventDefault()\n      return false\n    }\n\n    // we have to store that dragging started\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest('[data-drag-handle]')\n      const isValidDragHandle = dragHandle\n        && (this.dom === dragHandle || (this.dom.contains(dragHandle)))\n\n      if (isValidDragHandle) {\n        this.isDragging = true\n\n        document.addEventListener('dragend', () => {\n          this.isDragging = false\n        }, { once: true })\n\n        document.addEventListener('mouseup', () => {\n          this.isDragging = false\n        }, { once: true })\n      }\n    }\n\n    // these events are handled by prosemirror\n    if (\n      isDragging\n      || isDropEvent\n      || isCopyEvent\n      || isPasteEvent\n      || isCutEvent\n      || (isClickEvent && isSelectable)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  ignoreMutation(mutation: MutationRecord | { type: 'selection', target: Element }) {\n    if (!this.dom || !this.contentDOM) {\n      return true\n    }\n\n    if (typeof this.options.ignoreMutation === 'function') {\n      return this.options.ignoreMutation({ mutation })\n    }\n\n    // a leaf/atom node is like a black box for ProseMirror\n    // and should be fully handled by the node view\n    if (this.node.isLeaf || this.node.isAtom) {\n      return true\n    }\n\n    // ProseMirror should handle any selections\n    if (mutation.type === 'selection') {\n      return false\n    }\n\n    // try to prevent a bug on iOS that will break node views on enter\n    // this is because ProseMirror can’t preventDispatch on enter\n    // this will lead to a re-render of the node view on enter\n    // see: https://github.com/ueberdosis/tiptap/issues/1214\n    if (\n      this.dom.contains(mutation.target)\n      && mutation.type === 'childList'\n      && isiOS()\n      && this.editor.isFocused\n    ) {\n      const changedNodes = [\n        ...Array.from(mutation.addedNodes),\n        ...Array.from(mutation.removedNodes),\n      ] as HTMLElement[]\n\n      // we’ll check if every changed node is contentEditable\n      // to make sure it’s probably mutated by ProseMirror\n      if (changedNodes.every(node => node.isContentEditable)) {\n        return false\n      }\n    }\n\n    // we will allow mutation contentDOM with attributes\n    // so we can for example adding classes within our node view\n    if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n      return true\n    }\n\n    // ProseMirror should handle any changes within contentDOM\n    if (this.contentDOM.contains(mutation.target)) {\n      return false\n    }\n\n    return true\n  }\n\n  updateAttributes(attributes: {}) {\n    this.editor.commands.command(({ tr }) => {\n      const pos = this.getPos()\n\n      tr.setNodeMarkup(pos, undefined, {\n        ...this.node.attrs,\n        ...attributes,\n      })\n\n      return true\n    })\n  }\n\n  deleteNode(): void {\n    const from = this.getPos()\n    const to = from + this.node.nodeSize\n\n    this.editor.commands.deleteRange({ from, to })\n  }\n}\n","import { MarkType } from 'prosemirror-model'\n\nimport { getMarksBetween } from '../helpers/getMarksBetween'\nimport { PasteRule, PasteRuleFinder } from '../PasteRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities/callOrReturn'\n\n/**\n * Build an paste rule that adds a mark when the\n * matched text is pasted into it.\n */\nexport function markPasteRule(config: {\n  find: PasteRuleFinder,\n  type: MarkType,\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null\n  ,\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      const { tr } = state\n      const captureGroup = match[match.length - 1]\n      const fullMatch = match[0]\n      let markEnd = range.to\n\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/)\n        const textStart = range.from + fullMatch.indexOf(captureGroup)\n        const textEnd = textStart + captureGroup.length\n\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n          .filter(item => {\n            // @ts-ignore\n            const excluded = item.mark.type.excluded as MarkType[]\n\n            return excluded.find(type => type === config.type && type !== item.mark.type)\n          })\n          .filter(item => item.to > textStart)\n\n        if (excludedMarks.length) {\n          return null\n        }\n\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to)\n        }\n\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart)\n        }\n\n        markEnd = range.from + startSpaces + captureGroup.length\n\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}))\n\n        tr.removeStoredMark(config.type)\n      }\n    },\n  })\n}\n","// source: https://stackoverflow.com/a/6969486\nexport function escapeForRegEx(string: string): string {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n}\n","import { NodeType } from 'prosemirror-model'\n\nimport { PasteRule } from '../PasteRule'\nimport { ExtendedRegExpMatchArray } from '../types'\nimport { callOrReturn } from '../utilities'\n\n/**\n * Build an paste rule that adds a node when the\n * matched text is pasted into it.\n */\nexport function nodePasteRule(config: {\n  find: RegExp,\n  type: NodeType,\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray) => Record<string, any>)\n    | false\n    | null,\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler({ match, chain, range }) {\n      const attributes = callOrReturn(config.getAttributes, undefined, match)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      if (match.input) {\n        chain()\n          .deleteRange(range)\n          .insertContent({\n            type: config.type.name,\n            attrs: attributes,\n          })\n      }\n    },\n  })\n}\n","import { PasteRule, PasteRuleFinder } from '../PasteRule'\n\n/**\n * Build an paste rule that replaces text when the\n * matched text is pasted into it.\n */\nexport function textPasteRule(config: {\n  find: PasteRuleFinder,\n  replace: string,\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace\n      let start = range.from\n      const end = range.to\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n\n        insert += match[0].slice(offset + match[1].length)\n        start += offset\n\n        const cutOff = start - end\n\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert\n          start = end\n        }\n      }\n\n      state.tr.insertText(insert, start, end)\n    },\n  })\n}\n","import { Transaction } from 'prosemirror-state'\n\nexport interface TrackerResult {\n  position: number,\n  deleted: boolean,\n}\n\nexport class Tracker {\n\n  transaction: Transaction\n\n  currentStep: number\n\n  constructor(transaction: Transaction) {\n    this.transaction = transaction\n    this.currentStep = this.transaction.steps.length\n  }\n\n  map(position: number): TrackerResult {\n    let deleted = false\n\n    const mappedPosition = this.transaction.steps\n      .slice(this.currentStep)\n      .reduce((newPosition, step) => {\n        const mapResult = step\n          .getMap()\n          .mapResult(newPosition)\n\n        if (mapResult.deleted) {\n          deleted = true\n        }\n\n        return mapResult.pos\n      }, position)\n\n    return {\n      position: mappedPosition,\n      deleted,\n    }\n  }\n\n}\n"]},"metadata":{},"sourceType":"module"}