{"ast":null,"code":"import { isTextSelection, isNodeSelection, posToDOMRect, Extension } from '@tiptap/core';\nimport { Plugin, PluginKey } from 'prosemirror-state';\nimport tippy from 'tippy.js';\n\nclass BubbleMenuView {\n  constructor({\n    editor,\n    element,\n    view,\n    tippyOptions = {},\n    shouldShow\n  }) {\n    this.preventHide = false;\n\n    this.shouldShow = ({\n      view,\n      state,\n      from,\n      to\n    }) => {\n      const {\n        doc,\n        selection\n      } = state;\n      const {\n        empty\n      } = selection; // Sometime check for `empty` is not enough.\n      // Doubleclick an empty paragraph returns a node size of 2.\n      // So we check also for an empty text size.\n\n      const isEmptyTextBlock = !doc.textBetween(from, to).length && isTextSelection(state.selection);\n\n      if (!view.hasFocus() || empty || isEmptyTextBlock) {\n        return false;\n      }\n\n      return true;\n    };\n\n    this.mousedownHandler = () => {\n      this.preventHide = true;\n    };\n\n    this.dragstartHandler = () => {\n      this.hide();\n    };\n\n    this.focusHandler = () => {\n      // we use `setTimeout` to make sure `selection` is already updated\n      setTimeout(() => this.update(this.editor.view));\n    };\n\n    this.blurHandler = ({\n      event\n    }) => {\n      var _a;\n\n      if (this.preventHide) {\n        this.preventHide = false;\n        return;\n      }\n\n      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n        return;\n      }\n\n      this.hide();\n    };\n\n    this.editor = editor;\n    this.element = element;\n    this.view = view;\n\n    if (shouldShow) {\n      this.shouldShow = shouldShow;\n    }\n\n    this.element.addEventListener('mousedown', this.mousedownHandler, {\n      capture: true\n    });\n    this.view.dom.addEventListener('dragstart', this.dragstartHandler);\n    this.editor.on('focus', this.focusHandler);\n    this.editor.on('blur', this.blurHandler);\n    this.tippyOptions = tippyOptions; // Detaches menu content from its current parent\n\n    this.element.remove();\n    this.element.style.visibility = 'visible';\n  }\n\n  createTooltip() {\n    const {\n      element: editorElement\n    } = this.editor.options;\n    const editorIsAttached = !!editorElement.parentElement;\n\n    if (this.tippy || !editorIsAttached) {\n      return;\n    }\n\n    this.tippy = tippy(editorElement, {\n      duration: 0,\n      getReferenceClientRect: null,\n      content: this.element,\n      interactive: true,\n      trigger: 'manual',\n      placement: 'top',\n      hideOnClick: 'toggle',\n      ...this.tippyOptions\n    }); // maybe we have to hide tippy on its own blur event as well\n\n    if (this.tippy.popper.firstChild) {\n      this.tippy.popper.firstChild.addEventListener('blur', event => {\n        this.blurHandler({\n          event\n        });\n      });\n    }\n  }\n\n  update(view, oldState) {\n    var _a, _b, _c;\n\n    const {\n      state,\n      composing\n    } = view;\n    const {\n      doc,\n      selection\n    } = state;\n    const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);\n\n    if (composing || isSame) {\n      return;\n    }\n\n    this.createTooltip(); // support for CellSelections\n\n    const {\n      ranges\n    } = selection;\n    const from = Math.min(...ranges.map(range => range.$from.pos));\n    const to = Math.max(...ranges.map(range => range.$to.pos));\n    const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\n      editor: this.editor,\n      view,\n      state,\n      oldState,\n      from,\n      to\n    });\n\n    if (!shouldShow) {\n      this.hide();\n      return;\n    }\n\n    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\n      getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => {\n        if (isNodeSelection(state.selection)) {\n          const node = view.nodeDOM(from);\n\n          if (node) {\n            return node.getBoundingClientRect();\n          }\n        }\n\n        return posToDOMRect(view, from, to);\n      })\n    });\n    this.show();\n  }\n\n  show() {\n    var _a;\n\n    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\n  }\n\n  hide() {\n    var _a;\n\n    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\n  }\n\n  destroy() {\n    var _a;\n\n    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.destroy();\n    this.element.removeEventListener('mousedown', this.mousedownHandler, {\n      capture: true\n    });\n    this.view.dom.removeEventListener('dragstart', this.dragstartHandler);\n    this.editor.off('focus', this.focusHandler);\n    this.editor.off('blur', this.blurHandler);\n  }\n\n}\n\nconst BubbleMenuPlugin = options => {\n  return new Plugin({\n    key: typeof options.pluginKey === 'string' ? new PluginKey(options.pluginKey) : options.pluginKey,\n    view: view => new BubbleMenuView({\n      view,\n      ...options\n    })\n  });\n};\n\nconst BubbleMenu = Extension.create({\n  name: 'bubbleMenu',\n\n  addOptions() {\n    return {\n      element: null,\n      tippyOptions: {},\n      pluginKey: 'bubbleMenu',\n      shouldShow: null\n    };\n  },\n\n  addProseMirrorPlugins() {\n    if (!this.options.element) {\n      return [];\n    }\n\n    return [BubbleMenuPlugin({\n      pluginKey: this.options.pluginKey,\n      editor: this.editor,\n      element: this.options.element,\n      tippyOptions: this.options.tippyOptions,\n      shouldShow: this.options.shouldShow\n    })];\n  }\n\n});\nexport { BubbleMenu, BubbleMenuPlugin, BubbleMenuView, BubbleMenu as default };","map":{"version":3,"mappings":"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","names":["BubbleMenuView","constructor","editor","element","view","tippyOptions","shouldShow","preventHide","state","from","to","doc","selection","empty","isEmptyTextBlock","textBetween","length","isTextSelection","hasFocus","mousedownHandler","dragstartHandler","hide","focusHandler","setTimeout","update","event","relatedTarget","parentNode","_a","contains","addEventListener","capture","dom","on","blurHandler","remove","style","visibility","createTooltip","editorElement","options","editorIsAttached","parentElement","tippy","duration","getReferenceClientRect","content","interactive","trigger","placement","hideOnClick","popper","firstChild","oldState","composing","isSame","eq","ranges","Math","min","map","range","$from","pos","max","$to","_b","setProps","_c","isNodeSelection","node","nodeDOM","getBoundingClientRect","posToDOMRect","show","destroy","removeEventListener","off","Plugin","key","pluginKey","PluginKey","Extension","create","name","addOptions","addProseMirrorPlugins","BubbleMenuPlugin"],"sources":["../src/bubble-menu-plugin.ts","../src/bubble-menu.ts"],"sourcesContent":["import {\n  Editor,\n  isNodeSelection,\n  isTextSelection,\n  posToDOMRect,\n} from '@tiptap/core'\nimport { EditorState, Plugin, PluginKey } from 'prosemirror-state'\nimport { EditorView } from 'prosemirror-view'\nimport tippy, { Instance, Props } from 'tippy.js'\n\nexport interface BubbleMenuPluginProps {\n  pluginKey: PluginKey | string,\n  editor: Editor,\n  element: HTMLElement,\n  tippyOptions?: Partial<Props>,\n  shouldShow?: ((props: {\n    editor: Editor,\n    view: EditorView,\n    state: EditorState,\n    oldState?: EditorState,\n    from: number,\n    to: number,\n  }) => boolean) | null,\n}\n\nexport type BubbleMenuViewProps = BubbleMenuPluginProps & {\n  view: EditorView,\n}\n\nexport class BubbleMenuView {\n  public editor: Editor\n\n  public element: HTMLElement\n\n  public view: EditorView\n\n  public preventHide = false\n\n  public tippy: Instance | undefined\n\n  public tippyOptions?: Partial<Props>\n\n  public shouldShow: Exclude<BubbleMenuPluginProps['shouldShow'], null> = ({\n    view,\n    state,\n    from,\n    to,\n  }) => {\n    const { doc, selection } = state\n    const { empty } = selection\n\n    // Sometime check for `empty` is not enough.\n    // Doubleclick an empty paragraph returns a node size of 2.\n    // So we check also for an empty text size.\n    const isEmptyTextBlock = !doc.textBetween(from, to).length\n      && isTextSelection(state.selection)\n\n    if (\n      !view.hasFocus()\n      || empty\n      || isEmptyTextBlock\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  constructor({\n    editor,\n    element,\n    view,\n    tippyOptions = {},\n    shouldShow,\n  }: BubbleMenuViewProps) {\n    this.editor = editor\n    this.element = element\n    this.view = view\n\n    if (shouldShow) {\n      this.shouldShow = shouldShow\n    }\n\n    this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true })\n    this.view.dom.addEventListener('dragstart', this.dragstartHandler)\n    this.editor.on('focus', this.focusHandler)\n    this.editor.on('blur', this.blurHandler)\n    this.tippyOptions = tippyOptions\n    // Detaches menu content from its current parent\n    this.element.remove()\n    this.element.style.visibility = 'visible'\n  }\n\n  mousedownHandler = () => {\n    this.preventHide = true\n  }\n\n  dragstartHandler = () => {\n    this.hide()\n  }\n\n  focusHandler = () => {\n    // we use `setTimeout` to make sure `selection` is already updated\n    setTimeout(() => this.update(this.editor.view))\n  }\n\n  blurHandler = ({ event }: { event: FocusEvent }) => {\n    if (this.preventHide) {\n      this.preventHide = false\n\n      return\n    }\n\n    if (\n      event?.relatedTarget\n      && this.element.parentNode?.contains(event.relatedTarget as Node)\n    ) {\n      return\n    }\n\n    this.hide()\n  }\n\n  createTooltip() {\n    const { element: editorElement } = this.editor.options\n    const editorIsAttached = !!editorElement.parentElement\n\n    if (this.tippy || !editorIsAttached) {\n      return\n    }\n\n    this.tippy = tippy(editorElement, {\n      duration: 0,\n      getReferenceClientRect: null,\n      content: this.element,\n      interactive: true,\n      trigger: 'manual',\n      placement: 'top',\n      hideOnClick: 'toggle',\n      ...this.tippyOptions,\n    })\n\n    // maybe we have to hide tippy on its own blur event as well\n    if (this.tippy.popper.firstChild) {\n      (this.tippy.popper.firstChild as HTMLElement).addEventListener('blur', event => {\n        this.blurHandler({ event })\n      })\n    }\n  }\n\n  update(view: EditorView, oldState?: EditorState) {\n    const { state, composing } = view\n    const { doc, selection } = state\n    const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection)\n\n    if (composing || isSame) {\n      return\n    }\n\n    this.createTooltip()\n\n    // support for CellSelections\n    const { ranges } = selection\n    const from = Math.min(...ranges.map(range => range.$from.pos))\n    const to = Math.max(...ranges.map(range => range.$to.pos))\n\n    const shouldShow = this.shouldShow?.({\n      editor: this.editor,\n      view,\n      state,\n      oldState,\n      from,\n      to,\n    })\n\n    if (!shouldShow) {\n      this.hide()\n\n      return\n    }\n\n    this.tippy?.setProps({\n      getReferenceClientRect: this.tippyOptions?.getReferenceClientRect || (() => {\n        if (isNodeSelection(state.selection)) {\n          const node = view.nodeDOM(from) as HTMLElement\n\n          if (node) {\n            return node.getBoundingClientRect()\n          }\n        }\n\n        return posToDOMRect(view, from, to)\n      }),\n    })\n\n    this.show()\n  }\n\n  show() {\n    this.tippy?.show()\n  }\n\n  hide() {\n    this.tippy?.hide()\n  }\n\n  destroy() {\n    this.tippy?.destroy()\n    this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: true })\n    this.view.dom.removeEventListener('dragstart', this.dragstartHandler)\n    this.editor.off('focus', this.focusHandler)\n    this.editor.off('blur', this.blurHandler)\n  }\n}\n\nexport const BubbleMenuPlugin = (options: BubbleMenuPluginProps) => {\n  return new Plugin({\n    key: typeof options.pluginKey === 'string'\n      ? new PluginKey(options.pluginKey)\n      : options.pluginKey,\n    view: view => new BubbleMenuView({ view, ...options }),\n  })\n}\n","import { Extension } from '@tiptap/core'\n\nimport { BubbleMenuPlugin, BubbleMenuPluginProps } from './bubble-menu-plugin'\n\nexport type BubbleMenuOptions = Omit<BubbleMenuPluginProps, 'editor' | 'element'> & {\n  element: HTMLElement | null,\n}\n\nexport const BubbleMenu = Extension.create<BubbleMenuOptions>({\n  name: 'bubbleMenu',\n\n  addOptions() {\n    return {\n      element: null,\n      tippyOptions: {},\n      pluginKey: 'bubbleMenu',\n      shouldShow: null,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    if (!this.options.element) {\n      return []\n    }\n\n    return [\n      BubbleMenuPlugin({\n        pluginKey: this.options.pluginKey,\n        editor: this.editor,\n        element: this.options.element,\n        tippyOptions: this.options.tippyOptions,\n        shouldShow: this.options.shouldShow,\n      }),\n    ]\n  },\n})\n"]},"metadata":{},"sourceType":"module"}