{"ast":null,"code":"import { Node, mergeAttributes, nodeInputRule } from '@tiptap/core';\nimport { TextSelection } from 'prosemirror-state';\nconst HorizontalRule = Node.create({\n  name: 'horizontalRule',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [{\n      tag: 'hr'\n    }];\n  },\n\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule: () => ({\n        chain\n      }) => {\n        return chain().insertContent({\n          type: this.name\n        }) // set cursor after horizontal rule\n        .command(({\n          tr,\n          dispatch\n        }) => {\n          var _a;\n\n          if (dispatch) {\n            const {\n              $to\n            } = tr.selection;\n            const posAfter = $to.end();\n\n            if ($to.nodeAfter) {\n              tr.setSelection(TextSelection.create(tr.doc, $to.pos));\n            } else {\n              // add node after horizontal rule if it’s the end of the document\n              const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();\n\n              if (node) {\n                tr.insert(posAfter, node);\n                tr.setSelection(TextSelection.create(tr.doc, posAfter));\n              }\n            }\n\n            tr.scrollIntoView();\n          }\n\n          return true;\n        }).run();\n      }\n    };\n  },\n\n  addInputRules() {\n    return [nodeInputRule({\n      find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n      type: this.type\n    })];\n  }\n\n});\nexport { HorizontalRule, HorizontalRule as default };","map":{"version":3,"mappings":";;AAsBa,oBAAc,GAAGA,IAAI,CAACC,MAAL,CAAmC;EAC/DC,IAAI,EAAE,gBADyD;;EAG/DC,UAAU;IACR,OAAO;MACLC,cAAc,EAAE;IADX,CAAP;EAGD,CAP8D;;EAS/DC,KAAK,EAAE,OATwD;;EAW/DC,SAAS;IACP,OAAO,CACL;MAAEC,GAAG,EAAE;IAAP,CADK,CAAP;EAGD,CAf8D;;EAiB/DC,UAAU,CAAC;IAAEJ;EAAF,CAAD,EAAmB;IAC3B,OAAO,CAAC,IAAD,EAAOK,eAAe,CAAC,KAAKC,OAAL,CAAaN,cAAd,EAA8BA,cAA9B,CAAtB,CAAP;EACD,CAnB8D;;EAqB/DO,WAAW;IACT,OAAO;MACLC,iBAAiB,EAAE,MAAM,CAAC;QAAEC;MAAF,CAAD,KAAc;QACrC,OAAOA,KAAK,GACTC,aADI,CACU;UAAEC,IAAI,EAAE,KAAKb;QAAb,CADV;QAAA,CAGJc,OAHI,CAGI,CAAC;UAAEC,EAAF;UAAMC;QAAN,CAAD,KAAqB;;;UAC5B,IAAIA,QAAJ,EAAc;YACZ,MAAM;cAAEC;YAAF,IAAUF,EAAE,CAACG,SAAnB;YACA,MAAMC,QAAQ,GAAGF,GAAG,CAACG,GAAJ,EAAjB;;YAEA,IAAIH,GAAG,CAACI,SAAR,EAAmB;cACjBN,EAAE,CAACO,YAAH,CAAgBC,aAAa,CAACxB,MAAd,CAAqBgB,EAAE,CAACS,GAAxB,EAA6BP,GAAG,CAACQ,GAAjC,CAAhB;YACD,CAFD,MAEO;;cAEL,MAAMC,IAAI,GAAG,SAAG,CAACC,MAAJ,CAAWd,IAAX,CAAgBe,YAAhB,CAA6BC,WAA7B,MAA0C,IAA1C,IAA0CC,aAA1C,GAA0C,MAA1C,GAA0CA,WAAvD;;cAEA,IAAIJ,IAAJ,EAAU;gBACRX,EAAE,CAACgB,MAAH,CAAUZ,QAAV,EAAoBO,IAApB;gBACAX,EAAE,CAACO,YAAH,CAAgBC,aAAa,CAACxB,MAAd,CAAqBgB,EAAE,CAACS,GAAxB,EAA6BL,QAA7B,CAAhB;cACD;YACF;;YAEDJ,EAAE,CAACiB,cAAH;UACD;;UAED,OAAO,IAAP;QACD,CAxBI,EAyBJC,GAzBI,EAAP;MA0BD;IA5BI,CAAP;EA8BD,CApD8D;;EAsD/DC,aAAa;IACX,OAAO,CACLC,aAAa,CAAC;MACZC,IAAI,EAAE,6BADM;MAEZvB,IAAI,EAAE,KAAKA;IAFC,CAAD,CADR,CAAP;EAMD;;AA7D8D,CAAnC,CAAjB","names":["Node","create","name","addOptions","HTMLAttributes","group","parseHTML","tag","renderHTML","mergeAttributes","options","addCommands","setHorizontalRule","chain","insertContent","type","command","tr","dispatch","$to","selection","posAfter","end","nodeAfter","setSelection","TextSelection","doc","pos","node","parent","contentMatch","defaultType","_a","insert","scrollIntoView","run","addInputRules","nodeInputRule","find"],"sources":["../src/horizontal-rule.ts"],"sourcesContent":["import {\n  mergeAttributes,\n  Node,\n  nodeInputRule,\n} from '@tiptap/core'\nimport { TextSelection } from 'prosemirror-state'\n\nexport interface HorizontalRuleOptions {\n  HTMLAttributes: Record<string, any>,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    horizontalRule: {\n      /**\n       * Add a horizontal rule\n       */\n      setHorizontalRule: () => ReturnType,\n    }\n  }\n}\n\nexport const HorizontalRule = Node.create<HorizontalRuleOptions>({\n  name: 'horizontalRule',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [\n      { tag: 'hr' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule: () => ({ chain }) => {\n        return chain()\n          .insertContent({ type: this.name })\n          // set cursor after horizontal rule\n          .command(({ tr, dispatch }) => {\n            if (dispatch) {\n              const { $to } = tr.selection\n              const posAfter = $to.end()\n\n              if ($to.nodeAfter) {\n                tr.setSelection(TextSelection.create(tr.doc, $to.pos))\n              } else {\n                // add node after horizontal rule if it’s the end of the document\n                const node = $to.parent.type.contentMatch.defaultType?.create()\n\n                if (node) {\n                  tr.insert(posAfter, node)\n                  tr.setSelection(TextSelection.create(tr.doc, posAfter))\n                }\n              }\n\n              tr.scrollIntoView()\n            }\n\n            return true\n          })\n          .run()\n      },\n    }\n  },\n\n  addInputRules() {\n    return [\n      nodeInputRule({\n        find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type,\n      }),\n    ]\n  },\n})\n"]},"metadata":{},"sourceType":"module"}