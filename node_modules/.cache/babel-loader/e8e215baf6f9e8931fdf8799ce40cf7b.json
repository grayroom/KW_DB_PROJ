{"ast":null,"code":"import { findWrapping, ReplaceAroundStep, canSplit, liftTarget } from 'prosemirror-transform';\nimport { NodeRange, Fragment, Slice } from 'prosemirror-model';\nimport { Selection } from 'prosemirror-state';\nconst olDOM = [\"ol\", 0],\n      ulDOM = [\"ul\", 0],\n      liDOM = [\"li\", 0];\n/**\nAn ordered list [node spec](https://prosemirror.net/docs/ref/#model.NodeSpec). Has a single\nattribute, `order`, which determines the number at which the list\nstarts counting, and defaults to 1. Represented as an `<ol>`\nelement.\n*/\n\nconst orderedList = {\n  attrs: {\n    order: {\n      default: 1\n    }\n  },\n  parseDOM: [{\n    tag: \"ol\",\n\n    getAttrs(dom) {\n      return {\n        order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1\n      };\n    }\n\n  }],\n\n  toDOM(node) {\n    return node.attrs.order == 1 ? olDOM : [\"ol\", {\n      start: node.attrs.order\n    }, 0];\n  }\n\n};\n/**\nA bullet list node spec, represented in the DOM as `<ul>`.\n*/\n\nconst bulletList = {\n  parseDOM: [{\n    tag: \"ul\"\n  }],\n\n  toDOM() {\n    return ulDOM;\n  }\n\n};\n/**\nA list item (`<li>`) spec.\n*/\n\nconst listItem = {\n  parseDOM: [{\n    tag: \"li\"\n  }],\n\n  toDOM() {\n    return liDOM;\n  },\n\n  defining: true\n};\n\nfunction add(obj, props) {\n  let copy = {};\n\n  for (let prop in obj) copy[prop] = obj[prop];\n\n  for (let prop in props) copy[prop] = props[prop];\n\n  return copy;\n}\n/**\nConvenience function for adding list-related node types to a map\nspecifying the nodes for a schema. Adds\n[`orderedList`](https://prosemirror.net/docs/ref/#schema-list.orderedList) as `\"ordered_list\"`,\n[`bulletList`](https://prosemirror.net/docs/ref/#schema-list.bulletList) as `\"bullet_list\"`, and\n[`listItem`](https://prosemirror.net/docs/ref/#schema-list.listItem) as `\"list_item\"`.\n\n`itemContent` determines the content expression for the list items.\nIf you want the commands defined in this module to apply to your\nlist structure, it should have a shape like `\"paragraph block*\"` or\n`\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\ngiven to assign a group name to the list node types, for example\n`\"block\"`.\n*/\n\n\nfunction addListNodes(nodes, itemContent, listGroup) {\n  return nodes.append({\n    ordered_list: add(orderedList, {\n      content: \"list_item+\",\n      group: listGroup\n    }),\n    bullet_list: add(bulletList, {\n      content: \"list_item+\",\n      group: listGroup\n    }),\n    list_item: add(listItem, {\n      content: itemContent\n    })\n  });\n}\n/**\nReturns a command function that wraps the selection in a list with\nthe given type an attributes. If `dispatch` is null, only return a\nvalue to indicate whether this is possible, but don't actually\nperform the change.\n*/\n\n\nfunction wrapInList(listType, attrs = null) {\n  return function (state, dispatch) {\n    let {\n      $from,\n      $to\n    } = state.selection;\n    let range = $from.blockRange($to),\n        doJoin = false,\n        outerRange = range;\n    if (!range) return false; // This is at the top of an existing list item\n\n    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n      // Don't do anything if this is the top of the list\n      if ($from.index(range.depth - 1) == 0) return false;\n      let $insert = state.doc.resolve(range.start - 2);\n      outerRange = new NodeRange($insert, $insert, range.depth);\n      if (range.endIndex < range.parent.childCount) range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);\n      doJoin = true;\n    }\n\n    let wrap = findWrapping(outerRange, listType, attrs, range);\n    if (!wrap) return false;\n    if (dispatch) dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());\n    return true;\n  };\n}\n\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n  let content = Fragment.empty;\n\n  for (let i = wrappers.length - 1; i >= 0; i--) content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n\n  tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));\n  let found = 0;\n\n  for (let i = 0; i < wrappers.length; i++) if (wrappers[i].type == listType) found = i + 1;\n\n  let splitDepth = wrappers.length - found;\n  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0),\n      parent = range.parent;\n\n  for (let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false) {\n    if (!first && canSplit(tr.doc, splitPos, splitDepth)) {\n      tr.split(splitPos, splitDepth);\n      splitPos += 2 * splitDepth;\n    }\n\n    splitPos += parent.child(i).nodeSize;\n  }\n\n  return tr;\n}\n/**\nBuild a command that splits a non-empty textblock at the top level\nof a list item by also splitting that list item.\n*/\n\n\nfunction splitListItem(itemType) {\n  return function (state, dispatch) {\n    let {\n      $from,\n      $to,\n      node\n    } = state.selection;\n    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) return false;\n    let grandParent = $from.node(-1);\n    if (grandParent.type != itemType) return false;\n\n    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n      // In an empty block. If this is a nested list, the wrapping\n      // list item should be split. Otherwise, bail out and let next\n      // command handle lifting.\n      if ($from.depth == 3 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) return false;\n\n      if (dispatch) {\n        let wrap = Fragment.empty;\n        let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3; // Build a fragment containing empty versions of the structure\n        // from the outer list item to the parent node of the cursor\n\n        for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--) wrap = Fragment.from($from.node(d).copy(wrap));\n\n        let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3; // Add a second list item with an empty default start node\n\n        wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n        let start = $from.before($from.depth - (depthBefore - 1));\n        let tr = state.tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\n        let sel = -1;\n        tr.doc.nodesBetween(start, tr.doc.content.size, (node, pos) => {\n          if (sel > -1) return false;\n          if (node.isTextblock && node.content.size == 0) sel = pos + 1;\n        });\n        if (sel > -1) tr.setSelection(Selection.near(tr.doc.resolve(sel)));\n        dispatch(tr.scrollIntoView());\n      }\n\n      return true;\n    }\n\n    let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n    let tr = state.tr.delete($from.pos, $to.pos);\n    let types = nextType ? [null, {\n      type: nextType\n    }] : undefined;\n    if (!canSplit(tr.doc, $from.pos, 2, types)) return false;\n    if (dispatch) dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n    return true;\n  };\n}\n/**\nCreate a command to lift the list item around the selection up into\na wrapping list.\n*/\n\n\nfunction liftListItem(itemType) {\n  return function (state, dispatch) {\n    let {\n      $from,\n      $to\n    } = state.selection;\n    let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n    if (!range) return false;\n    if (!dispatch) return true;\n    if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\n      return liftToOuterList(state, dispatch, itemType, range);else // Outer list node\n      return liftOutOfList(state, dispatch, range);\n  };\n}\n\nfunction liftToOuterList(state, dispatch, itemType, range) {\n  let tr = state.tr,\n      end = range.end,\n      endOfList = range.$to.end(range.depth);\n\n  if (end < endOfList) {\n    // There are siblings after the lifted items, which must become\n    // children of the last item\n    tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n    range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n  }\n\n  dispatch(tr.lift(range, liftTarget(range)).scrollIntoView());\n  return true;\n}\n\nfunction liftOutOfList(state, dispatch, range) {\n  let tr = state.tr,\n      list = range.parent; // Merge the list items into a single big item\n\n  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n    pos -= list.child(i).nodeSize;\n    tr.delete(pos - 1, pos + 1);\n  }\n\n  let $start = tr.doc.resolve(range.start),\n      item = $start.nodeAfter;\n  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) return false;\n  let atStart = range.startIndex == 0,\n      atEnd = range.endIndex == list.childCount;\n  let parent = $start.node(-1),\n      indexBefore = $start.index(-1);\n  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list)))) return false;\n  let start = $start.pos,\n      end = start + item.nodeSize; // Strip off the surrounding list. At the sides where we're not at\n  // the end of the list, the existing list is closed. At sides where\n  // this is the end, it is overwritten to its end.\n\n  tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n  dispatch(tr.scrollIntoView());\n  return true;\n}\n/**\nCreate a command to sink the list item around the selection down\ninto an inner list.\n*/\n\n\nfunction sinkListItem(itemType) {\n  return function (state, dispatch) {\n    let {\n      $from,\n      $to\n    } = state.selection;\n    let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n    if (!range) return false;\n    let startIndex = range.startIndex;\n    if (startIndex == 0) return false;\n    let parent = range.parent,\n        nodeBefore = parent.child(startIndex - 1);\n    if (nodeBefore.type != itemType) return false;\n\n    if (dispatch) {\n      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n      let inner = Fragment.from(nestedBefore ? itemType.create() : null);\n      let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n      let before = range.start,\n          after = range.end;\n      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());\n    }\n\n    return true;\n  };\n}\n\nexport { addListNodes, bulletList, liftListItem, listItem, orderedList, sinkListItem, splitListItem, wrapInList };","map":{"version":3,"names":["findWrapping","ReplaceAroundStep","canSplit","liftTarget","NodeRange","Fragment","Slice","Selection","olDOM","ulDOM","liDOM","orderedList","attrs","order","default","parseDOM","tag","getAttrs","dom","hasAttribute","getAttribute","toDOM","node","start","bulletList","listItem","defining","add","obj","props","copy","prop","addListNodes","nodes","itemContent","listGroup","append","ordered_list","content","group","bullet_list","list_item","wrapInList","listType","state","dispatch","$from","$to","selection","range","blockRange","doJoin","outerRange","depth","type","compatibleContent","startIndex","index","$insert","doc","resolve","endIndex","parent","childCount","end","wrap","doWrapInList","tr","scrollIntoView","wrappers","joinBefore","empty","i","length","from","create","step","found","splitDepth","splitPos","e","first","split","child","nodeSize","splitListItem","itemType","isBlock","sameParent","grandParent","size","indexAfter","depthBefore","d","depthAfter","createAndFill","before","replace","after","sel","nodesBetween","pos","isTextblock","setSelection","near","nextType","contentMatchAt","defaultType","delete","types","undefined","liftListItem","firstChild","liftToOuterList","liftOutOfList","endOfList","lift","list","$start","item","nodeAfter","mapping","map","atStart","atEnd","indexBefore","canReplace","sinkListItem","nodeBefore","nestedBefore","lastChild","inner","slice"],"sources":["/Users/jeonghoon/Desktop/vue/cloud-his-frontend/node_modules/prosemirror-schema-list/dist/index.js"],"sourcesContent":["import { findWrapping, ReplaceAroundStep, canSplit, liftTarget } from 'prosemirror-transform';\nimport { NodeRange, Fragment, Slice } from 'prosemirror-model';\nimport { Selection } from 'prosemirror-state';\n\nconst olDOM = [\"ol\", 0], ulDOM = [\"ul\", 0], liDOM = [\"li\", 0];\n/**\nAn ordered list [node spec](https://prosemirror.net/docs/ref/#model.NodeSpec). Has a single\nattribute, `order`, which determines the number at which the list\nstarts counting, and defaults to 1. Represented as an `<ol>`\nelement.\n*/\nconst orderedList = {\n    attrs: { order: { default: 1 } },\n    parseDOM: [{ tag: \"ol\", getAttrs(dom) {\n                return { order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1 };\n            } }],\n    toDOM(node) {\n        return node.attrs.order == 1 ? olDOM : [\"ol\", { start: node.attrs.order }, 0];\n    }\n};\n/**\nA bullet list node spec, represented in the DOM as `<ul>`.\n*/\nconst bulletList = {\n    parseDOM: [{ tag: \"ul\" }],\n    toDOM() { return ulDOM; }\n};\n/**\nA list item (`<li>`) spec.\n*/\nconst listItem = {\n    parseDOM: [{ tag: \"li\" }],\n    toDOM() { return liDOM; },\n    defining: true\n};\nfunction add(obj, props) {\n    let copy = {};\n    for (let prop in obj)\n        copy[prop] = obj[prop];\n    for (let prop in props)\n        copy[prop] = props[prop];\n    return copy;\n}\n/**\nConvenience function for adding list-related node types to a map\nspecifying the nodes for a schema. Adds\n[`orderedList`](https://prosemirror.net/docs/ref/#schema-list.orderedList) as `\"ordered_list\"`,\n[`bulletList`](https://prosemirror.net/docs/ref/#schema-list.bulletList) as `\"bullet_list\"`, and\n[`listItem`](https://prosemirror.net/docs/ref/#schema-list.listItem) as `\"list_item\"`.\n\n`itemContent` determines the content expression for the list items.\nIf you want the commands defined in this module to apply to your\nlist structure, it should have a shape like `\"paragraph block*\"` or\n`\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\ngiven to assign a group name to the list node types, for example\n`\"block\"`.\n*/\nfunction addListNodes(nodes, itemContent, listGroup) {\n    return nodes.append({\n        ordered_list: add(orderedList, { content: \"list_item+\", group: listGroup }),\n        bullet_list: add(bulletList, { content: \"list_item+\", group: listGroup }),\n        list_item: add(listItem, { content: itemContent })\n    });\n}\n/**\nReturns a command function that wraps the selection in a list with\nthe given type an attributes. If `dispatch` is null, only return a\nvalue to indicate whether this is possible, but don't actually\nperform the change.\n*/\nfunction wrapInList(listType, attrs = null) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to), doJoin = false, outerRange = range;\n        if (!range)\n            return false;\n        // This is at the top of an existing list item\n        if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n            // Don't do anything if this is the top of the list\n            if ($from.index(range.depth - 1) == 0)\n                return false;\n            let $insert = state.doc.resolve(range.start - 2);\n            outerRange = new NodeRange($insert, $insert, range.depth);\n            if (range.endIndex < range.parent.childCount)\n                range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);\n            doJoin = true;\n        }\n        let wrap = findWrapping(outerRange, listType, attrs, range);\n        if (!wrap)\n            return false;\n        if (dispatch)\n            dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());\n        return true;\n    };\n}\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n    let content = Fragment.empty;\n    for (let i = wrappers.length - 1; i >= 0; i--)\n        content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));\n    let found = 0;\n    for (let i = 0; i < wrappers.length; i++)\n        if (wrappers[i].type == listType)\n            found = i + 1;\n    let splitDepth = wrappers.length - found;\n    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;\n    for (let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false) {\n        if (!first && canSplit(tr.doc, splitPos, splitDepth)) {\n            tr.split(splitPos, splitDepth);\n            splitPos += 2 * splitDepth;\n        }\n        splitPos += parent.child(i).nodeSize;\n    }\n    return tr;\n}\n/**\nBuild a command that splits a non-empty textblock at the top level\nof a list item by also splitting that list item.\n*/\nfunction splitListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to, node } = state.selection;\n        if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to))\n            return false;\n        let grandParent = $from.node(-1);\n        if (grandParent.type != itemType)\n            return false;\n        if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth == 3 || $from.node(-3).type != itemType ||\n                $from.index(-2) != $from.node(-2).childCount - 1)\n                return false;\n            if (dispatch) {\n                let wrap = Fragment.empty;\n                let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--)\n                    wrap = Fragment.from($from.node(d).copy(wrap));\n                let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1\n                    : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n                // Add a second list item with an empty default start node\n                wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n                let start = $from.before($from.depth - (depthBefore - 1));\n                let tr = state.tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\n                let sel = -1;\n                tr.doc.nodesBetween(start, tr.doc.content.size, (node, pos) => {\n                    if (sel > -1)\n                        return false;\n                    if (node.isTextblock && node.content.size == 0)\n                        sel = pos + 1;\n                });\n                if (sel > -1)\n                    tr.setSelection(Selection.near(tr.doc.resolve(sel)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n        let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        let tr = state.tr.delete($from.pos, $to.pos);\n        let types = nextType ? [null, { type: nextType }] : undefined;\n        if (!canSplit(tr.doc, $from.pos, 2, types))\n            return false;\n        if (dispatch)\n            dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n        return true;\n    };\n}\n/**\nCreate a command to lift the list item around the selection up into\na wrapping list.\n*/\nfunction liftListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        if (!dispatch)\n            return true;\n        if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\n            return liftToOuterList(state, dispatch, itemType, range);\n        else // Outer list node\n            return liftOutOfList(state, dispatch, range);\n    };\n}\nfunction liftToOuterList(state, dispatch, itemType, range) {\n    let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);\n    if (end < endOfList) {\n        // There are siblings after the lifted items, which must become\n        // children of the last item\n        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n        range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n    }\n    dispatch(tr.lift(range, liftTarget(range)).scrollIntoView());\n    return true;\n}\nfunction liftOutOfList(state, dispatch, range) {\n    let tr = state.tr, list = range.parent;\n    // Merge the list items into a single big item\n    for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n        pos -= list.child(i).nodeSize;\n        tr.delete(pos - 1, pos + 1);\n    }\n    let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;\n    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)\n        return false;\n    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;\n    let parent = $start.node(-1), indexBefore = $start.index(-1);\n    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))\n        return false;\n    let start = $start.pos, end = start + item.nodeSize;\n    // Strip off the surrounding list. At the sides where we're not at\n    // the end of the list, the existing list is closed. At sides where\n    // this is the end, it is overwritten to its end.\n    tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty)))\n        .append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n    dispatch(tr.scrollIntoView());\n    return true;\n}\n/**\nCreate a command to sink the list item around the selection down\ninto an inner list.\n*/\nfunction sinkListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        let startIndex = range.startIndex;\n        if (startIndex == 0)\n            return false;\n        let parent = range.parent, nodeBefore = parent.child(startIndex - 1);\n        if (nodeBefore.type != itemType)\n            return false;\n        if (dispatch) {\n            let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n            let inner = Fragment.from(nestedBefore ? itemType.create() : null);\n            let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n            let before = range.start, after = range.end;\n            dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true))\n                .scrollIntoView());\n        }\n        return true;\n    };\n}\n\nexport { addListNodes, bulletList, liftListItem, listItem, orderedList, sinkListItem, splitListItem, wrapInList };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}